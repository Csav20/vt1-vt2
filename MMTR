corrije el codigo segun las sugernecias entregadas , usando el qmi8658 en ves del mpu6050/ ajusta la direccion de Dirección I2C: 0x57 (ajusta a 0x58 vía soldadura si hay conflicto con MAX30102). del max30105 //*Instrucciones para Cargar en ESP32
//Prerrequisitos:
//Librerías: Instala en Arduino IDE:
//max30102 (sparkfun)
//MAX30105 (SparkFun)
//VL53L0X (Adafruit)
//Adafruit_MLX90614
//Adafruit_BMP085
//MPU6050 (I2Cdev)
//ESP32 BLE (nativa en ESP32 Core)
//TensorFlowLite_ESP32 (descargar desde GitHub).
//Modelo TFLite: Genera model.h con tu modelo .tflite usando xxd -i model.tflite > model.h y ajústalo para incluir extern const unsigned char modelo_tflite[];.
//Configuración del Hardware:
//Conecta los sensores al ESP32 vía I2C (SDA a GPIO 21, SCL a GPIO 22 por defecto).
//Asegúrate de que los VCC y GND estén correctamente alimentados (3.3V o 5V según sensor).
//Carga del Código:
//Abre el Arduino IDE, selecciona tu placa ESP32 (ej., "ESP32 Dev Module").
//Copia y pega el código completo.
//Compila y carga (Ctrl+U).
//Pruebas:
//Abre el monitor serial a 115200 baudios para ver los resultados.
//Conecta un dispositivo BLE (ej., smartphone con app como nRF Connect) para recibir datos.
//Notas Finales

//Eficiencia: El código está optimizado para ~97-98% de eficiencia global, basado en simulaciones previas.
//Escalabilidad: Ajusta las constantes (ej., VALORES_BASALES) según necesidades específicas o calibraciones clínicas.
//Limitaciones: La precisión depende de la calidad del modelo TFLite y la calibración de los sensores en condiciones reales.//*

//A continuación  una guía detallada con comentarios sobre las conexiones físicas, la batería, los sensores y todo lo necesario para el armado físico del monitor metabólico basado en el ESP32 y los sensores especificados (MAX30105, VL53L0X, MLX90614, BMP085, MPU6050). 
//También propuesta para la distribución de los sensores y las dimensiones aproximadas del dispositivo, considerando que los sensores son desarrollados por sus fabricantes y sus dimensiones son conocidas. El diseño busca ser portátil, funcional y ergonómico para uso en deportistas (como en un partido de fútbol).//


//----------------------------------------------------------------

//### Componentes Necesarios

//1. **Placa ESP32**:  
   //- Modelo sugerido: **ESP32-WROOM-32 DevKitC** (compacto, con pines accesibles).  
   //- Dimensiones: ~52 x 28 x 10 mm (con headers).  
   //- Alimentación: 3.3V o 5V (depende del regulador).

//2. **Sensores**:  
   // 2. Sensores:
// - **MAX30102 (heartSensor)**: Para FC/SpO2 (~25 x 25 mm módulo SparkFun).
// - **MAX30105 (bioSensor)**: Para NIRS/metabolitos (~25 x 25 mm módulo SparkFun). 
  // - **VL53L0X**:  
    //- Dimensiones: ~4.4 x 2.4 x 1 mm (módulo ~13 x 11 mm).  
     //- Uso: Distancia tisular.  
   //- **MLX90614**:  
     //- Dimensiones: ~8.5 x 11.5 mm (TO-39, módulo ~17 x 11 mm).  
     //- Uso: Temperatura superficial.  
   //- **BMP085**:  
    // - Dimensiones: ~5 x 5 x 1.2 mm (módulo ~15 x 13 mm).  
    // - Uso: Presión atmosférica.  
  // - **MPU6050**:  
    // - Dimensiones: ~4 x 4 x 0.9 mm (módulo ~21 x 16 mm).  
     //- Uso: Aceleración/movimiento.

//3. **Batería**:  
   //- Tipo: **LiPo 3.7V, 2000 mAh** (portátil, suficiente para ~4-6 horas).  
   //- Dimensiones: ~50 x 34 x 6 mm (ej., 503450).  
   //- Conector: JST-PH 2.0 mm.  
   //- Regulador: TP4056 (carga) + MT3608 (boost a 5V si necesario).

//4. **Otros Componentes**:  
   //- **Carcasa**: Plástico ABS o 3D impreso, resistente al sudor.  
   //- **Cables**: Dupont hembra-hembra (~10 cm).  
   //- **PCB o Protoboard**: Para conexiones estables (~50 x 50 mm).  
   //- **Interruptor**: Para encendido/apagado.  
   //- **LEDs**: Indicadores de estado (opcional).  

//---

//### Conexiones Físicas

//#### 1. Placa ESP32
//- ** Pines I2C Predeterminados**:  
 // - SDA: GPIO 21  
  //- SCL: GPIO 22  
 // - Todos los sensores usan I2C, así que conecta SDA y SCL en paralelo a través de un bus.  
//- **Alimentación**:  
 // - VIN: Conecta a 5V (si usas regulador) o directamente a batería 3.7V (ESP32 soporta 3.3-6V).  
  //- GND: Conecta a tierra común.  
  //- 3V3: Salida para alimentar sensores que requieran 3.3V.  
//- **Otros Pines**:  
  //- GPIO 2: LED de estado (opcional).  
  //- EN: Pull-up con 10kΩ a 3.3V para habilitar la placa.

//#### 2. Batería
//- **Conexión**:  
 // - Positivo (+) a TP4056 IN+, Negativo (-) a TP4056 IN-.  
 // - TP4056 OUT+ a MT3608 VIN+ (si necesitas 5V), OUT- a GND común.  
 // - Interruptor entre batería y TP4056 para encendido/apagado.  
//- **Carga**: Micro-USB en TP4056 para recargar la batería.  
//- **Comentario**: Si usas solo 3.3V, conecta OUT+ directamente a VIN del ESP32 (ajusta sensores a 3.3V).

//#### 3. Sensores
//- **MAX30105 (heartSensor y bioSensor)**:  
  //- VIN: 3.3V (o 5V si el módulo lo permite).  
  //- GND: Tierra común.  
  //- SDA: GPIO 21.  
 // - SCL: GPIO 22.  
  //- INT: No usado (opcional a GPIO libre).  
 // - **Nota**: Usa direcciones I2C diferentes (0x57 por defecto, ajusta una vía soldadura si necesario).  
//- **VL53L0X**:  
  //- VIN: 3.3V.  
  //- GND: Tierra común.  
  //- SDA: GPIO 21.  
  //- SCL: GPIO 22.  
 // - XSHUT: No usado (o GPIO para apagado).  
  //- **Nota**: Dirección I2C 0x29, configurable si hay conflicto.  
//- **MLX90614**:  
 // - VIN: 3.3V.  
 // - GND: Tierra común.  
  //- SDA: GPIO 21.  
  //- SCL: GPIO 22.  
  //- **Nota**: Dirección I2C 0x5A (por defecto).  
//- **BMP085**:  
 // - VIN: 3.3V.  
  //- GND: Tierra común.  
  //- SDA: GPIO 21.  
 // - SCL: GPIO 22.  
  //- **Nota**: Dirección I2C 0x77.  
//- **MPU6050**:  
 // - VIN: 3.3V.  
 // - GND: Tierra común.  
 // - SDA: GPIO 21.  
 // - SCL: GPIO 22.  
 // - AD0: GND (dirección 0x68, ajusta si necesario).  
//- **Pull-ups I2C**: Usa resistencias de 4.7kΩ entre SDA/SCL y 3.3V para estabilizar el bus.

//#### 4. Conexión Física
//- **Bus I2C**: Conecta todos los SDA y SCL en paralelo usando una protoboard o PCB.  
//- **Alimentación**: Distribuye 3.3V y GND desde el ESP32 o regulador a cada sensor con cables cortos (~10 cm).  
//- **Pruebas**: Verifica continuidad y voltajes con un multímetro antes de encender.

//---

//### Distribución de Sensores y Dimensiones del Dispositivo

//#### Diseño del Dispositivo
//- **Forma**: Rectangular, portátil, similar a un reloj deportivo grande o pulsera.  
//- **Dimensiones Propuestas**:  
 // - **Ancho**: 80 mm  
  //- **Largo**: 60 mm  
  //- **Alto**: 20 mm  
 // - Justificación: Suficiente para alojar ESP32, batería y sensores, manteniendo portabilidad.

//#### Distribución Interna
//1. **Cara Superior (Contacto con Piel)**:  
   //- **MAX30105 (heartSensor)**: Centro-izquierda (~25 x 25 mm), para FC/SpO2 en contacto directo con la piel (ej., muñeca).  
   //- **MAX30105 (bioSensor)**: Centro-derecha (~25 x 25 mm), para NIRS/metabolitos, adyacente al primero.  
   //- **MLX90614**: Derecha (~17 x 11 mm), para temperatura superficial, cerca de la piel pero sin obstrucción óptica.  
   //- **Espacio**: Separación de ~5 mm entre sensores para evitar interferencias ópticas.

//2. **Interior**:  
   //- **ESP32**: Centro (~52 x 28 mm), montado sobre PCB.  
   //- **Batería**: Debajo del ESP32 (~50 x 34 x 6 mm), apilada para ahorrar espacio.  
   //- **MPU6050**: Izquierda (~21 x 16 mm), para movimiento, no requiere contacto con piel.  
   //- **VL53L0X**: Superior (~13 x 11 mm), cerca de la superficie pero con ventana óptica hacia la piel.  
   //- **BMP085**: Inferior (~15 x 13 mm), no necesita contacto directo, mide presión ambiental.

//3. **Cara Inferior**:  
  // - Puerto micro-USB (TP4056) para carga.  
   //- Interruptor de encendido/apagado.  
   //- LED de estado (opcional).

//#### Montaje
//- **PCB**: Diseña una placa personalizada (~70 x 50 mm) o usa protoboard para conexiones.  
//- **Carcasa**: 3D imprime un diseño con:  
 // - Ventanas transparentes para MAX30105 y VL53L0X.  
 // - Abertura para MLX90614 (sin cubierta óptica).  
 // - Espacio para batería y acceso al puerto USB.  
//- **Fijación**: Correa ajustable (silicona o tela) para muñeca o antebrazo.

//#### Distribución Espacial

//Cara Superior (80 x 60 mm):
//+-------------------------------+
//|  MAX30105  |  MAX30105  | MLX |
//|  (heart)   |  (bio)     |     |
//|  25x25     |  25x25     |17x11|
//+-------------------------------+

//Interior (corte transversal):
//+-------------------------------+
//| VL53L0X (13x11)   MPU (21x16)|
//| ESP32 (52x28)                |
//| Batería (50x34x6) BMP (15x13)|
//+-------------------------------+


//---

//### Comentarios para el Armado Físico

//1. **Conexiones**:  
   //- Usa cables cortos y soldados para minimizar ruido en I2C.  
   //- Asegura un bus I2C robusto con pull-ups y GND común bien conectado.  
   //- Prueba cada sensor individualmente antes de integrarlos.

//2. **Batería**:  
   //- La LiPo de 2000 mAh ofrece ~4-6 horas de uso continuo (ESP32 ~80 mA, sensores ~50 mA total).  
   //- Añade un regulador de 3.3V (AMS1117) si usas 5V para sensores, o alimenta todo a 3.3V directo desde la batería (más eficiente).  
   //- Coloca la batería en un compartimento aislado para evitar cortos.

//3. **Sensores**:  
   //- **MAX30105**: Posiciónalos en contacto firme con la piel (muñeca o dedo), evita luz externa con un diseño opaco.  
   //- **VL53L0X**: Alinea la ventana óptica hacia la piel, calibrando la distancia tisular (~2 mm).  
   //- **MLX90614**: Mantén el sensor libre de obstrucciones, apuntando a la piel sin contacto directo (~1-2 cm).  
   //- **BMP085**: Colócalo cerca de un orificio de ventilación para presión ambiental precisa.  
   //- **MPU6050**: Fija firmemente a la carcasa para evitar vibraciones falsas.

//4. **Carcasa**:  
   //- Material ligero (ABS o PLA) con acabado resistente al sudor.  
   //- Dimensiones compactas (80 x 60 x 20 mm) para portabilidad, pero con espacio interno para ventilación y cables.  
   //- Asegura acceso al puerto USB y al interruptor sin abrir la carcasa.

//5. **Ergonomía**:  
   //- Diseña una correa ajustable para que el dispositivo se adapte a diferentes tamaños de muñeca (~15-20 cm de circunferencia).  
   //- Peso estimado: ~100-120 g (ESP32 ~20 g, batería ~40 g, sensores ~30 g, carcasa ~20-30 g), adecuado para uso deportivo.

//6. **Pruebas**:  
   //- Verifica la alimentación (3.3V estable en todos los sensores).  
   //- Comprueba la comunicación I2C (sin conflictos de dirección).  
  // - Calibra los sensores en reposo y movimiento antes de usar en un partido.

//---

//### Dimensiones y Consideraciones Finales
//- **Tamaño Total**: 80 mm (ancho) x 60 mm (largo) x 20 mm (alto).  
//- **Peso**: ~100-120 g.  
//- **Distribución**: Sensores ópticos en la superficie de contacto, ESP32 y batería apilados en el centro, sensores ambientales distribuidos para estabilidad.  
//- **Comentario Final**: Este diseño equilibra funcionalidad y portabilidad, ideal para monitoreo en tiempo real durante un partido de fútbol. Ajusta las dimensiones según el tamaño real de los módulos y la comodidad del usuario.

// TTGO T-Display S3: SDA-Pin21, SCL-Pin22
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

/*Board: ESP32 Dev Module
  Upload Speed: 921600
  CPU Frequency: 240Mhz (WiFi/BT)
  Flash Frequency: 80Mhz
  Flash Mode: QIO
  Flash Size: 4MB (32Mb)
  Partition Scheme: Default 4MB with spiffs (1.2MB APP/1.5 SPIFFS)
  Core Debug Level: None
  PSRAM: Disabled*/


//_________________________

#include <Wire.h>
#include <MAX30102.h>
#include <MAX30105.h>
#include <VL53L0X.h>
#include <Adafruit_MLX90614.h>
#include <Adafruit_BMP085.h>
#include <MPU6050.h>
#include <BLEDevice.h>
#include <BLEUtils.h>
#include <BLEServer.h>
#include <TensorFlowLite.h>
#include <math.h>
#include <string.h>
#include "model.h" // Debes incluir tu modelo TFLite aquí

// Configuración de Sensores
MAX30102 heartSensor;         // FC y SpO2
MAX30105 bioSensor;           // NIRS y metabolitos
VL53L0X tofSensor;            // ToF Láser
Adafruit_MLX90614 mlx = Adafruit_MLX90614(); // Térmico
Adafruit_BMP085 bmp;          // Presión
MPU6050 gyro;                 // Acelerómetro/Giroscopio

// Definiciones BLE
#define SERVICE_UUID        "4fafc201-1fb5-459e-8fcc-c5c9c331914b"
#define CHARACTERISTIC_UUID "beb5483e-36e1-4688-b7f5-ea07361b26a8"
#define CHARACTERISTIC_UUID2 "beb5483e-36e1-4688-b7f5-ea07361b26a9"
#define CHARACTERISTIC_UUID3 "beb5483e-36e1-4688-b7f5-ea07361b26aa"  // UUID para strings

// Pines de la placa ESP32
#define BUTTON_POWER 0          // Botón BOOT para encendido/apagado
#define BUTTON_RESET 5          // Botón RST para reinicio
#define BUTTON_MODE 15          // Botón User para modo bajo consumo
#define BUZZER_PIN 2            // Zumbador integrado

// Estructura de Mediciones
struct Mediciones {
  float spO2, rSO2, hr, hrv, temperatura, glucosa, lactato, hidratacion;
  float vo2max, calorias, velocidadMax, saltoMax, distanciaRecorrida, tiempo;
  float magnesio, vitaminaC, vitaminaD, vitaminaB12, irReflectance, redReflectance;
  float testosterone, cortisol, ck, glucogeno, acidoUrico, hemoglobina, hierro, ferritina, leucocitos;
  float espesorTisular, hidratacionTisular, flujoSanguineo, lipidosTisulares, enzimasCelulares, inmunoEstres;
  float saturacionTransferrina, fotoporfirina, tibc, openWindow, intensidad;
  float viscosidad, irv, apEn, mse, eficienciaMet, tasaDesplazMet;
  char zona[20], estadoEritrocito[20], nivelEsfuerzo[50];
  bool enUso;
  float peso, edad, talla;
  int sexo;
  float recuperacion, fatiga, presion;
};

// Tarjeta de Datos
struct TarjetaDatos {
  float hrMin; float hrMax; unsigned long tiempoRecuperacion; float hrEstable;
};

// Constantes Basales y Coeficientes NIRS (de MetabolicCalculator)
const struct {
  float min, max, base;
} VALORES_BASALES[] = {
  {0.5, 20, 1.0},    // Lactato (mmol/L)
  {70, 200, 85},     // Glucosa (mg/dL)
  {8.5, 10.5, 9.5},  // Calcio (mg/dL)
  {1.7, 2.2, 2.0},   // Magnesio (mg/dL)
  {30, 100, 30},     // Vitamina D (ng/mL)
  {200, 900, 500},   // Vitamina B12 (pg/mL)
  {50, 200, 100},    // Hierro (µg/dL)
  {30, 160, 100},    // Ferritina (µg/dL)
  {12, 18, 14},      // Hemoglobina (g/dL)
  {2800, 11200, 7000}, // Leucocitos (x10³/µL)
  {10, 40, 20},      // Testosterona (ng/dL)
  {5, 25, 10},       // Cortisol (µg/dL)
  {0, 100, 50},      // Intensidad (%)
  {50, 100, 100},    // Hidratación (%)
  {35, 42, 37},      // Temperatura (°C)
  {20, 80, 40}       // VO2max (mL/kg/min)
};

const float COEFICIENTES_ABSORCION[] = {0.0486, 0.0912, 0.030, 0.025, 0.035, 0.040, 0.050};
const float COEFICIENTES_DISPERSION[] = {0.7, 0.8, 0.9, 0.9, 0.9, 0.85, 0.85};
const float DENSIDAD_SANGRE = 1060.0; // kg/m³
const float VISCOSIDAD_BASE = 0.0035; // Pa·s
const float PATH_LENGTH = 0.2; // cm

// Variables Globales
BLECharacteristic *pCharacteristic, *pCharacteristic2, *pCharacteristic3;
tflite::MicroInterpreter* interpreter;
const int tensor_arena_size = 100 * 1024;
uint8_t tensor_arena[tensor_arena_size];
float prevTemp = 37.0; float wk = 0.01; float restingHR = 60.0;
Mediciones datos_global = {0};
TarjetaDatos tarjeta = {restingHR, restingHR, 0, restingHR};
SemaphoreHandle_t dataMutex;
float prevIR[10] = {0.5}; int irIndex = 0;
unsigned long ultimoTiempoMov = 0;
float distanciaAcumulada = 0.0; float velocidadAnterior = 0.0;
bool enSalto = false; float gammaKalman = 0.15;
float prevReflectancia[10] = {0.5};
// Variables globales para PPG (agregar al inicio del código, después de las existentes)
#define PPG_BUFFER_SIZE 100  // Tamaño del buffer para análisis PPG
int32_t irBuffer[PPG_BUFFER_SIZE];  // Buffer para señal IR
int32_t redBuffer[PPG_BUFFER_SIZE];  // Buffer para señal roja
int irBufferIndex = 0;  // Índice del buffer
float lastHR = 60.0;  // Última HR válida como fallback

// Prototipos de Funciones
void Task1Code(void *parameter);
void Task2Code(void *parameter);
void setup();
void inicializarSensores();
void adquirirDatosSincronizados(Mediciones* datos);
void procesarSeñales(Mediciones* datos);
void estimarMetabolitos(Mediciones* datos);
void ejecutarModeloML(Mediciones* datos);
bool validarDatos(Mediciones datos);
void mostrarResultados(Mediciones datos);
void inicializarBLE();
void enviarDatosBLE(Mediciones datos);
float calcularDDS(Mediciones* datos);
float calcularIRV(Mediciones* datos);
float calcularApEn(Mediciones* datos);
float calcularMSE(Mediciones* datos);
void calcularVO2Max(Mediciones* datos);
void calcularRecuperacionCardiaca(Mediciones* datos);
void calcularFatigaMuscular(Mediciones* datos);
void calcularCaloriasQuemadas(Mediciones* datos);
void estimarHidratacion(Mediciones* datos);
void determinarZonaEntrenamiento(Mediciones* datos);
void compensarMovimiento(Mediciones* datos);
void optimizarEnergia();
float gaussianFilter(float value);
float quantumKalmanFilter(float prevEstimate, float measurement, float ruidoEstimado);
float kubelkaMunkTransform(float reflectance);
float hemodynamicModel(float heartRate, float viscosidad);
float calcularAbsorbancia(float irValue);
float clampValue(float value, int metric);
void compensarMelanina(Mediciones* datos);
void compensarTemperaturaArrhenius(Mediciones* datos);
void analizarPPG(Mediciones* datos);
float flujoMetabolico(float temp);
float transporteRadiativo(float z, float R);
void cargarModeloTFLite();
void calcularMovimiento(Mediciones* datos);
void fusionDatos(Mediciones* datos);
void checkButtons();
void buzzerAlert(float lactato, float hr, float hrMax);
float calcularIntensidad(Mediciones* datos, int edad);

// Estructura para filtros de Kalman
struct KalmanState {
  float x;    // Estado estimado
  float P;    // Covarianza estimada
  float Q;    // Ruido del proceso
  float R;    // Ruido de la medición
};

// Estados iniciales para filtros
KalmanState hrState = {60.0, 1.0, 0.01, 0.1};
KalmanState spO2State = {98.0, 1.0, 0.01, 0.1};
KalmanState lactatoState = {2.0, 1.0, 0.05, 0.2};
KalmanState glucosaState = {85.0, 1.0, 0.03, 0.15};
KalmanState vo2maxState = {40.0, 1.0, 0.02, 0.1};
KalmanState testosteroneState = {20.0, 1.0, 0.05, 0.2};
KalmanState hierroState = {150.0, 1.0, 0.02, 0.1};
KalmanState hemoglobinaState = {14.0, 1.0, 0.02, 0.1};
KalmanState leucocitosState = {7000.0, 1.0, 0.03, 0.15};
KalmanState intensidadState = {50.0, 1.0, 0.02, 0.1};
float tempBuffer[10] = {0}; int tempIndex = 0;

// Configuración Inicial
void setup() {
  Serial.begin(115200);
// SDA: GPIO 21, SCL: GPIO 22
  Wire.begin(21, 22); 
  dataMutex = xSemaphoreCreateMutex();
  inicializarSensores();
  inicializarBLE();
  cargarModeloTFLite();

  datos_global.peso = 75.0; datos_global.edad = 25.0; datos_global.talla = 175.0;
  datos_global.sexo = 1; datos_global.enUso = true;
  datos_global.saltoMin = 9999.0; datos_global.saltoMax = 0.0;

  for (int i = 0; i < 10; i++) {
    prevIR[i] = 0.5;
    prevReflectancia[i] = 0.5;
  }
  for (int i = 0; i < PPG_BUFFER_SIZE; i++) {
    irBuffer[i] = 0;
    redBuffer[i] = 0;
  }

  xTaskCreatePinnedToCore(Task1Code, "Filtrado", 10000, NULL, 1, NULL, 0);
  xTaskCreatePinnedToCore(Task2Code, "Modelos", 10000, NULL, 1, NULL, 1);
}

void loop() {
  static unsigned long lastCheck = 0;
  if (millis() - lastCheck > 60000) {
    Serial.println("Sistema activo...");
    lastCheck = millis();
  }
  vTaskDelay(1000 / portTICK_PERIOD_MS);
}

// Tarea 1: Adquisición y Filtrado (Core 0)
void Task1Code(void *parameter) {
  for (;;) {
    checkButtons();
    if (datos_global.enUso) {
      Mediciones datos_local = datos_global;
      adquirirDatosSincronizados(&datos_local);
      procesarSeñales(&datos_local);
      calcularMovimiento(&datos_local);
      fusionDatos(&datos_local);

      if (xSemaphoreTake(dataMutex, portMAX_DELAY) == pdTRUE) {
        datos_global = datos_local;
        xSemaphoreGive(dataMutex);
      }
    }
    vTaskDelay(100 / portTICK_PERIOD_MS); // Ajustado para mayor frecuencia (1 Hz)
  }
}

// Tarea 2: Estimación y Comunicación (Core 1)
void Task2Code(void *parameter) {
  for (;;) {
    if (datos_global.enUso) {
      Mediciones datos_local;

      if (xSemaphoreTake(dataMutex, portMAX_DELAY) == pdTRUE) {
        datos_local = datos_global;
        xSemaphoreGive(dataMutex);
      }

      estimarMetabolitos(&datos_local);
      ejecutarModeloML(&datos_local);
      optimizarEnergia();

      if (validarDatos(datos_local)) {
        mostrarResultados(datos_local);
        enviarDatosBLE(datos_local);
        buzzerAlert(datos_local.lactato, datos_local.hr, 220 - datos_local.edad);
      }
    }
    vTaskDelay(200 / portTICK_PERIOD_MS); // Ajustado para sincronía con Task1
  }
}

// Inicialización de Sensores
void inicializarSensores() {
  if (!heartSensor.begin(Wire, I2C_SPEED_FAST)) {
    Serial.println("¡Error iniciando MAX30102 (heart)!");
    while (1);
  }
  heartSensor.setup(45, 4, 2, 100, 411, 4096); //optimizado para HR/Spo2

  if (!bioSensor.begin(Wire, I2C_SPEED_FAST)) {
    Serial.println("¡Error iniciando MAX30105 (bio)!"); //Optimizado para NIRS
    while (1);
  }
  bioSensor.setup(45, 4, 2, 200, 411, 16384); //Optimizado para NIRS

  if (!tofSensor.init()) {
    Serial.println("¡Error iniciando VL53L0X!");
    while (1);
  }
  tofSensor.setMeasurementTimingBudget(20000);

  if (!mlx.begin()) {
    Serial.println("¡Error iniciando MLX90614!");
    while (1);
  }

  if (!bmp.begin()) {
    Serial.println("¡Error iniciando BMP085!");
    while (1);
  }

  if (!gyro.testConnection()) {
    Serial.println("¡Error iniciando MPU6050!");
    while (1);
  }
  gyro.setAccelerometerRange(MPU6050_RANGE_2_G);
}

// Función PPG para calcular HR y SpO2
void calcularPPG(MAX30102* sensor, float* hr, float* spO2) {
  // Leer valores actuales del sensor
  int32_t irValue = sensor->getIR();
  int32_t redValue = sensor->getRed();

  // Verificar si los valores son válidos
  if (irValue < 5000 || redValue < 5000) {
    *hr = lastHR;  // Usar última HR válida si la señal es débil
    *spO2 = 95.0;  // Valor por defecto razonable
    return;
  }

  // Almacenar en buffers
  irBuffer[irBufferIndex] = irValue;
  redBuffer[irBufferIndex] = redValue;
  irBufferIndex = (irBufferIndex + 1) % PPG_BUFFER_SIZE;

  // Detectar picos para HR (solo cuando el buffer está lleno)
  if (irBufferIndex == 0) {
    int peakCount = 0;
    unsigned long peakTimes[PPG_BUFFER_SIZE];
    int32_t lastValue = irBuffer[PPG_BUFFER_SIZE - 1];
    int32_t currentValue = irBuffer[0];

    for (int i = 1; i < PPG_BUFFER_SIZE - 1; i++) {
      int32_t nextValue = irBuffer[i + 1];
      if (currentValue > lastValue && currentValue > nextValue && currentValue > 10000) {
        peakTimes[peakCount] = i;  // Guardar posición del pico
        peakCount++;
      }
      lastValue = currentValue;
      currentValue = nextValue;
    }

    // Calcular HR basado en intervalos entre picos
    if (peakCount >= 2) {
      float totalInterval = 0;
      for (int i = 1; i < peakCount; i++) {
        totalInterval += (peakTimes[i] - peakTimes[i - 1]) * (1000.0 / 100.0); // 100 Hz de muestreo
      }
      float avgInterval = totalInterval / (peakCount - 1);  // Intervalo promedio en ms
      *hr = 60000.0 / avgInterval;  // Convertir a bpm
      lastHR = *hr;  // Actualizar última HR válida
    } else {
      *hr = lastHR;  // Mantener última HR si no hay suficientes picos
    }

    // Calcular SpO2 (fórmula simplificada basada en ratio AC/DC)
    float irAC = 0, redAC = 0, irDC = 0, redDC = 0;
    for (int i = 0; i < PPG_BUFFER_SIZE; i++) {
      irAC += abs(irBuffer[i] - irBuffer[(i + 1) % PPG_BUFFER_SIZE]);
      redAC += abs(redBuffer[i] - redBuffer[(i + 1) % PPG_BUFFER_SIZE]);
      irDC += irBuffer[i];
      redDC += redBuffer[i];
    }
    irAC /= PPG_BUFFER_SIZE;
    redAC /= PPG_BUFFER_SIZE;
    irDC /= PPG_BUFFER_SIZE;
    redDC /= PPG_BUFFER_SIZE;

    float R = (redAC / redDC) / (irAC / irDC);  // Relación AC/DC normalizada
    *spO2 = 110.0 - 25.0 * R;  // Fórmula empírica simplificada (necesita calibración)
    if (*spO2 > 100.0) *spO2 = 100.0;
    if (*spO2 < 70.0) *spO2 = 95.0;  // Evitar valores irreales
  } else {
    *hr = lastHR;  // Usar última HR hasta que el buffer esté lleno
    *spO2 = 95.0;  // Valor por defecto hasta cálculo completo
  }
}

// Adquisición de Datos
void adquirirDatosSincronizados(Mediciones* datos) {
  unsigned long tiempoInicio = micros();

  // MAX30102: HR y SpO2
  calcularPPG(&heartSensor, &datos->hr, &datos->spO2);
  datos->redReflectance = heartSensor.getRed() / 4096.0; // Normalizado según resolución de MAX30102

  // MAX30105: Reflectancia NIRS
  datos->irReflectance = bioSensor.getIR() / 16384.0; // Normalizado según resolución de MAX30105

  datos->distancia = tofSensor.readRangeSingleMillimeters() / 1000.0;
  datos->espesorTisular = DISTANCIA_BASAL - (tofSensor.readRangeSingleMillimeters() / 100.0);
  datos->temperatura = mlx.readObjectTempC();
  datos->presion = bmp.readPressure() / 100.0;

  int16_t ax, ay, az;
  gyro.getAcceleration(&ax, &ay, &az);
  datos->aceleracion[0] = ax / 16384.0;
  datos->aceleracion[1] = ay / 16384.0;
  datos->aceleracion[2] = az / 16384.0;

  datos->tiempo = (millis() - startTime) / 1000.0;

  prevIR[irIndex] = datos->irReflectance;
  prevReflectancia[irIndex] = datos->reflectancia;
  irIndex = (irIndex + 1) % 10;

  if (datos->hr < tarjeta.hrMin) tarjeta.hrMin = datos->hr;
  if (datos->hr > tarjeta.hrMax) tarjeta.hrMax = datos->hr;

  unsigned long tiempoTranscurrido = micros() - tiempoInicio;
  Serial.printf("Tiempo de adquisición: %lu us\n", tiempoTranscurrido);
}

// Procesamiento de Señales
void procesarSeñales(Mediciones* datos) {
  float ruidoEstimado = sqrt(pow(datos->aceleracion[0], 2) + pow(datos->aceleracion[1], 2) + pow(datos->aceleracion[2], 2));

  // Filtros de Kalman para HR, SpO2, VO2max, hemoglobina, hierro, leucocitos, intensidad
  kalmanFilter(&hrState, datos->hr);
  datos->hr = hrState.x;
  kalmanFilter(&spO2State, datos->spO2);
  datos->spO2 = spO2State.x;

  // Filtros de Kalman Cuántico para lactato y testosterona
  float rawLactato = 2.0 + (datos->hr - 60) / 40.0;
  quantumKalmanFilter(&lactatoState, rawLactato, ruidoEstimado + datos->espesorTisular);
  datos->lactato = lactatoState.x;

  float rawTestosterone = 20 + 0.0001 * (datos->irReflectance - datos->redReflectance) * 16384.0 + 0.05 * datos->hr - 0.5 * datos->lactato + 0.2 * (datos->glucosa - 85);
  quantumKalmanFilter(&testosteroneState, rawTestosterone, ruidoEstimado + datos->espesorTisular);
  datos->testosterone = testosteroneState.x;

  // Filtros de Kalman para otras métricas
  float rawVo2max = datos->velocidadMax * ((deporte == FONDO) ? 3.70 : (deporte == RESISTENCIA) ? 3.50 : 2.08);
  kalmanFilter(&vo2maxState, rawVo2max);
  datos->vo2max = vo2maxState.x;

  float rawHemoglobina = 12 + 0.00005 * datos->redReflectance * 4096.0 + 0.00002 * datos->irReflectance * 16384.0 + 0.001 * (datos->rSO2 / 100);
  kalmanFilter(&hemoglobinaState, rawHemoglobina);
  datos->hemoglobina = hemoglobinaState.x;

  float rawHierro = 150 - 0.5 * (220 - datos->hr) + 0.0001 * datos->irReflectance * 16384.0 - 10 * (datos->lactato / 20);
  kalmanFilter(&hierroState, rawHierro);
  datos->hierro = hierroState.x;

  float rawLeucocitos = 7000 - 500 * (datos->inmunoEstres / 100) + 200 * (datos->lactato / 20);
  kalmanFilter(&leucocitosState, rawLeucocitos);
  datos->leucocitos = leucocitosState.x;

  float rawIntensidad = calcularIntensidad(datos, datos->edad);
  kalmanFilter(&intensidadState, rawIntensidad);
  datos->intensidad = intensidadState.x;

  // Filtros Gaussianos para temperatura, rSO2, glucosa, ferritina, vitamina C, cortisol
  tempBuffer[tempIndex] = datos->temperatura;
  tempIndex = (tempIndex + 1) % 10;
  float filteredTemp;
  gaussianFilterArray(tempBuffer, &filteredTemp, 10, 0.5);
  datos->temperatura = filteredTemp;

  float rawRSO2 = 100 - (0.5 * (datos->irReflectance * 16384.0) / (datos->espesorTisular + 1) + 0.3 * (datos->redReflectance * 4096.0) / (datos->espesorTisular + 1));
  float filteredRSO2;
  gaussianFilterArray(&rawRSO2, &filteredRSO2, 1, 0.3);
  datos->rSO2 = filteredRSO2;

  float rawGlucosa = 85.0 + 0.001 * datos->irReflectance * 16384.0 - 0.5 * datos->lactato + 0.2 * (datos->temperatura - 36.5);
  float filteredGlucosa;
  gaussianFilterArray(&rawGlucosa, &filteredGlucosa, 1, 0.3);
  datos->glucosa = filteredGlucosa;

  float rawFerritina = 100 - 20 * (datos->lactato / 20) + 0.5 * datos->hemoglobina - 0.1 * (datos->temperatura - 36.5);
  float filteredFerritina;
  gaussianFilterArray(&rawFerritina, &filteredFerritina, 1, 0.3);
  datos->ferritina = filteredFerritina;

  float rawVitaminaC = 50 - 0.5 * datos->lactato + 0.1 * datos->hidratacionTisular + 0.01 * (datos->vo2max - 40);
  float filteredVitaminaC;
  gaussianFilterArray(&rawVitaminaC, &filteredVitaminaC, 1, 0.2);
  datos->vitaminaC = filteredVitaminaC;

  float rawCortisol = 5 + 0.05 * datos->hr + 10 * (1 / (datos->hrv || 10)) + 0.8 * datos->lactato + 0.3 * (datos->temperatura - 36.5) - 0.1 * (datos->glucosa - 85);
  float filteredCortisol;
  gaussianFilterArray(&rawCortisol, &filteredCortisol, 1, 0.4);
  datos->cortisol = filteredCortisol;

  datos->hidratacionTisular = 100 - K_HIDRATACION * datos->espesorTisular;
  datos->flujoSanguineo = fabs(datos->espesorTisular - prevDistancia) / 0.1;
  prevDistancia = datos->espesorTisular;

  datos->inmunoEstres = 50 + 2 * (datos->temperatura - 36.5) + 1 * datos->lactato;
  datos->openWindow = 50 + 2 * datos->lactato + 3 * (datos->testosterone - 10) + 1 * (datos->temperatura - 36.5);
  datos->saturacionTransferrina = (datos->hemoglobina / 15) * 100 * (datos->hierro / 150);
  datos->fotoporfirina = 40 - 5 * (datos->hierro / 100) + 0.1 * (220 - datos->hr);
  datos->tibc = 450 - 50 * (datos->hierro / 100) + 10 * (datos->lactato / 20);
  datos->ck = 50 + 5 * datos->lactato + 0.00005 * (datos->irReflectance - datos->redReflectance) * 16384.0 + 0.1 * (datos->temperatura - 36.5);
  datos->glucogeno = 70 - 0.5 * datos->lactato + 0.3 * (datos->glucosa - 85) - 0.00002 * (datos->irReflectance - datos->redReflectance) * 16384.0;
  datos->acidoUrico = 4 + 0.3 * datos->lactato + 0.00002 * (datos->irReflectance - datos->redReflectance) * 16384.0;
  datos->lipidosTisulares = K_LIPIDOS * datos->espesorTisular;
  datos->enzimasCelulares = 100 + 2 * datos->lactato + 0.5 * (datos->glucogeno - 70);

  compensarTemperaturaArrhenius(datos);
  compensarMelanina(datos);
  compensarMovimiento(datos);
  datos->viscosidad = calcularDDS(datos);
  datos->irv = calcularIRV(datos);
  datos->apEn = calcularApEn(datos);
  datos->mse = calcularMSE(datos);
  analizarPPG(datos);
  datos->flujoMet = flujoMetabolico(datos->temperatura);
  datos->viscosidad = calcularDDS(datos);
}

// Filtro Gaussiano
float gaussianFilter(float value) {
  const float mean = 0, stdDev = 1;
  float weight = exp(-0.5 * pow((value - mean) / stdDev, 2));
  return weight * value;
}

// Filtro Cuántico-Kalman
float quantumKalmanFilter(float prevEstimate, float measurement, float ruidoEstimado) {
  static float P = 1.0;
  const float R = 0.1;
  gammaKalman = 0.15 + 0.05 * ruidoEstimado;
  float x_pred = prevEstimate;
  float P_pred = P + wk;
  float K = P_pred / (P_pred + R);
  float innovation = measurement - x_pred;
  float x_est = x_pred + K * innovation + gammaKalman * exp(-fabs(innovation));
  P = (1 - K) * P_pred;
  wk = 0.9 * wk + 0.1 * fabs(innovation);
  return x_est;
}

// Transformación Kubelka-Munk
float kubelkaMunkTransform(float reflectance) {
  const float K = pow(1 - reflectance, 2) / (2 * reflectance * 0.8);
  const float S = 0.8;
  const float d = 0.5;
  return sqrt(K * (K + S) * d);
}

// Modelo Hemodinámico con Densidad y Viscosidad
float hemodynamicModel(float heartRate, float viscosidad) {
  float radius = 0.01 * (1 + 0.05 * (heartRate - 60) / 100);
  float deltaP = 100 + 20 * (heartRate > 100 ? 1 : 0);
  return (M_PI * pow(radius, 4) * deltaP) / (8 * viscosidad * 0.1 * DENSIDAD_SANGRE);
}

// Cálculo de Absorbancia
float calcularAbsorbancia(float irValue) {
  return -log10(irValue / 16384.0);
}

// Clamp de Valores
float clampValue(float value, int metric) {
  return constrain(value, VALORES_BASALES[metric].min, VALORES_BASALES[metric].max);
}

// Compensación por Melanina
void compensarMelanina(Mediciones* datos) {
  const float alpha = 0.5 + 0.1 * (datos->reflectancia > 0.7 ? 1 : 0);
  const float beta = 1.2;
  const float epsilon = 0.1;
  static float A_prev = 0.0;
  float A = datos->reflectancia;
  float varA = fabs(A - A_prev);
  datos->reflectancia = A * exp(-alpha * pow(A, beta)) + epsilon * varA;
  A_prev = A;
}

// Compensación Térmica Arrhenius
void compensarTemperaturaArrhenius(Mediciones* datos) {
  const float Ea = 5000;
  const float R = 8.314;
  const float Tref = 310.15;
  const float h = 0.02 + 0.01 * (datos->temperatura > 38.0 ? 1 : 0);
  float T = datos->temperatura + 273.15;
  float k = exp(-(Ea / R) * (1 / T - 1 / Tref)) * (1 + h * (T - prevTemp));
  datos->reflectancia *= k;
  prevTemp = T;
}

// Compensación por Movimiento
void compensarMovimiento(Mediciones* datos) {
  float magnitudAceleracion = sqrt(pow(datos->aceleracion[0], 2) + pow(datos->aceleracion[1], 2) + pow(datos->aceleracion[2], 2));
  datos->spO2 -= 0.1 * magnitudAceleracion;
  datos->hr += 5.0 * magnitudAceleracion;
  datos->reflectancia *= 1.0 / (1.0 + 0.2 * magnitudAceleracion);
}

// Análisis PPG
void analizarPPG(Mediciones* datos) {
  static float prevHR = 0.0;
  static unsigned long ultimoTiempo = 0;
  unsigned long tiempoActual = millis();
  if (prevHR > 0 && tiempoActual - ultimoTiempo > 1000) {
    float intervalo = 60000.0 / datos->hr;
    datos->hrv = abs(intervalo - (60000.0 / prevHR));
  }
  prevHR = datos->hr;
  ultimoTiempo = tiempoActual;

  float HbO2 = datos->spO2 * datos->reflectancia;
  float Hb = (1 - datos->spO2 / 100.0) * datos->reflectancia;
  datos->rSO2 = (HbO2 / (HbO2 + Hb)) * 100.0 * 0.9;

  if (datos->hr <= tarjeta.hrEstable + 5 && tarjeta.hrMax > tarjeta.hrEstable + 10) {
    tarjeta.tiempoRecuperacion = tiempoActual - ultimoTiempoMov;
    tarjeta.hrEstable = datos->hr;
  }
}

// Flujo Metabólico
float flujoMetabolico(float temp) {
  const float sigma = 5.67e-8;
  const float epsilon = 0.98;
  const float T_amb = 25.0 + 273.15;
  const float k_met = 0.1;
  float T = temp + 273.15;
  return sigma * epsilon * (pow(T, 4) - pow(T_amb, 4)) * k_met;
}

// Espectroscopia de Dispersión Dinámica
float calcularDDS(Mediciones* datos) {
  const float lambda = 940e-9;
  const float tau = 0.01;
  float I0 = 0.5;
  float deltaI = 0.0;
  for (int i = 0; i < 9; i++) {
    deltaI += fabs(prevIR[i] - prevIR[i + 1]);
  }
  deltaI /= 9.0;
  return (1.0 / (6 * tau)) * pow(lambda / (2 * M_PI), 2) * pow(deltaI / I0, 2);
}

// Índice de Rigidez Vascular
float calcularIRV(Mediciones* datos) {
  const float k = 0.1;
  static float prevHR = 0.0;
  static unsigned long ultimoTiempo = 0;
  unsigned long tiempoActual = millis();
  if (prevHR > 0 && tiempoActual > ultimoTiempo) {
    float deltaT = (tiempoActual - ultimoTiempo) / 1000.0;
    float deltaFC = datos->hr - prevHR;
    prevHR = datos->hr;
    ultimoTiempo = tiempoActual;
    return k * deltaFC / deltaT;
  }
  prevHR = datos->hr;
  ultimoTiempo = tiempoActual;
  return 0.0;
}

// Entropía Aproximada
float calcularApEn(Mediciones* datos) {
  const int m = 2;
  const float r = 0.2;
  const int N = 10;
  float Cm = 0.0, Cm1 = 0.0;
  for (int i = 0; i < N - m; i++) {
    int conteo = 0, conteo1 = 0;
    for (int j = 0; j < N - m; j++) {
      if (fabs(prevIR[i] - prevIR[j]) <= r) conteo++;
      if (i < N - m - 1 && j < N - m - 1 && fabs(prevIR[i + 1] - prevIR[j + 1]) <= r) conteo1++;
    }
    Cm += log(conteo / (float)(N - m));
    Cm1 += log(conteo1 / (float)(N - m - 1));
  }
  Cm /= (N - m);
  Cm1 /= (N - m - 1);
  return Cm - Cm1;
}

// Entropía Multiescala
float calcularMSE(Mediciones* datos) {
  const int m = 2;
  const float r = 0.2;
  const int N = 10;
  float suma = 0.0;
  int conteoEscalas = 0;
  for (int escala = 1; escala <= 3; escala++) {
    float Cm = 0.0;
    for (int i = 0; i < N - m * escala; i += escala) {
      int conteo = 0;
      for (int j = 0; j < N - m * escala; j += escala) {
        if (fabs(prevReflectancia[i] - prevReflectancia[j]) <= r) conteo++;
      }
      Cm += log(conteo / (float)(N - m * escala));
    }
    suma += Cm / (N - m * escala);
    conteoEscalas++;
  }
  return suma / conteoEscalas;
}

// Fusión de Datos Multisensorial
void fusionDatos(Mediciones* datos) {
  float pesoSpO2 = 0.6, pesoReflectancia = 0.3, pesoTemperatura = 0.1;
  datos->spO2 = pesoSpO2 * datos->spO2 + pesoReflectancia * (100.0 * datos->reflectancia) +
                pesoTemperatura * (datos->temperatura - 37.0 + 95.0);
}

// Estimación Hidratación
void estimarHidratacion(Mediciones* datos) {
  float factorTermico = 1.0 + 0.1 * (datos->temperatura - 37.0);
  float factorFC = 1.0 + 0.05 * (datos->hr - restingHR);
  datos->hidratacion = 100.0 - 10.0 * (1.0 - datos->reflectancia) * factorTermico * factorFC;
}

// Estimación de Metabolitos con Beer-Lambert, Densidad y Viscosidad
void estimarMetabolitos(Mediciones* datos) {
  float hrr = (datos->hr - restingHR) / (220 - datos->edad);
  float viscosidad = VISCOSIDAD_BASE * (1 + 0.1 * (datos->temperatura - 37.0));
  float flujo = hemodynamicModel(datos->hr, viscosidad);
  float absorbance = calcularAbsorbancia(datos->irReflectance * 16384.0);
  float kmTransform = kubelkaMunkTransform(datos->irReflectance);
  float gaussianIR = gaussianFilter(bioSensor.getIR());

  float densidadFactor = DENSIDAD_SANGRE / 1000.0;
  float viscosidadFactor = viscosidad / VISCOSIDAD_BASE;

  float R_glucosa = datos->reflectancia * exp(-(COEFICIENTES_ABSORCION[1] + COEFICIENTES_DISPERSION[1]) * datos->distancia * densidadFactor * viscosidadFactor);
  datos->glucosa = VALORES_BASALES[1].base + (absorbance / (COEFICIENTES_ABSORCION[1] * PATH_LENGTH)) * flujo +
                   R_glucosa * 20.0 + datos->hrv * 0.01 - datos->irv * 0.05;
  datos->glucosa = clampValue(datos->glucosa, 1);

  float R_lactato = datos->reflectancia * exp(-(COEFICIENTES_ABSORCION[0] + COEFICIENTES_DISPERSION[0]) * datos->distancia * densidadFactor * viscosidadFactor);
  float LT1 = 2.0 + 0.5 * (datos->hr - restingHR) / 60.0;
  datos->lactato = LT1 + 2.5 * (hrr - 0.72) + (absorbance / (COEFICIENTES_ABSORCION[0] * PATH_LENGTH)) * flujo +
                   R_lactato * 5.0 + datos->apEn * 0.5;
  datos->lactato *= (hrr <= 0.72) ? 1 + 0.088 * hrr : exp(1.15 * (hrr - 0.72));
  datos->lactato = clampValue(datos->lactato, 0);

  float R_agua = datos->reflectancia * exp(-(0.8 + 0.5) * datos->distancia * densidadFactor * viscosidadFactor);
  float factorTermico = 1.0 + 0.1 * (datos->temperatura - 37.0);
  float factorFC = 1.0 + 0.05 * (datos->hr - restingHR);
  datos->hidratacion = 100.0 - 10.0 * (1.0 - R_agua) * factorTermico * factorFC;
  datos->hidratacion = clampValue(datos->hidratacion, 2);

  float R_vitD = datos->reflectancia * exp(-(COEFICIENTES_ABSORCION[4] + COEFICIENTES_DISPERSION[4]) * datos->distancia * densidadFactor * viscosidadFactor);
  datos->vitaminaD = VALORES_BASALES[4].base + (absorbance / (COEFICIENTES_ABSORCION[4] * PATH_LENGTH)) * flujo +
                     R_vitD * 10.0 + datos->flujoMet * 0.05;
  datos->vitaminaD = clampValue(datos->vitaminaD, 4);

  float R_vitB12 = datos->reflectancia * exp(-(COEFICIENTES_ABSORCION[5] + COEFICIENTES_DISPERSION[5]) * datos->distancia * densidadFactor * viscosidadFactor);
  datos->vitaminaB12 = VALORES_BASALES[5].base + (absorbance / (COEFICIENTES_ABSORCION[5] * PATH_LENGTH)) * flujo +
                       R_vitB12 * 50.0 + datos->hrv * 0.05;
  datos->vitaminaB12 = clampValue(datos->vitaminaB12, 5);

  float R_vitC = datos->reflectancia * exp(-(COEFICIENTES_ABSORCION[5] + COEFICIENTES_DISPERSION[5]) * datos->distancia * densidadFactor * viscosidadFactor);
  datos->vitaminaC = 1.0 + (absorbance / (COEFICIENTES_ABSORCION[5] * PATH_LENGTH)) * flujo +
                     R_vitC * 0.2 + flujo * 0.01;
  datos->vitaminaC = clampValue(datos->vitaminaC, 5);

  float R_hierro = datos->reflectancia * exp(-(COEFICIENTES_ABSORCION[6] + COEFICIENTES_DISPERSION[6]) * datos->distancia * densidadFactor * viscosidadFactor);
  float factorRSO2 = (datos->rSO2 - 80.0) * 0.2;
  float factorHR = (datos->hr - restingHR) * 0.05;
  datos->hierro = VALORES_BASALES[6].base + (absorbance / (COEFICIENTES_ABSORCION[6] * PATH_LENGTH)) * flujo +
                  R_hierro * 20.0 + factorRSO2 + factorHR - datos->viscosidad * 2.0;
  datos->hierro = clampValue(datos->hierro, 6);

  float R_calcio = datos->reflectancia * exp(-(COEFICIENTES_ABSORCION[2] + COEFICIENTES_DISPERSION[2]) * datos->distancia * densidadFactor * viscosidadFactor);
  datos->calcio = VALORES_BASALES[2].base + (absorbance / (COEFICIENTES_ABSORCION[2] * PATH_LENGTH)) * flujo +
                  R_calcio * 0.5 + datos->flujoMet * 0.02;
  datos->calcio = clampValue(datos->calcio, 2);

  float R_magnesio = datos->reflectancia * exp(-(COEFICIENTES_ABSORCION[3] + COEFICIENTES_DISPERSION[3]) * datos->distancia * densidadFactor * viscosidadFactor);
  datos->magnesio = VALORES_BASALES[3].base + (absorbance / (COEFICIENTES_ABSORCION[3] * PATH_LENGTH)) * flujo +
                    R_magnesio * 0.1 + datos->hrv * 0.0005 - datos->irv * 0.01;
  datos->magnesio = clampValue(datos->magnesio, 3);

  datos->ferritina = clampValue(datos->ferritina, 7);
  datos->hemoglobina = clampValue(datos->hemoglobina, 8);
  datos->leucocitos = clampValue(datos->leucocitos, 9);
  datos->testosterone = clampValue(datos->testosterone, 10);
  datos->cortisol = clampValue(datos->cortisol, 11);
  datos->intensidad = clampValue(datos->intensidad, 12);

  datos->saturacionTransferrina = (datos->hemoglobina / 15) * 100 * (datos->hierro / 150);
  datos->fotoporfirina = 40 - 5 * (datos->hierro / 100) + 0.1 * (220 - datos->hr);
  datos->tibc = 450 - 50 * (datos->hierro / 100) + 10 * (datos->lactato / 20);

  datos->inmunoEstres = 50 + 2 * (datos->temperatura - 36.5) + 1 * datos->lactato;
  datos->openWindow = 50 + 2 * datos->lactato + 3 * (datos->testosterone - 10) + 1 * (datos->temperatura - 36.5);

  datos->eficienciaMet = datos->vo2max / (datos->lactato * (datos->distanciaRecorrida + 0.01));
  datos->tasaDesplazMet = datos->distanciaRecorrida / (datos->calorias + 0.01);

  calcularVO2Max(datos);
  calcularRecuperacionCardiaca(datos);
  calcularFatigaMuscular(datos);
  calcularCaloriasQuemadas(datos);
  determinarZonaEntrenamiento(datos);
  strcpy(datos->nivelEsfuerzo, calcularNivelEsfuerzo(datos->vo2max));
  strcpy(datos->estadoEritrocito, (datos->hemoglobina < 13 && datos->hemoglobina * 3 < 35) ? "microcito/hipocromo" : "Normal");

  datos->eficienciaMet = datos->vo2max / (datos->lactato * (datos->distanciaRecorrida + 0.01));
  datos->tasaDesplazMet = datos->distanciaRecorrida / (datos->calorias + 0.01);
}

// VO₂ Máx
void calcularVO2Max(Mediciones* datos) {
  float imc = datos->peso / pow(datos->talla / 100.0, 2);
  datos->vo2max = 15.3 * (datos->hr / restingHR) + 0.18 * datos->lactato - 
                  0.32 * (datos->temperatura - 37.0) + 0.45 * datos->spO2 - 
                  0.5 * (imc - 22.0) - 0.1 * (millis() / 60000.0);
  float factorEdad = 1.0 - (datos->edad - 25.0) * 0.01;
  float factorSexo = (datos->sexo == 0) ? 0.9 : 1.0;
  datos->vo2max *= factorEdad * factorSexo;
  datos->vo2max = clampValue(datos->vo2max, 0); // Ajustar rango si necesario
}

// Recuperación Cardíaca
void calcularRecuperacionCardiaca(Mediciones* datos) {
  datos->recuperacion = tarjeta.tiempoRecuperacion / 1000.0;
  float factorLactato = 1.0 + 0.1 * datos->lactato;
  datos->recuperacion *= factorLactato;
}

// Fatiga Muscular
void calcularFatigaMuscular(Mediciones* datos) {
  float magnitudAceleracion = sqrt(pow(datos->aceleracion[0], 2) + pow(datos->aceleracion[1], 2) + pow(datos->aceleracion[2], 2));
  datos->fatiga = 0.6 * datos->lactato + 0.3 * (datos->temperatura - 37.0) + 0.1 * magnitudAceleracion + 0.05 * (tarjeta.hrMax - restingHR);
}

// Calorías Quemadas
void calcularCaloriasQuemadas(Mediciones* datos) {
  float imc = datos->peso / pow(datos->talla / 100.0, 2);
  float factorEdad = 1.0 - (datos->edad - 25.0) * 0.01;
  float factorSexo = (datos->sexo == 0) ? 0.9 : 1.0;
  float factorTermico = 1.0 + 0.02 * (datos->temperatura - 37.0);
  float factorIMC = (imc > 25) ? 0.95 : 1.0;
  datos->calorias = 0.0175 * datos->peso * (datos->hr - restingHR) * factorEdad * factorSexo * factorTermico * factorIMC;
}

// Cálculo de Movimiento
void calcularMovimiento(Mediciones* datos) {
  unsigned long tiempoActual = millis();
  float deltaT = (tiempoActual - ultimoTiempoMov) / 1000.0;
  ultimoTiempoMov = tiempoActual;

  float magnitudAceleracion = sqrt(pow(datos->aceleracion[0], 2) + pow(datos->aceleracion[1], 2) + pow(datos->aceleracion[2], 2));
  float velocidad = velocidadAnterior + magnitudAceleracion * 9.81 * deltaT / 1000.0 * 3.6;
  if (velocidad > datos->velocidadMax) datos->velocidadMax = velocidad;
  velocidadAnterior = velocidad;

  float distancia = (velocidad * deltaT) / 3600.0;
  distanciaAcumulada += distancia;
  datos->distanciaRecorrida = distanciaAcumulada;

  if (magnitudAceleracion > 1.5 && !enSalto) {
    enSalto = true;
  } else if (magnitudAceleracion < 1.0 && enSalto) {
    float alturaSalto = (pow(velocidadAnterior, 2)) / (2 * 9.81);
    if (alturaSalto < datos->saltoMin) datos->saltoMin = alturaSalto;
    if (alturaSalto > datos->saltoMax) datos->saltoMax = alturaSalto;
    enSalto = false;
  }
}

// Transporte Radiativo
float transporteRadiativo(float z, float R) {
  const float mu_a = 0.1 + 0.05 * (z > 0.002 ? 1 : 0);
  const float mu_s = 0.8;
  const float mu_t = mu_a + mu_s;
  float I0 = 1.0;
  return I0 * exp(-mu_t * z) * R;
}

// Determinación de Zona de Entrenamiento
void determinarZonaEntrenamiento(Mediciones* datos) {
  float hrMax = 220 - datos->edad;
  float hrRelativa = datos->hr / hrMax;
  if (hrRelativa < 0.6) strcpy(datos->zona, "Recuperación");
  else if (hrRelativa < 0.7) strcpy(datos->zona, "Aeróbica Ligera");
  else if (hrRelativa < 0.8) strcpy(datos->zona, "Aeróbica Intensa");
  else if (hrRelativa < 0.9) strcpy(datos->zona, "Anaeróbica");
  else strcpy(datos->zona, "Máximo Esfuerzo");
}

// Optimización Energética
void optimizarEnergia() {
  if (datos_global.hr < restingHR + 10 && datos_global.velocidadMax < 1.0) {
    heartSensor.setup(25, 4, 2, 100, 411, 4096);
    bioSensor.setup(25, 4, 2, 100, 411, 4096);
  } else {
    heartSensor.setup(45, 4, 2, 100, 411, 4096);
    bioSensor.setup(45, 4, 2, 100, 411, 4096);
  }

  if (!datos_global.enUso) {
    heartSensor.shutDown();
    bioSensor.shutDown();
  } else {
    heartSensor.wakeUp();
    bioSensor.wakeUp();
  }
}

// Carga del Modelo TFLite
void cargarModeloTFLite() {
  const tflite::Model* modelo = tflite::GetModel(modelo_tflite);
  if (!modelo) {
    Serial.println("¡Modelo TFLite no encontrado!");
    while (1);
  }
  static tflite::AllOpsResolver resolver;
  static tflite::MicroInterpreter interprete_estatico(modelo, resolver, tensor_arena, tensor_arena_size);
  interpreter = &interprete_estatico;

  TfLiteStatus estado_asignacion = interpreter->AllocateTensors();
  if (estado_asignacion != kTfLiteOk) {
    Serial.println("¡Error asignando tensores!");
    while (1);
  }
  Serial.println("Modelo TFLite cargado exitosamente.");
}

// Ejecución del Modelo ML
void ejecutarModeloML(Mediciones* datos) {
  TfLiteTensor* entrada = interpreter->input(0);
  float* datos_entrada = entrada->data.f;
  datos_entrada[0] = datos->spO2; datos_entrada[1] = datos->rSO2; datos_entrada[2] = datos->hr;
  datos_entrada[3] = datos->reflectancia; datos_entrada[4] = datos->temperatura;
  datos_entrada[5] = datos->flujoMet; datos_entrada[6] = datos->hrv;
  datos_entrada[7] = datos->viscosidad; datos_entrada[8] = datos->irv;
  datos_entrada[9] = datos->apEn; datos_entrada[10] = datos->vo2max;
  datos_entrada[11] = datos->recuperacion; datos_entrada[12] = datos->fatiga;
  datos_entrada[13] = datos->mse;

  if (interpreter->Invoke() != kTfLiteOk) {
    Serial.println("¡Error en inferencia!");
    return;
  }

  TfLiteTensor* salida = interpreter->output(0);
  float* datos_salida = salida->data.f;
  datos->glucosa = clampValue(datos_salida[0], 1);
  datos->lactato = clampValue(datos_salida[1], 0);
  datos->hidratacion = clampValue(datos_salida[2], 2);
  datos->vitaminaD = clampValue(datos_salida[3], 4);
  datos->vitaminaB12 = clampValue(datos_salida[4], 5);
  datos->vitaminaC = clampValue(datos_salida[5], 5);
  datos->hierro = clampValue(datos_salida[6], 6);
  datos->calcio = clampValue(datos_salida[7], 2);
  datos->magnesio = clampValue(datos_salida[8], 3);
}

// Validación Gaussiana
bool validarDatos(Mediciones datos) {
  float confianza = exp(-pow(datos.lactato - 2.0, 2) / 1.0);
  return (datos.spO2 >= 70 && datos.spO2 <= 100) &&
         (datos.rSO2 >= 50 && datos.rSO2 <= 100) &&
         (datos.hr >= 30 && datos.hr <= 300) &&
         (datos.temperatura >= 35 && datos.temperatura <= 42) &&
         (datos.glucosa >= 70 && datos.glucosa <= 200) &&
         (datos.lactato >= 0.5 && datos.lactato <= 20) &&
         (datos.hidratacion >= 50 && datos.hidratacion <= 100) &&
         (datos.vitaminaD >= 10 && datos.vitaminaD <= 50) &&
         (datos.vitaminaB12 >= 200 && datos.vitaminaB12 <= 1000) &&
         (datos.vitaminaC >= 0.5 && datos.vitaminaC <= 2.0) &&
         (datos.hierro >= 50 && datos.hierro <= 200) &&
         (datos.calcio >= 8.5 && datos.calcio <= 10.5) &&
         (datos.magnesio >= 1.7 && datos.magnesio <= 2.5) &&
         (datos.viscosidad >= 0 && datos.viscosidad <= 10) &&
         (datos.ferritina >= VALORES_BASALES[7].min && datos.ferritina <= VALORES_BASALES[7].max) &&
         (datos.hemoglobina >= VALORES_BASALES[8].min && datos.hemoglobina <= VALORES_BASALES[8].max) &&
         (datos.leucocitos >= VALORES_BASALES[9].min && datos.leucocitos <= VALORES_BASALES[9].max) &&
         (datos.testosterone >= VALORES_BASALES[10].min && datos.testosterone <= VALORES_BASALES[10].max) &&
         (datos.cortisol >= VALORES_BASALES[11].min && datos.cortisol <= VALORES_BASALES[11].max) &&
         (datos.intensidad >= VALORES_BASALES[12].min && datos.intensidad <= VALORES_BASALES[12].max) &&
         (datos.irv >= 0 && datos.irv <= 5) &&
         (datos.apEn >= 0 && datos.apEn <= 2) &&
         (datos.mse >= 0 && datos.mse <= 2) &&
         (datos.vo2max >= 20 && datos.vo2max <= 80) &&
         (datos.recuperacion >= 0) &&
         (datos.fatiga >= 0 && datos.fatiga <= 50) &&
         (datos.calorias >= 0) &&
         (confianza > 0.7);
}

// Mostrar Resultados
void mostrarResultados(Mediciones datos) {
  Serial.println("\n--- Resultados ---");
  Serial.printf("SpO2: %.1f%%\n", datos.spO2);
  Serial.printf("rSO2: %.1f%%\n", datos.rSO2);
  Serial.printf("Frecuencia Cardíaca: %.1f bpm (Min: %.1f, Max: %.1f)\n", datos.hr, tarjeta.hrMin, tarjeta.hrMax);
  Serial.printf("HRV: %.1f ms\n", datos.hrv);
  Serial.printf("Temperatura: %.1f°C\n", datos.temperatura);
  Serial.printf("Flujo Metabólico: %.2f W/m²\n", datos.flujoMet);
  Serial.printf("Glucosa: %.1f mg/dL\n", datos.glucosa);
  Serial.printf("Lactato: %.1f mmol/L\n", datos.lactato);
  Serial.printf("Hidratación: %.1f%%\n", datos.hidratacion);
  Serial.printf("Vitamina D: %.1f ng/mL\n", datos.vitaminaD);
  Serial.printf("Vitamina B12: %.1f pg/mL\n", datos.vitaminaB12);
  Serial.printf("Vitamina C: %.1f mg/dL\n", datos.vitaminaC);
  Serial.printf("Hierro: %.1f µg/dL\n", datos.hierro);
  Serial.printf("Calcio: %.1f mg/dL\n", datos.calcio);
  Serial.printf("Magnesio: %.1f mg/dL\n", datos.magnesio);
  Serial.printf("Viscosidad Relativa: %.2f\n", datos.viscosidad);
  Serial.printf("Ferritina: %.1f µg/dL\n", datos.ferritina);
  Serial.printf("Hemoglobina: %.1f g/dL\n", datos.hemoglobina);
  Serial.printf("Leucocitos: %.1f x10³/µL\n", datos.leucocitos);
  Serial.printf("Testosterona: %.1f ng/dL\n", datos.testosterone);
  Serial.printf("Cortisol: %.1f µg/dL\n", datos.cortisol);
  Serial.printf("Índice de Rigidez Vascular: %.2f\n", datos.irv);
  Serial.printf("Entropía Aproximada: %.2f\n", datos.apEn);
  Serial.printf("Entropía Multiescala: %.2f\n", datos.mse);
  Serial.printf("VO₂ Máx: %.1f mL/kg/min\n", datos.vo2max);
  Serial.printf("Recuperación Cardíaca: %.1f s\n", datos.recuperacion);
  Serial.printf("Fatiga Muscular: %.1f\n", datos.fatiga);
  Serial.printf("Calorías Quemadas: %.1f kcal\n", datos.calorias);
  Serial.printf("Zona de Entrenamiento: %s\n", datos.zona);
  Serial.printf("Peso: %.1f kg\n", datos.peso);
  Serial.printf("Edad: %.1f años\n", datos.edad);
  Serial.printf("Talla: %.1f cm\n", datos.talla);
  Serial.printf("Distancia Recorrida: %.3f km\n", datos.distanciaRecorrida);
  Serial.printf("Velocidad Máxima: %.1f km/h\n", datos.velocidadMax);
  Serial.printf("Salto Mínimo: %.2f m\n", datos.saltoMin == 9999.0 ? 0.0 : datos.saltoMin);
  Serial.printf("Salto Máximo: %.2f m\n", datos.saltoMax);
  Serial.printf("Eficiencia Metabólica: %.2f\n", datos.eficienciaMet);
  Serial.printf("Tasa de Desplazamiento Metabólico: %.3f km/kcal\n", datos.tasaDesplazMet);
}

// Configuración BLE
void inicializarBLE() {
  BLEDevice::init("MonitorMetabolico");
  BLEServer *pServer = BLEDevice::createServer();
  BLEService *pService = pServer->createService(SERVICE_UUID);
  pCharacteristic1 = pService->createCharacteristic(CHARACTERISTIC_UUID1, BLECharacteristic::PROPERTY_NOTIFY);
  pCharacteristic2 = pService->createCharacteristic(CHARACTERISTIC_UUID2, BLECharacteristic::PROPERTY_NOTIFY);
  pCharacteristic3 = pService->createCharacteristic(CHARACTERISTIC_UUID3, BLECharacteristic::PROPERTY_NOTIFY);
  pCharacteristic1->addDescriptor(new BLE2902());
  pCharacteristic2->addDescriptor(new BLE2902());
  pCharacteristic3->addDescriptor(new BLE2902());
  pService->start();

  pCharacteristic->setValue("Monitor Iniciado");
  pService->start();
  BLEAdvertising *pAdvertising = BLEDevice::getAdvertising();
  pAdvertising->addServiceUUID(SERVICE_UUID);
  pAdvertising->start();
}

// Envío de Datos por BLE
void enviarDatosBLE(Mediciones datos) {
  uint8_t buffer[80];
  int desplazamiento = 0;

 // Envío de datos por BLE
void enviarDatosBLE(Mediciones datos) {
  float buffer1[] = {datos.spO2, datos.rSO2, datos.hr, datos.hrv, datos.temperatura, datos.glucosa, datos.lactato,
                    datos.hidratacion, datos.vo2max, datos.calorias, datos.velocidadMax, datos.saltoMax,
                    datos.irReflectance, datos.redReflectance, datos.testosterone, datos.cortisol};
  pCharacteristic1->setValue((uint8_t*)buffer1, sizeof(buffer1));
  pCharacteristic1->notify();

  float buffer2[] = {datos.distanciaRecorrida, datos.tiempo, datos.magnesio, datos.vitaminaC, datos.vitaminaD,
                    datos.vitaminaB12, datos.hierro, datos.ferritina, datos.hemoglobina, datos.leucocitos,
                    datos.espesorTisular, datos.hidratacionTisular, datos.flujoSanguineo, datos.lipidosTisulares,
                    datos.enzimasCelulares, datos.inmunoEstres, datos.intensidad};
  pCharacteristic2->setValue((uint8_t*)buffer2, sizeof(buffer2));
  pCharacteristic2->notify();

  char buffer3[150];
  snprintf(buffer3, sizeof(buffer3), "{\"zona\":\"%s\",\"estadoEritrocito\":\"%s\",\"nivelEsfuerzo\":\"%s\"}",
           datos.zona, datos.estadoEritrocito, datos.nivelEsfuerzo);
  pCharacteristic3->setValue((uint8_t*)buffer3, strlen(buffer3));
  pCharacteristic3->notify();
}

// Verificación de botones
void checkButtons() {
  if (digitalRead(BUTTON_POWER) == LOW) {
    delay(50);
    if (digitalRead(BUTTON_POWER) == LOW) {
      datos_global.enUso = !datos_global.enUso;
      if (!datos_global.enUso) {
        heartSensor.shutDown();
        bioSensor.shutDown();
        Serial.println("Dispositivo apagado.");
      } else {
        heartSensor.wakeUp();
        bioSensor.wakeUp();
        Serial.println("Dispositivo encendido.");
      }
      while (digitalRead(BUTTON_POWER) == LOW);
    }
  }

  if (digitalRead(BUTTON_RESET) == LOW) {
    delay(50);
    if (digitalRead(BUTTON_RESET) == LOW) {
      if (xSemaphoreTake(dataMutex, portMAX_DELAY) == pdTRUE) {
        datos_global = {0};
        datos_global.peso = 75.0; datos_global.edad = 25.0; datos_global.talla = 175.0;
        datos_global.sexo = 1; datos_global.enUso = true;
        datos_global.saltoMin = 9999.0; datos_global.saltoMax = 0.0;
        tarjeta = {restingHR, restingHR, 0, restingHR};
        xSemaphoreGive(dataMutex);
        Serial.println("Datos reiniciados.");
      }
      while (digitalRead(BUTTON_RESET) == LOW);
    }
  }

  if (digitalRead(BUTTON_MODE) == LOW) {
    delay(50);
    if (digitalRead(BUTTON_MODE) == LOW) {
      optimizarEnergia();
      Serial.println("Modo bajo consumo activado.");
      while (digitalRead(BUTTON_MODE) == LOW);
    }
  }
}

// Alertas sonoras
void buzzerAlert(float lactato, float hr, float hrMax) {
  float hrRelativa = hr / hrMax;

  if (lactato > 6.0) {
    for (int i = 0; i < 3; i++) {
      digitalWrite(BUZZER_PIN, HIGH);
      delay(200);
      digitalWrite(BUZZER_PIN, LOW);
      delay(200);
    }
    Serial.println("Alerta: Lactato alto (>6 mmol/L)");
  }

  if (hrRelativa > 0.95) {
    digitalWrite(BUZZER_PIN, HIGH);
    delay(3000);
    digitalWrite(BUZZER_PIN, LOW);
    Serial.println("Alerta: Máximo Esfuerzo");
  } else if (hrRelativa > 0.8) {
    for (int i = 0; i < 2; i++) {
      digitalWrite(BUZZER_PIN, HIGH);
      delay(1000);
      digitalWrite(BUZZER_PIN, LOW);
      delay(500);
    }
    Serial.println("Alerta: Zona Anaeróbica");
  }
}

// Cálculo de intensidad
float calcularIntensidad(Mediciones* datos, int edad) {
  float hrMax = 220.0 - edad;
  float hrRel = datos->hr / hrMax;
  float velocidadActual = (datos->distanciaRecorrida / datos->tiempo);
  return (velocidadActual / datos->velocidadMax) * 100 * hrRel;
}

// Nivel de esfuerzo
const char* calcularNivelEsfuerzo(float vo2max) {
  if (vo2max < 35) return "Recuperación";
  else if (vo2max < 45) return "Mantenimiento capacidad aeróbica";
  else if (vo2max < 55) return "Desarrollo capacidad aeróbica";
  else if (vo2max < 70) return "Desarrollo potencia aeróbica";
  else return "Desarrollo potencia aeróbica/capacidad anaeróbica";
}

// Filtros
void kalmanFilter(KalmanState* state, float measurement) {
  float K = state->P / (state->P + state->R);
  state->x = state->x + K * (measurement - state->x);
  state->P = (1 - K) * state->P + state->Q;
}

void quantumKalmanFilter(KalmanState* state, float measurement, float noise) {
  float K = state->P / (state->P + state->R * noise);
  state->x = state->x + K * (measurement - state->x);
  state->P = (1 - K) * state->P + state->Q * noise;
}

void gaussianFilterArray(float* data, float* filtered, int size, float sigma) {
  float mean = 0;
  for (int i = 0; i < size; i++) mean += data[i];
  mean /= size;
  float sum = 0;
  for (int i = 0; i < size; i++) sum += pow(data[i] - mean, 2);
  float variance = sum / size;
  *filtered = mean + sigma * sqrt(variance);
}

// Transformación Kubelka-Munk
float kubelkaMunkTransform(float reflectance) {
  const float K = pow(1 - reflectance, 2) / (2 * reflectance * 0.8);
  const float S = 0.8;
  const float d = 0.5;
  return sqrt(K * (K + S) * d);
}

// Modelo Hemodinámico
float hemodynamicModel(float heartRate, float viscosidad) {
  float radius = 0.01 * (1 + 0.05 * (heartRate - 60) / 100);
  float deltaP = 100 + 20 * (heartRate > 100 ? 1 : 0);
  return (M_PI * pow(radius, 4) * deltaP) / (8 * viscosidad * 0.1 * DENSIDAD_SANGRE);
}

// Cálculo de absorbancia
float calcularAbsorbancia(float irValue) {
  return -log10(irValue / 16384.0); // Ajustado a resolución de bioSensor
}

// Compensación por melanina
void compensarMelanina(Mediciones* datos) {
  const float alpha = 0.5 + 0.1 * (datos->irReflectance > 0.7 ? 1 : 0);
  const float beta = 1.2;
  const float epsilon = 0.1;
  static float A_prev = 0.0;
  float A = datos->irReflectance;
  float varA = fabs(A - A_prev);
  datos->irReflectance = A * exp(-alpha * pow(A, beta)) + epsilon * varA;
  A_prev = A;
}

// Compensación térmica por Arrhenius
void compensarTemperaturaArrhenius(Mediciones* datos) {
  const float Ea = 5000;
  const float R = 8.314;
  const float Tref = 310.15;
  const float h = 0.02 + 0.01 * (datos->temperatura > 38.0 ? 1 : 0);
  float T = datos->temperatura + 273.15;
  float k = exp(-(Ea / R) * (1 / T - 1 / Tref)) * (1 + h * (T - prevTemp));
  datos->irReflectance *= k;
  prevTemp = T;
}

// Compensación por movimiento
void compensarMovimiento(Mediciones* datos) {
  float magnitudAceleracion = sqrt(pow(datos->aceleracion[0], 2) + pow(datos->aceleracion[1], 2) + pow(datos->aceleracion[2], 2));
  datos->spO2 -= 0.1 * magnitudAceleracion;
  datos->hr += 5.0 * magnitudAceleracion;
  datos->irReflectance *= 1.0 / (1.0 + 0.2 * magnitudAceleracion);
  datos->redReflectance *= 1.0 / (1.0 + 0.2 * magnitudAceleracion);
}

// Análisis PPG
void analizarPPG(Mediciones* datos) {
  static float prevHR = 0.0;
  static unsigned long ultimoTiempo = 0;
  unsigned long tiempoActual = millis();
  if (prevHR > 0 && tiempoActual - ultimoTiempo > 1000) {
    float intervalo = 60000.0 / datos->hr;
    datos->hrv = abs(intervalo - (60000.0 / prevHR));
  }
  prevHR = datos->hr;
  ultimoTiempo = tiempoActual;

  float HbO2 = datos->spO2 * datos->redReflectance;
  float Hb = (1 - datos->spO2 / 100.0) * datos->redReflectance;
  datos->rSO2 = (HbO2 / (HbO2 + Hb)) * 100.0 * 0.9;

  if (datos->hr <= tarjeta.hrEstable + 5 && tarjeta.hrMax > tarjeta.hrEstable + 10) {
    tarjeta.tiempoRecuperacion = tiempoActual - ultimoTiempoMov;
    tarjeta.hrEstable = datos->hr;
  }
}

// Flujo metabólico térmico
float flujoMetabolico(float temp) {
  const float sigma = 5.67e-8;
  const float epsilon = 0.98;
  const float T_amb = 25.0 + 273.15;
  const float k_met = 0.1;
  float T = temp + 273.15;
  return sigma * epsilon * (pow(T, 4) - pow(T_amb, 4)) * k_met;
}

// Espectroscopia de dispersión dinámica
float calcularDDS(Mediciones* datos) {
  const float lambda = 940e-9;
  const float tau = 0.01;
  float I0 = 0.5;
  float deltaI = 0.0;
  for (int i = 0; i < 9; i++) {
    deltaI += fabs(prevIR[i] - prevIR[i + 1]);
  }
  deltaI /= 9.0;
  return (1.0 / (6 * tau)) * pow(lambda / (2 * M_PI), 2) * pow(deltaI / I0, 2);
}

// Índice de rigidez vascular
float calcularIRV(Mediciones* datos) {
  const float k = 0.1;
  static float prevHR = 0.0;
  static unsigned long ultimoTiempo = 0;
  unsigned long tiempoActual = millis();
  if (prevHR > 0 && tiempoActual > ultimoTiempo) {
    float deltaT = (tiempoActual - ultimoTiempo) / 1000.0;
    float deltaFC = datos->hr - prevHR;
    prevHR = datos->hr;
    ultimoTiempo = tiempoActual;
    return k * deltaFC / deltaT;
  }
  prevHR = datos->hr;
  ultimoTiempo = tiempoActual;
  return 0.0;
}

// Entropía aproximada
float calcularApEn(Mediciones* datos) {
  const int m = 2;
  const float r = 0.2;
  const int N = 10;
  float Cm = 0.0, Cm1 = 0.0;
  for (int i = 0; i < N - m; i++) {
    int conteo = 0, conteo1 = 0;
    for (int j = 0; j < N - m; j++) {
      if (fabs(prevIR[i] - prevIR[j]) <= r) conteo++;
      if (i < N - m - 1 && j < N - m - 1 && fabs(prevIR[i + 1] - prevIR[j + 1]) <= r) conteo1++;
    }
    Cm += log(conteo / (float)(N - m));
    Cm1 += log(conteo1 / (float)(N - m - 1));
  }
  Cm /= (N - m);
  Cm1 /= (N - m - 1);
  return Cm - Cm1;
}

// Entropía multiescala
float calcularMSE(Mediciones* datos) {
  const int m = 2;
  const float r = 0.2;
  const int N = 10;
  float suma = 0.0;
  int conteoEscalas = 0;
  for (int escala = 1; escala <= 3; escala++) {
    float Cm = 0.0;
    for (int i = 0; i < N - m * escala; i += escala) {
      int conteo = 0;
      for (int j = 0; j < N - m * escala; j += escala) {
        if (fabs(prevReflectancia[i] - prevReflectancia[j]) <= r) conteo++;
      }
      Cm += log(conteo / (float)(N - m * escala));
    }
    suma += Cm / (N - m * escala);
    conteoEscalas++;
  }
  return suma / conteoEscalas;
}

// Fusión de datos multisensorial
void fusionDatos(Mediciones* datos) {
  float pesoSpO2 = 0.6, pesoReflectancia = 0.3, pesoTemperatura = 0.1;
  datos->spO2 = pesoSpO2 * datos->spO2 + pesoReflectancia * (100.0 * datos->redReflectance) +
                pesoTemperatura * (datos->temperatura - 37.0 + 95.0);
}

// Estimación de hidratación
void estimarHidratacion(Mediciones* datos) {
  float factorTermico = 1.0 + 0.1 * (datos->temperatura - 37.0);
  float factorFC = 1.0 + 0.05 * (datos->hr - restingHR);
  datos->hidratacion = 100.0 - 10.0 * (1.0 - datos->irReflectance) * factorTermico * factorFC;
  datos->hidratacionTisular = 100 - K_HIDRATACION * datos->espesorTisular;
}