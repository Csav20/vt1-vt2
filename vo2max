// VO2Smart // Claudio Abarca // Patente 2024024875
// Proyecto VO2Max ESP32 Integrado - Versión Optimizada 3.0
// Fecha: 2 de abril de 2025
// Optimizado por Csav20

//*Board: ESP32 Dev Module
//Upload Speed: 921600
//CPU Frequency: 240Mhz (WiFi/BT)
//Flash Frequency: 80Mhz
//Flash Mode: QIO
//Flash Size: 4MB (32Mb)
//Partition Scheme: Default 4MB with spiffs (1.2MB APP/1.5 SPIFFS)
//Core Debug Level: None
//PSRAM: Disabled*/

#include <WiFi.h>
#include <WebServer.h>
#include <Arduino.h>
#include <Wire.h>
#include <SPI.h>
#include <EEPROM.h>
#include "esp_adc_cal.h"
#include <TFT_eSPI.h>
#include <BLEDevice.h>
#include <BLEServer.h>
#include <BLEUtils.h>
#include <BLE2902.h>
#include "BluetoothSerial.h"
#include <CircularBuffer.hpp>
#include <limits>
#include <ESPmDNS.h>

// Sensores
#include "DFRobot_OxygenSensor.h"
#include "SCD30.h"
#include "Omron_D6FPH.h"
#include "Adafruit_BMP280.h"

#if !defined(CONFIG_BT_ENABLED) || !defined(CONFIG_BLUEDROID_ENABLED)
#error Bluetooth is not enabled! Please run `make menuconfig` to and enable it
#endif

// Configuración del dispositivo
#define DEVICE_VERSION "V3.0 2025/04/02"
#define DEVICE_NAME "VO2Smart"

// Algoritmos de cálculo de VO2
#define VO2_METHOD_VSLOPE 0      // Método V-Slope estándar (por defecto)
#define VO2_METHOD_WASSERMAN 1   // Método de Wasserman
#define VO2_METHOD_BEAVER 2      // Método de Beaver
#define VO2_METHOD_DICKHUTH 3    // Método de Dickhuth

// Configuración del venturi
#define DIAMETER 20 // diámetro del tubo venturi en mm

// Configuración de depuración
#define DEBUG_ENABLED true
#define VERBOSE false  // Mensajes de depuración detallados

// Pinout
#define ADC_EN 14
#define ADC_PIN 34
#define BUTTON_PIN1 0
#define BUTTON_PIN2 35

// Constantes científicas
#define FI02 20.93         // % O2 ambiental (aire seco)
#define FICO2 0.0004       // % CO2 ambiental
#define PRESION_STPD 101325.0  // Presión estándar (Pa)
#define TEMP_STPD 273.15   // Temperatura estándar (K)
#define CONSTANTE_GASES 287.05 // J/(kg·K)
#define MUESTRAS_VT 30     // Muestras para detección de umbral ventilatorio

// Constantes ISO
#define CD_ISO5167 0.98    // ISO 5167-1: Coeficiente de descarga
#define WEIR_A 3.9         // ISO 8996: Constante A de la ecuación de Weir
#define WEIR_B 1.1         // ISO 8996: Constante B de la ecuación de Weir
#define CALIBRATION_TOLERANCE 0.05 // ISO 16269-6: Tolerancia de calibración (±5%)
#define SYRINGE_VOLUME 3000.0    // 3L según estándar ATS/ERS
#define CALIB_TIMEOUT_MS 30000   // 30 segundos máx. por calibración
#define CALIB_ALLOWED_ERROR 5.0  // 5% máximo de error

// Tiempos de muestreo
#define SENSOR_SAMPLING_MS 50    // 20Hz
#define UI_REFRESH_MS 100        // 10Hz
#define VO2_CALCULATION_MS 5000  // 0.2Hz

// Sensor O2
#define OXYGEN_I2C_ADDRESS ADDRESS_3
#define OXYGEN_COLLECT_NUMBER 10

// Constantes para transmisión de datos
#define DATA_TRANSMISSION_INTERVAL 1000    // Intervalo de transmisión de datos (ms)
#define MAX_RETRIES 3                      // Máximo número de reintentos para transmisión
#define DATA_BUFFER_SIZE 5                 // Número de registros a almacenar en buffer

// Connectivity Settings
const char* ssid = "VO2Max_Network";
const char* password = "vo2smart2025";
const char* deviceName = "VO2Smart"; 

// Updated HTML Page with enhanced features
const char* htmlPage = R"rawliteral(
<!DOCTYPE html>
<html>
<head>
    <title>VO2Smart Dashboard</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
        body { font-family: Arial; margin: 0; padding: 20px; background: #f0f0f0; }
        .container { max-width: 800px; margin: auto; }
        .header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
        .header-title { margin: 0; }
        .date-time { text-align: right; }
        .card { background: white; padding: 15px; margin: 10px 0; border-radius: 5px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
        .value { font-size: 24px; color: #2196F3; }
        .controls { display: flex; justify-content: space-between; margin: 15px 0; }
        .btn { padding: 10px 15px; border: none; border-radius: 4px; cursor: pointer; font-weight: bold; }
        .btn-start { background: #4CAF50; color: white; }
        .btn-stop { background: #f44336; color: white; }
        .btn-download { background: #2196F3; color: white; }
        canvas { width: 100%; height: 200px; }
        .metrics { display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; }
        .metric { padding: 10px; }
        @media (max-width: 600px) {
            .metrics { grid-template-columns: 1fr; }
        }
        
        // Function to read filtered flow
        float readFilteredFlow() {
            float rawPressure = pressureSensor.getPressure();
            if (!isnan(rawPressure)) {
                if (settings.useAdvancedFilters) {
                    return filtroPresion.filtrar(rawPressure);
                } else {
                    return rawPressure;
                }
            }
            return 0.0; // Return 0 if the pressure reading is invalid
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1 class="header-title" id="header-title">VO2Smart Dashboard</h1>
            <div class="date-time">
                <div id="date">Date: --/--/----</div>
                <div id="time">Time: --:--:--</div>
            </div>
        </div>
        
        <div class="controls">
            <button id="startBtn" class="btn btn-start">Start Reading</button>
            <button id="stopBtn" class="btn btn-stop" disabled>Stop Reading</button>
            <button id="downloadBtn" class="btn btn-download">Download Data</button>
        </div>
        
        <div class="card">
            <div class="metrics">
                <div class="metric">
                    <h3>VO2 Max</h3>
                    <span class="value" id="vo2">0</span> ml/kg/min
                </div>
                <div class="metric">
                    <h3>RQ</h3>
                    <span class="value" id="rq">0</span>
                </div>
                <div class="metric">
                    <h3>VT1</h3>
                    <span class="value" id="vt1">0</span> ml/kg/min
                </div>
                <div class="metric">
                    <h3>VT2</h3>
                    <span class="value" id="vt2">0</span> ml/kg/min
                </div>
                <div class="metric">
                    <h3>Device Time</h3>
                    <span class="value" id="deviceTime">00:00</span>
                </div>
                <div class="metric">
                    <h3>Session Duration</h3>
                    <span class="value" id="sessionTime">00:00</span>
                </div>
            </div>
        </div>
        
        <div class="card">
            <canvas id="vo2Chart"></canvas>
        </div>
    </div>
    
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script>
        // Initialize variables
        let dataLog = [];
        let isReading = false;
        let startTime = null;
        let updateInterval = null;
        
        // Set up the chart
        var ctx = document.getElementById('vo2Chart').getContext('2d');
        var vo2Chart = new Chart(ctx, {
            type: 'line',
            data: { 
                labels: [], 
                datasets: [
                    { 
                        label: 'VO2 Max', 
                        data: [], 
                        borderColor: '#2196F3', 
                        fill: false 
                    },
                    { 
                        label: 'VT1', 
                        data: [], 
                        borderColor: 'rgba(255, 165, 0, 0.5)', 
                        fill: false,
                        pointRadius: 0,
                        borderDashed: [5, 5]
                    },
                    { 
                        label: 'VT2', 
                        data: [], 
                        borderColor: 'rgba(255, 0, 0, 0.5)', 
                        fill: false,
                        pointRadius: 0,
                        borderDashed: [5, 5]
                    }
                ]
            },
            options: { 
                scales: { y: { beginAtZero: true } },
                animation: { duration: 0 }
            }
        });
        
        // Update clock
        function updateClock() {
            const now = new Date();
            document.getElementById('date').textContent = 'Date: ' + now.toLocaleDateString();
            document.getElementById('time').textContent = 'Time: ' + now.toLocaleTimeString();
        }
        setInterval(updateClock, 1000);
        updateClock();
        
        // Update data from device
        function updateData() {
            if (!isReading) return;
            
            fetch('/data')
                .then(response => response.json())
                .then(data => {
                    // Añadir indicador de modo demo
                    if (data.demoMode) {
                        // Si no existe ya el indicador, lo creamos
                        if (!document.getElementById('demoIndicator')) {
                            const indicator = document.createElement('div');
                            indicator.id = 'demoIndicator';
                            indicator.innerHTML = 'MODO DEMO';
                            indicator.style.position = 'fixed';
                            indicator.style.top = '10px';
                            indicator.style.right = '10px';
                            indicator.style.background = 'red';
                            indicator.style.color = 'white';
                            indicator.style.padding = '5px 10px';
                            indicator.style.borderRadius = '5px';
                            indicator.style.fontWeight = 'bold';
                            document.body.appendChild(indicator);
                            
                            // También cambiar el título
                            document.querySelector('.header-title').textContent = 'VO2Smart Dashboard (DEMO)';
                            document.querySelector('.header-title').style.color = 'red';
                        }
                    } else {
                        // Remover indicador si existe
                        const indicator = document.getElementById('demoIndicator');
                        if (indicator) {
                            indicator.remove();
                            document.querySelector('.header-title').textContent = 'VO2Smart Dashboard';
                            document.querySelector('.header-title').style.color = '';
                        }
                    }
                    
                    // Continuar con la actualización normal de datos
                    // Actualizar indicador de modo
                    if (data.demoMode) {
                        document.getElementById('header-title').innerText = "VO2Smart Dashboard (DEMO)";
                        document.getElementById('header-title').style.color = "#FF4444";
                    } else {
                        document.getElementById('header-title').innerText = "VO2Smart Dashboard";
                        document.getElementById('header-title').style.color = "#000000";
                    }

                    // Actualizar valores
                    document.getElementById('vo2').innerText = data.vo2Max.toFixed(1);
                    document.getElementById('rq').innerText = data.rq.toFixed(2);
                    document.getElementById('vt1').innerText = data.vt1.toFixed(1);
                    document.getElementById('vt2').innerText = data.vt2.toFixed(1);
                    document.getElementById('deviceTime').innerText = data.time;
                    
                    // Update session time
                    const now = new Date();
                    const elapsed = Math.floor((now - startTime) / 1000);
                    const minutes = Math.floor(elapsed / 60).toString().padStart(2, '0');
                    const seconds = (elapsed % 60).toString().padStart(2, '0');
                    document.getElementById('sessionTime').innerText = `${minutes}:${seconds}`;
                    
                    // Update chart
                    vo2Chart.data.labels.push(data.time);
                    vo2Chart.data.datasets[0].data.push(data.vo2Max);
                    
                    // Add horizontal lines for VT1 and VT2 if detected
                    const vt1Value = parseFloat(data.vt1);
                    const vt2Value = parseFloat(data.vt2);
                    
                    if (vt1Value > 0) {
                        vo2Chart.data.datasets[1].data = Array(vo2Chart.data.labels.length).fill(vt1Value);
                    }
                    
                    if (vt2Value > 0) {
                        vo2Chart.data.datasets[2].data = Array(vo2Chart.data.labels.length).fill(vt2Value);
                    }
                    
                    // Limit data points to keep chart readable
                    if (vo2Chart.data.labels.length > 60) {
                        vo2Chart.data.labels.shift();
                        vo2Chart.data.datasets[0].data.shift();
                        vo2Chart.data.datasets[1].data.shift();
                        vo2Chart.data.datasets[2].data.shift();
                    }
                    
                    vo2Chart.update();
                    
                    // Log data for download
                    dataLog.push({
                        timestamp: new Date().toISOString(),
                        deviceTime: data.time,
                        vo2Max: data.vo2Max,
                        rq: data.rq,
                        vt1: data.vt1,
                        vt2: data.vt2
                    });
                })
                .catch(error => {
                    console.error('Error fetching data:', error);
                });
        }
        
        // Start reading data
        document.getElementById('startBtn').addEventListener('click', function() {
            isReading = true;
            startTime = new Date();
            this.disabled = true;
            document.getElementById('stopBtn').disabled = false;
            
            // Start regular updates
            updateInterval = setInterval(updateData, 1000);
            updateData(); // Initial update
        });
        
        // Stop reading data
        document.getElementById('stopBtn').addEventListener('click', function() {
            isReading = false;
            clearInterval(updateInterval);
            this.disabled = true;
            document.getElementById('startBtn').disabled = false;
        });
        
        // Download data as CSV
        document.getElementById('downloadBtn').addEventListener('click', function() {
            if (dataLog.length === 0) {
                alert('No data to download yet');
                return;
            }
            
            // Create CSV content
            let csvContent = 'data:text/csv;charset=utf-8,';
            csvContent += 'Timestamp,Device Time,VO2 Max,RQ,VT1,VT2\r\n';
            
            dataLog.forEach(function(row) {
                csvContent += `${row.timestamp},${row.deviceTime},${row.vo2Max},${row.rq},${row.vt1},${row.vt2}\r\n`;
            });
            
            // Create download link
            const encodedUri = encodeURI(csvContent);
            const link = document.createElement('a');
            link.setAttribute('href', encodedUri);
            link.setAttribute('download', 'VO2Smart_Data_' + new Date().toISOString().slice(0,19).replace(/:/g,'-') + '.csv');
            document.body.appendChild(link);
            
            // Download file
            link.click();
            document.body.removeChild(link);
        });
    </script>
</body>
</html>
)rawliteral";

// Servidor web
WebServer server(80);

// ===================== Clases y Estructuras =====================

// Estructura para almacenar registros de calibración
struct CalibLog {
    uint32_t timestamp;
    float expectedVol;
    float measuredVol;
    float error;
    bool passed;
};

// Configuración guardada en EEPROM
struct Settings {
    int version = 1;
    float correctionSensor = 1.0;
    float weightKg = 75.0;
    bool co2SensorEnabled = false;
    uint8_t backlightLevel = 80;
    bool autoCalibration = false;
    bool useAdvancedFilters = true; // Controlar filtros avanzados desde el menú
    uint8_t vo2Method = VO2_METHOD_VSLOPE; // Método de cálculo de umbrales ventilatorios
    float flowCalibFactor = 1.0;
    float o2CalibReference = 20.93;
    CalibLog lastCalib[3];  // Log de últimas 3 calibraciones
};

// Datos en vivo de mediciones
struct LiveData {
    // Mediciones directas
    float pressure = 0.0;       // Presión diferencial (Pa)
    float o2Percent = 20.9;     // % de oxígeno
    float co2Ppm = 400.0;       // CO2 en ppm
    float ambientTemp = 20.0;   // Temperatura ambiente (°C)
    float ambientPressure = 101325.0; // Presión barométrica (Pa)
    float humidity = 50.0;      // Humedad relativa (%)
    
    // Valores calculados
    float volumeTotal = 0.0;    // Volumen total (mL)
    float volumeExp = 0.0;      // Volumen espiratorio (L)
    float volumeVE = 0.0;       // Ventilación por minuto (L/min)
    float volumeVEMean = 0.0;   // Media de VE (L/min)
    float breathRate = 0.0;     // Frecuencia respiratoria (resp/min)
    float breathRateMean = 0.0; // Media de frecuencia respiratoria
    float vo2 = 0.0;            // Consumo de oxígeno (mL/min/kg)
    float vo2Max = 0.0;         // VO2 máximo (mL/min/kg)
    float vco2 = 0.0;           // Producción de CO2 (mL/min/kg)
    float rer = 0.0;            // Cociente respiratorio
    float calories = 0.0;       // Calorías consumidas
    float caloriesPerHour = 0.0;// Tasa calórica (kcal/h)
    float caloriesPerDay = 0.0; // Tasa calórica (kcal/día)
    
    // Estado del sistema
    float batteryVoltage = 4.0; // Voltaje de batería
    bool sensorError = false;   // Indicador de error en sensores
    uint32_t totalTimeMs = 0;   // Tiempo total desde inicio (ms)
    uint8_t screenNumber = 1;   // Pantalla actual
    bool dataTransmissionEnabled = true; // Habilitar transmisión de datos
    uint32_t lastSentTime = 0;  // Tiempo de último envío de datos
    
    // Umbrales ventilatorios
    float vt1VO2 = 0.0;        // VO2 en el primer umbral ventilatorio
    float vt2VO2 = 0.0;        // VO2 en el segundo umbral ventilatorio
    uint32_t vt1Time = 0;      // Tiempo cuando se detectó VT1
    uint32_t vt2Time = 0;      // Tiempo cuando se detectó VT2
    bool vt1Detected = false;  // Indicador de detección de VT1
    bool vt2Detected = false;  // Indicador de detección de VT2
    
    // Referencias
    float initialO2 = 20.9;     // Valor inicial de O2
    float initialCO2 = 400.0;   // Valor inicial de CO2
    float airDensity = 1.225;   // Densidad del aire (kg/m³)
    float airDensityBTPS = 1.123; // Densidad BTPS
};

// Estructura para almacenar registros de datos
struct DataRecord {
    uint32_t timestamp;
    float vo2;
    float vco2;
    float rer;
    float volumeVE;
    float o2Percent;
    float co2Ppm;
    float breathRate;
    float calories;
    bool vt1Detected;
    bool vt2Detected;
    float vt1VO2;
    float vt2VO2;
};

// Filtro Kalman estándar para reducir ruido
class FiltroKalman {
private:
    float estimacion;
    float errorEstimacion;
    float errorMedicion;
    float gananciaKalman;

public:
    FiltroKalman(float errorInicial = 1.0, float errorMedicionInicial = 0.1) {
        estimacion = 0.0;
        errorEstimacion = errorInicial;
        errorMedicion = errorMedicionInicial;
    }

    float filtrar(float medicion) {
        gananciaKalman = errorEstimacion / (errorEstimacion + errorMedicion);
        estimacion = estimacion + gananciaKalman * (medicion - estimacion);
        errorEstimacion = (1 - gananciaKalman) * errorEstimacion;
        return estimacion;
    }
    
    void reset(float valorInicial = 0.0, float errorInicial = 1.0) {
        estimacion = valorInicial;
        errorEstimacion = errorInicial;
    }
};

// Filtro Kalman Gaussiano
class FiltroKalmanGauss {
private:
    float media;
    float varianza;

public:
    FiltroKalmanGauss(float mediaInicial = 20.93, float varianzaInicial = 0.5) {
        media = mediaInicial;
        varianza = varianzaInicial;
    }

    float filtrar(float medicion, float varianzaMedicion = 0.1) {
        float peso = varianza / (varianza + varianzaMedicion);
        media = media + peso * (medicion - media);
        varianza = (1 - peso) * varianza;
        return media;
    }
    
    void reset(float mediaInicial = 20.93, float varianzaInicial = 0.5) {
        media = mediaInicial;
        varianza = varianzaInicial;
    }
};

// Filtro Kalman Cuántico (simplificado)
class FiltroKalmanCuantico {
private:
    float estado;
    float probabilidad;

public:
    FiltroKalmanCuantico(float estadoInicial = 0.04, float probabilidadInicial = 0.9) {
        estado = estadoInicial;
        probabilidad = probabilidadInicial;
    }

    float filtrar(float medicion, float probabilidadMedicion = 0.8) {
        probabilidad = probabilidad * probabilidadMedicion;
        estado = (estado * probabilidadMedicion + medicion * probabilidad) / (probabilidad + probabilidadMedicion);
        return estado;
    }
    
    void reset(float estadoInicial = 0.04, float probabilidadInicial = 0.9) {
        estado = estadoInicial;
        probabilidad = probabilidadInicial;
    }
};

// Filtro Kalman mejorado
class KalmanFilter {
public:
    float Q, R, x, P, K;
    KalmanFilter(float processNoise = 0.01, float measurementNoise = 0.1, float initialState = 0.0) {
        Q = processNoise; 
        R = measurementNoise; 
        x = initialState; 
        P = 0.0; 
        K = 0.0;
    }
    
    float update(float measurement) {
        P = P + Q; 
        K = P / (P + R); 
        x = x + K * (measurement - x); 
        P = (1 - K) * P; 
        return x;
    }
};

// Filtro de Maxwell-Boltzmann para gases respiratorios
class MaxwellBoltzmannFilter {
private:
    float T = 310.15;          // Temperatura en Kelvin (por defecto 37°C)
    float k = 1.38e-23;        // Constante de Boltzmann
    float m = 5.31e-26;        // Masa molecular promedio
    float lastValue = 0.0;     // Último valor filtrado
    float alpha = 0.1;         // Factor de suavizado

public:
    void updateTemperature(float tempC) { 
        T = tempC + 273.15; 
    }
    
    float update(float z, float pressure, float tempC) {
        updateTemperature(tempC);
        float v_mean = sqrt(8.0 * k * T / (PI * m));
        float expected = z * (pressure / (k * T));
        lastValue = alpha * expected + (1 - alpha) * lastValue;
        return lastValue;
    }
};

// Filtro de partículas cuánticas para mediciones de alta variabilidad
class QuantumParticleFilter {
private:
    static const int N_PARTICLES = 50;
    float particles[N_PARTICLES]; 
    float weights[N_PARTICLES];
    float mean = 0.0;

public:
    QuantumParticleFilter(float initial = 0.0) {
        for (int i = 0; i < N_PARTICLES; i++) {
            particles[i] = initial + random(-10, 10) / 10.0;
            weights[i] = 1.0 / N_PARTICLES;
        }
    }
    
    float update(float z) {
        float sumWeights = 0.0;
        for (int i = 0; i < N_PARTICLES; i++) {
            particles[i] += random(-10, 10) / 100.0;
            weights[i] *= exp(-pow(z - particles[i], 2) / 2.0);
            sumWeights += weights[i];
        }
        
        if (sumWeights == 0) sumWeights = 1e-10;
        
        for (int i = 0; i < N_PARTICLES; i++) {
            weights[i] /= sumWeights;
        }
        
        mean = 0.0;
        for (int i = 0; i < N_PARTICLES; i++) {
            mean += particles[i] * weights[i];
        }
        
        return mean;
    }
};

// Clase para el manejo de temporizadores
class Timer {
private:
    uint32_t interval;

public:
    uint32_t lastTime;  // Make this public

    Timer(uint32_t intervalMs = 1000) : interval(intervalMs) {
        lastTime = millis();
    }
    bool isReady() {
        uint32_t currentTime = millis();
        if (currentTime - lastTime >= interval) {
            lastTime = currentTime;
            return true;
        }
        return false;
    }

    void reset() {
        lastTime = millis();
    }

    void setInterval(uint32_t intervalMs) {
        interval = intervalMs;
    }
    
    uint32_t getElapsedTime() {
        return millis() - lastTime;
    }
};

// Callback para conexiones BLE
class MyServerCallbacks : public BLEServerCallbacks {
private:
    bool* clientConnected;
    
public:
    MyServerCallbacks(bool* connected) : clientConnected(connected) {}
    
    void onConnect(BLEServer* server) override {
        *clientConnected = true;
        if (DEBUG_ENABLED) {
            Serial.println("Cliente BLE conectado");
        }
    }

    void onDisconnect(BLEServer* server) override {
        *clientConnected = false;
        if (DEBUG_ENABLED) {
            Serial.println("Cliente BLE desconectado");
        }
    }
};

// Estructura para almacenar registros de calibración
struct CalibLog {
    uint32_t timestamp;
    float expectedVol;
    float measuredVol;
    float error;
    bool passed;
};

// ===================== Variables Globales =====================

// Objetos de hardware
TFT_eSPI tft = TFT_eSPI();
Omron_D6FPH pressureSensor;
DFRobot_OxygenSensor oxygenSensor;
Adafruit_BMP280 bmp;
BluetoothSerial SerialBT;

// Estado global
Settings settings;
LiveData liveData;
bool bleClientConnected = false;
bool demoMode = true;
int screenChanged = 0;
bool headersInitialized = false;
SemaphoreHandle_t dataMutex;

// Filtros
FiltroKalman filtroPresion(2.0, 0.5);
FiltroKalmanGauss filtroO2(20.93, 0.5);
FiltroKalmanCuantico filtroCO2(0.04, 0.9);
FiltroKalman filtroTemperatura(1.0, 0.5);
FiltroKalman filtroVentilacion(2.0, 1.0);

// Filtros avanzados adicionales
MaxwellBoltzmannFilter mbFilterO2;
QuantumParticleFilter qpFilterVO2(20.0);  // Inicializado con un valor típico de VO2

// Buffers circulares para detección de umbrales ventilatorios
CircularBuffer<float, MUESTRAS_VT> vo2Buffer;
CircularBuffer<float, MUESTRAS_VT> vco2Buffer;

// Buffers para métodos avanzados de cálculo de umbrales
CircularBuffer<float, 30> time_data;
CircularBuffer<float, 30> vo2_data;
CircularBuffer<float, 30> vco2_data;

// Buffer circular para almacenar datos cuando hay problemas de transmisión
CircularBuffer<DataRecord, DATA_BUFFER_SIZE> dataBuffer;

// Temporizadores
Timer sensorTimer(SENSOR_SAMPLING_MS);
Timer uiTimer(UI_REFRESH_MS);
Timer vo2CalcTimer(VO2_CALCULATION_MS);
Timer startupTimer;
Timer measurementTimer;
Timer blinkTimer(500);
Timer dataTransmissionTimer(DATA_TRANSMISSION_INTERVAL);
Timer screenCycleTimer(2000); // 2 seconds between screen changes in demo mode

// Áreas del venturi (calculadas desde el diámetro)
float venturiArea1 = 0.000531;  // = 26mm diámetro (área entrada, m²)
float venturiArea2;             // Área constricción (calculada en setup)

// Estado de los botones
int buttonState1 = 1;
int buttonPushCounter1 = 0;
int buttonState2 = 1;
int buttonPushCounter2 = 0;

// Umbrales
const float PRESSURE_THRESHOLD = 0.2;  // Umbral de presión para iniciar cálculo VE

// Estado del WiFi
bool wifiActive = false;
bool webServerActive = false;
Timer wifiCheckTimer(10000); // Verificar conexión WiFi cada 10 segundos

// ===================== Prototipos de Funciones =====================
bool checkEnvironmentalStability();
void showError(const char* message);

// Funciones de inicialización
void initializeHardware();
void initializeSensors();
void loadSettings();
void saveSettings();
void initializeBLE();
void beginMeasurement();

// Funciones de UI
void drawScreen();
void updateScreen();
void drawScreen1();
void drawScreen2();
void drawScreen3();
void drawScreen4();
void drawScreen5();
void drawScreen6(); // Nueva pantalla para umbrales ventilatorios
void drawParametersScreen();
void drawScreen8(); // Nueva pantalla para información de conectividad
void readButtons();
void handleButtonActions();
void showSplashScreen();
void showCalibrationMenu();
void updateBacklight();
void showISOScreen(); // Display ISO standards information
void showDemoSelectionScreen(); // Screen to select between normal and demo modes
void drawScreen7(); // Display ISO standards information as a regular screen

// Funciones de medición
void readSensors();
void calculateRespiratory();
void calculateMetabolic();
void detectVentilatoryThresholds();
void readVoltage();
void readAmbientConditions();

// Funciones de calibración
void calibrateO2Sensor();
void calibrateFlowSensor();
void calibrateCO2Sensor();
void setWeight();
bool performSyringeCalibration();
void drawSyringeCalibrationScreen(float volInyectado, float progress);
bool checkCalibrationConditions();
void showCalibrationResult(bool passed, float error);

// Utilidades
void logData();
String formatTime(uint32_t timeMs);
float convertToSTPD(float volume, float temperature, float pressure);
void safetyChecks();

// Funciones ISO
float calculatePH2O(float temperature);
float termISO26782(float temperature, float pressure);
void logCalibration(float value, float refValue);
bool testThermalStability(float temperature, float threshold = 0.5);
bool autoCalibrate(float measured, float expected, float tolerance = CALIBRATION_TOLERANCE);

// Funciones de datos
void saveDataRecord();
bool transmitData(const String& dataString, uint8_t retries = MAX_RETRIES);
String formatDataRecord(const DataRecord& record);
void flushDataBuffer();
void toggleDataTransmission();
void toggleVO2Method();

// Tareas FreeRTOS
void sensorTask(void* parameters);
void uiTask(void* parameters);

// Funciones de Web Server
void setupWiFi();
void handleRoot();
void handleData();
void handleNotFound();

// Funciones avanzadas de cálculo de umbrales ventilatorios
void calculateVO2Wasserman();
void calculateVO2Beaver();
void calculateVO2Dickhuth();

// Añadir estas declaraciones en la sección de "Prototipos de Funciones"
void calculateFlow();
void checkInitialO2();
void checkInitialCO2();
void drawBatteryIndicator();
void updateTimers(); // Update time tracking variables

// ===================== Implementación de Funciones =====================

void setup() {
    // Calculate proper area based on diameter
    #if (DIAMETER == 20)
    venturiArea2 = 0.000314;  // 20mm diameter
    #elif (DIAMETER == 19)
    venturiArea2 = 0.000284;  // 19mm diameter
    #else
    venturiArea2 = 0.000201;  // 16mm diameter (default)
    #endif

    // Initialize EEPROM and hardware
    EEPROM.begin(sizeof(Settings));
    loadSettings();
    
    // Initialize hardware
    initializeHardware();
    
    // Mostrar pantalla de normas ISO primero
    showISOScreen();
    delay(2000);
    
    // Mostrar pantalla de selección de modo
    showDemoSelectionScreen();
    
    // Mostrar pantalla de inicio
    showSplashScreen();
    
    // Inicializar sensores solo si no es demo
    if (!demoMode) {
        initializeSensors();
    } else {
        // Configuración inicial para demo
        liveData.initialO2 = 20.9;
        liveData.initialCO2 = 400.0;
        liveData.ambientTemp = 25.0;
        liveData.ambientPressure = 101325.0;
        liveData.humidity = 50.0;
    }
    
    // Initialize Bluetooth communication
    initializeBLE();
    
    // Show initial parameters
    drawParametersScreen();
    delay(2000);
    
    // Create mutex for data synchronization
    dataMutex = xSemaphoreCreateMutex();
    
    // Create tasks on separate cores
    xTaskCreatePinnedToCore(
        sensorTask,
        "SensorTask",
        10000,
        NULL,
        1,
        NULL,
        0  // Core 0
    );
    
    xTaskCreatePinnedToCore(
        uiTask,
        "UITask",
        10000,
        NULL,
        1,
        NULL,
        1  // Core 1
    );

    // Initialize WiFi after hardware initialization
    startupTimer.reset();  // Explicitly reset the timer when starting
    setupWiFi();
    
    // Begin measurement
    beginMeasurement();
}

void loop() {
    // El loop principal no se usa, todo se ejecuta en tareas
    vTaskDelete(NULL);
}

// ===================== Tareas FreeRTOS =====================

void sensorTask(void* parameters) {
    while (true) {
        if (sensorTimer.isReady()) {
            if (xSemaphoreTake(dataMutex, pdMS_TO_TICKS(100)) == pdTRUE) {
                readSensors();
                calculateRespiratory();
                
                if (vo2CalcTimer.isReady()) {
                    calculateMetabolic();
                    detectVentilatoryThresholds();
                    readVoltage();
                    logData();
                }
                
                if (liveData.dataTransmissionEnabled && dataTransmissionTimer.isReady()) {
                    saveDataRecord();
                    flushDataBuffer();
                }
                
                updateTimers();
                xSemaphoreGive(dataMutex);
            }
        }
        
        if (wifiCheckTimer.isReady() && wifiActive) {
            if (WiFi.status() != WL_CONNECTED) {
                WiFi.reconnect();
            }
        }
        
        if (webServerActive) {
            server.handleClient(); // Maneja solicitudes del dashboard
        }
        
        vTaskDelay(1);
    }
}

void uiTask(void* parameters) {
    while (true) {
        if (uiTimer.isReady()) {
            readButtons();
            handleButtonActions();
            
            // Auto cycle through screens in demo mode
            if (demoMode && screenCycleTimer.isReady()) {
                liveData.screenNumber++;
                if (liveData.screenNumber > 9) {
                    liveData.screenNumber = 1;
                }
                screenChanged = 1;
            }
            
            if (xSemaphoreTake(dataMutex, pdMS_TO_TICKS(100)) == pdTRUE) {
                updateScreen();
                xSemaphoreGive(dataMutex);
            }
            
            updateBacklight();
        }
        
        // Permitir que otras tareas se ejecuten
        vTaskDelay(1);
    }
}

// ===================== Funciones de inicialización =====================

void initializeHardware() {
    // Configurar pines
    pinMode(BUTTON_PIN1, INPUT_PULLUP);
    pinMode(BUTTON_PIN2, INPUT_PULLUP);
    pinMode(ADC_EN, OUTPUT);
    digitalWrite(ADC_EN, HIGH);
    
    // Inicializar pantalla
    tft.init();
    tft.setRotation(1);
    showError("Error: TFT screen issue!");
    
    // Inicializar Serial
    Serial.begin(115200);
    Wire.begin();
    
    // Configurar ADC para medición de batería
    esp_adc_cal_characteristics_t adc_chars;
    esp_adc_cal_value_t val_type = esp_adc_cal_characterize(
        ADC_UNIT_1, ADC_ATTEN_11db, ADC_WIDTH_BIT_12, 1100, &adc_chars);
        
    // Verificar modo demo
    if (!digitalRead(BUTTON_PIN2)) {
        demoMode = true;
    }
}

void loadSettings() {
    int storedVersion = EEPROM.read(0);
    if (storedVersion == settings.version) {
        uint8_t* settingsBytes = (uint8_t*)&settings;
        for (size_t i = 0; i < sizeof(Settings); i++) {
            settingsBytes[i] = EEPROM.read(i);
        }
    }
}

void saveSettings() {
    bool changed = false;
    uint8_t* settingsBytes = (uint8_t*)&settings;
    
    for (size_t i = 0; i < sizeof(Settings); i++) {
        uint8_t currentValue = EEPROM.read(i);
        if (currentValue != settingsBytes[i]) {
            EEPROM.write(i, settingsBytes[i]);
            changed = true;
        }
    }
    
    if (changed) {
        EEPROM.commit();
    }
}

void initializeSensors() {
    bool sensorsOk = true;
    
    // Inicializar BMP280 (temperatura y presión)
    if (!bmp.begin(BMP280_ADDRESS)) {
        tft.drawString("Temp/Pres. Error!", 0, 50, 4);
        sensorsOk = false;
    } else {
        tft.drawString("Temp/Pres. ok", 0, 50, 4);
        bmp.setSampling(Adafruit_BMP280::MODE_NORMAL,
                        Adafruit_BMP280::SAMPLING_X2,
                        Adafruit_BMP280::SAMPLING_X16,
                        Adafruit_BMP280::FILTER_X16,
                        Adafruit_BMP280::STANDBY_MS_500);
    }
    
    // Inicializar sensor de oxígeno
    if (!oxygenSensor.begin(OXYGEN_I2C_ADDRESS)) {
        tft.drawString("O2 ERROR!", 0, 75, 4);
        sensorsOk = false;
    } else {
        tft.drawString("O2 ok", 0, 75, 4);
    }
    
    // Inicializar sensor de CO2
    scd30.initialize();
    scd30.setAutoSelfCalibration(settings.autoCalibration ? 1 : 0);
    int retries = 0;
    while (!scd30.isAvailable() && retries < 10) {
        tft.drawString("CO2init..", 120, 75, 4);
        delay(500);
        retries++;
    }
    
    if (retries < 10) {
        tft.drawString("CO2 ok", 120, 75, 4);
    } else {
        tft.drawString("CO2 timeout", 120, 75, 4);
        sensorsOk = false;
    }
    
    // Inicializar sensor de flujo
    retries = 0;
    while (!pressureSensor.begin(MODEL_0025AD1) && retries < 5) {
        tft.drawString("Flow-Sensor ERROR!", 0, 100, 4);
        delay(500);
        retries++;
    }
    
    if (retries < 5) {
        tft.drawString("Flow-Sensor ok", 0, 100, 4);
    } else {
        sensorsOk = false;
    }
    
    // Obtener valores iniciales de O2 y CO2
    checkInitialO2();
    checkInitialCO2();
}

void initializeBLE() {
    // Inicializar Serial Bluetooth
    if (!SerialBT.begin(DEVICE_NAME)) {
        tft.drawString("BT NOT ready!", 0, 25, 4);
    } else {
        tft.drawString("BT ready", 0, 25, 4);
    }
    
    // Inicializar BLE
    BLEDevice::init(DEVICE_NAME);
    BLEServer* pServer = BLEDevice::createServer();
    pServer->setCallbacks(new MyServerCallbacks(&bleClientConnected)); // Cambiado aquí
    
    // Configurar advertising
    BLEAdvertising* pAdvertising = pServer->getAdvertising();
    pAdvertising->setScanResponse(true);
    pAdvertising->setMinPreferred(0x06);
    pAdvertising->setMinPreferred(0x12);
    BLEDevice::startAdvertising();
}

void showSplashScreen() {
    tft.fillScreen(TFT_BLACK);
    tft.setTextColor(TFT_WHITE, TFT_BLACK);
    tft.drawString("VO2Smart", 0, 25, 4);
    tft.drawString(DEVICE_VERSION, 0, 50, 4);
    tft.drawString("Iniciando...", 0, 75, 4);
    
    if (demoMode) {
        tft.setTextColor(TFT_RED, TFT_BLACK);
        tft.drawString("DEMO-MODE!", 0, 100, 4);
    }
    
    // Add weight configuration option
    tft.setTextColor(TFT_YELLOW, TFT_BLACK);
    tft.drawString("Config Peso:", 0, 125, 2);
    tft.drawString(String(settings.weightKg) + " kg", 120, 125, 2);
    tft.drawString("(Presione ambos botones)", 0, 145, 1);
    
    // Check for button press to configure weight
    uint32_t startTime = millis();
    while (millis() - startTime < 3000) {
        if (!digitalRead(BUTTON_PIN1) && !digitalRead(BUTTON_PIN2)) {
            setWeight();
            break;
        }
        delay(100);
    }
    
    tft.fillScreen(TFT_BLACK);
}

void beginMeasurement() {
    // Reiniciar temporizadores
    startupTimer.reset();
    vo2CalcTimer.reset();
    measurementTimer.reset();
    
    // Resetear valores de detección de umbrales ventilatorios
    liveData.vt1Detected = false;
    liveData.vt2Detected = false;
    liveData.vt1VO2 = 0.0;
    liveData.vt2VO2 = 0.0;
    liveData.vt1Time = 0;
    liveData.vt2Time = 0;
    
    // Limpiar pantalla y preparar para mediciones
    tft.fillScreen(TFT_BLACK);
    tft.setTextColor(TFT_GREEN, TFT_BLACK);
    tft.drawCentreString("preparado...", 120, 55, 4);
    delay(1000);
}

// ===================== Funciones de sensores =====================

void readSensors() {
    if (demoMode) {
        uint32_t currentTime = millis();
        float sinValue = sin(currentTime / 2000.0);
        float cosValue = cos(currentTime / 1500.0);
        
        // Datos simulados más realistas
        liveData.pressure = (sinValue > 0) ? 10.0 + 5.0 * sinValue : 0.0;
        liveData.o2Percent = liveData.initialO2 - 4.0 * (0.5 + 0.5 * sinValue);
        liveData.co2Ppm = liveData.initialCO2 + 30000.0 * (0.5 + 0.5 * cosValue);
        liveData.ambientTemp = 25.0 + 2.0 * sinValue;
        liveData.humidity = 50.0 + 10.0 * cosValue;
        
        // Simular volumen y ventilación
        liveData.volumeExp = 1.5 + 0.5 * sinValue;
        liveData.volumeVE = 25.0 + 15.0 * sinValue;
        liveData.breathRate = 15.0 + 5.0 * sinValue;
        
        // VO2 y VCO2 simulados
        liveData.vo2 = 20.0 + 30.0 * (0.5 + 0.5 * sinValue);
        if (liveData.vo2 > liveData.vo2Max) liveData.vo2Max = liveData.vo2;
        liveData.vco2 = liveData.vo2 * (0.85 + 0.15 * cosValue);
        liveData.rer = liveData.vco2 / liveData.vo2;
        
        // Calorías simuladas
        liveData.calories = (currentTime / 1000.0) * 0.1; // Incremento gradual
        
        // Simulación de VT1 y VT2 persistente
        static bool vt1Detected = false;
        static bool vt2Detected = false;
        if (!vt1Detected && currentTime > 60000) { // VT1 después de 1 min
            vt1Detected = true;
            liveData.vt1Detected = true;
            liveData.vt1VO2 = 35.0 + random(0, 50) / 10.0;
            liveData.vt1Time = currentTime;
        }
        if (!vt2Detected && currentTime > 120000) { // VT2 después de 2 min
            vt2Detected = true;
            liveData.vt2Detected = true;
            liveData.vt2VO2 = 48.0 + random(0, 70) / 10.0;
            liveData.vt2Time = currentTime;
        }
    } else {
        // Leer datos reales de los sensores
        float rawPressure = pressureSensor.getPressure();
        if (!isnan(rawPressure)) {
            if (settings.useAdvancedFilters) {
                liveData.pressure = filtroPresion.filtrar(rawPressure);
            } else {
                liveData.pressure = rawPressure;
            }
        }
        
        // Corregir límites de presión
        if (liveData.pressure < 0) {
            liveData.pressure = 0;
        }
        
        // Leer sensor de oxígeno
        float rawO2 = oxygenSensor.ReadOxygenData(OXYGEN_COLLECT_NUMBER);
        if (!isnan(rawO2)) {
            if (settings.useAdvancedFilters) {
                // Usar el filtro más adecuado según configuración
                float filteredO2 = filtroO2.filtrar(rawO2, 0.2);
                
                // Aplicar filtro Maxwell-Boltzmann para estabilidad adicional
                filteredO2 = mbFilterO2.update(filteredO2, liveData.ambientPressure, liveData.ambientTemp);
                
                liveData.o2Percent = filteredO2;
            } else {
                liveData.o2Percent = rawO2;
            }
        }
        
        // Leer CO2 si está habilitado
        if (settings.co2SensorEnabled && scd30.isAvailable()) {
            float result[3] = {0};
            scd30.getCarbonDioxideConcentration(result);
            
            if (!isnan(result[0])) {
                if (settings.useAdvancedFilters) {
                    liveData.co2Ppm = filtroCO2.filtrar(result[0], 0.8);
                } else {
                    liveData.co2Ppm = result[0];
                }
                liveData.ambientTemp = result[1];
                liveData.humidity = result[2];
                
                // Verificar estabilidad térmica según ISO 80601-2-61
                if (!testThermalStability(result[1])) {
                    if (DEBUG_ENABLED) {
                        Serial.println("Advertencia: Inestabilidad térmica");
                    }
                }
            }
        }
    }
    
    calculateFlow(); // Actualizar flujo basado en presión simulada
}

void calculateFlow() {
    // Si la presión está por encima del umbral, calcular el flujo
    if (liveData.pressure >= PRESSURE_THRESHOLD) {
        // ISO 26782: Factor de corrección por temperatura
        float termo = termISO26782(liveData.ambientTemp, liveData.ambientPressure);
        
        // ISO 5167-1: Ecuación de Bernoulli con coeficiente de descarga
        float massFlow = 1000.0 * CD_ISO5167 * sqrt(
            (abs(liveData.pressure) * 2.0 * liveData.airDensity) /
            ((1.0 / (pow(venturiArea2, 2))) - (1.0 / (pow(venturiArea1, 2))))
        ) * termo;
        
        // Flujo volumétrico
        float volFlow = massFlow / liveData.airDensity;
        volFlow *= settings.correctionSensor;  // Aplicar factor de corrección
        
        // Integrar para obtener volumen total
        uint32_t elapsed = sensorTimer.getElapsedTime();
        liveData.volumeTotal += volFlow * elapsed;
        
        // Detectar inicio de respiración para cálculo de VE
        if (liveData.volumeTotal > 50) {
            measurementTimer.reset();
        }
    } else if (measurementTimer.getElapsedTime() < 5000) {
        // Calcular volumen espiratorio cuando la presión cae por debajo del umbral
        float duration = measurementTimer.getElapsedTime();
        if (duration > 0) {
            liveData.volumeExp = liveData.volumeTotal / 1000.0;  // Convertir a litros
            liveData.volumeVE = liveData.volumeExp / duration * 60000.0;  // L/min
            
            // Calcular media de ventilación
            if (settings.useAdvancedFilters) {
                liveData.volumeVEMean = filtroVentilacion.filtrar(liveData.volumeVE);
            } else {
                liveData.volumeVEMean = 0.8 * liveData.volumeVEMean + 0.2 * liveData.volumeVE;
            }
            
            // Calcular frecuencia respiratoria
            if (liveData.volumeVE > 0.1) {
                liveData.breathRate = 60000.0 / duration;
                liveData.breathRateMean = 0.75 * liveData.breathRateMean + 0.25 * liveData.breathRate;
            } else {
                liveData.breathRate = 0;
            }
            
            // Resetear volumen para la siguiente respiración
            liveData.volumeTotal = 0;
        }
        
        // Reiniciar timer para la próxima medición
        measurementTimer.reset();
    }
}

void calculateRespiratory() {
    // Leer condiciones ambientales
    readAmbientConditions();
    
    // Actualizar densidad del aire
    liveData.airDensity = liveData.ambientPressure / (liveData.ambientTemp + 273.15) / 287.058;
    liveData.airDensityBTPS = liveData.ambientPressure / (35.0 + 273.15) / 292.9;
}

void calculateMetabolic() {
    // Calcular la diferencia de O2
    float o2Diff = liveData.initialO2 - liveData.o2Percent;
    if (o2Diff < 0) o2Diff = 0;  // Corrección para deriva del sensor
    
    // Cálculo de VO2
    float vo2Total = liveData.volumeVEMean * liveData.airDensityBTPS / 1.292 * o2Diff * 10.0;  // ml/min
    
    // Aplicar filtro de partículas cuánticas para estabilizar el VO2 calculado
    if (settings.useAdvancedFilters) {
        vo2Total = qpFilterVO2.update(vo2Total);
    }
    
    liveData.vo2 = vo2Total / settings.weightKg;  // ml/min/kg
    
    // Actualizar VO2 máximo
    if (liveData.vo2 > liveData.vo2Max) {
        liveData.vo2Max = liveData.vo2;
    }
    
    // Cálculo de VCO2 si tenemos sensor de CO2
    if (settings.co2SensorEnabled) {
        float co2PercDiff = (liveData.co2Ppm - liveData.initialCO2) / 10000.0;
        if (co2PercDiff < 0) co2PercDiff = 0;
        
        float vco2Total = liveData.volumeVEMean * liveData.airDensityBTPS / 1.292 * co2PercDiff * 10.0;
        liveData.vco2 = vco2Total / settings.weightKg;
        
        // ISO 8996: Calcular RER (cociente respiratorio) usando molaridad
        if (vo2Total > 0) {
            liveData.rer = (vco2Total * 44.0) / (vo2Total * 32.0);
            if (isnan(liveData.rer) || liveData.rer > 1.5) {
                liveData.rer = 0;
            }
        }
        
        // Actualizar buffers para detección de umbrales
        vo2Buffer.push(liveData.vo2);
        vco2Buffer.push(liveData.vco2);
        
        // ISO 8996: Ecuación completa de Weir para el cálculo de calorías
        float vo2KCal = (WEIR_A * vo2Total / 1000.0) + (WEIR_B * vco2Total / 1000.0);  // kcal/min
        uint32_t elapsed = vo2CalcTimer.getElapsedTime();
        liveData.calories += vo2KCal * elapsed / 60000.0;
        liveData.caloriesPerHour = vo2KCal * 60.0;
        liveData.caloriesPerDay = vo2KCal * 1440.0;
    } else {
        // Cálculo simplificado sin CO2
        float vo2KCal = vo2Total / 1000.0 * 4.86;  // kcal/min (4.86 kcal/L O2)
        uint32_t elapsed = vo2CalcTimer.getElapsedTime();
        liveData.calories += vo2KCal * elapsed / 60000.0;
        liveData.caloriesPerHour = vo2KCal * 60.0;
        liveData.caloriesPerDay = vo2KCal * 1440.0;
    }
}

// Detección de umbrales ventilatorios (V-Slope) mejorada
void detectVentilatoryThresholds() {
    if (vo2Buffer.size() < MUESTRAS_VT || !settings.co2SensorEnabled) {
        return;
    }
    
    // Añadir datos a los buffers para métodos avanzados
    time_data.push(liveData.totalTimeMs);
    vo2_data.push(liveData.vo2);
    vco2_data.push(liveData.vco2);
    
    // Seleccionar método según configuración
    switch(settings.vo2Method) {
        case VO2_METHOD_WASSERMAN:
            calculateVO2Wasserman();
            break;
        case VO2_METHOD_BEAVER:
            calculateVO2Beaver();
            break;
        case VO2_METHOD_DICKHUTH:
            calculateVO2Dickhuth();
            break;
        case VO2_METHOD_VSLOPE:
        default:
            // Método V-Slope original
            // Calcular pendientes y normalizar por número de intervalos
            float vo2Slope = 0, vco2Slope = 0;
            for (size_t i = 1; i < MUESTRAS_VT; i++) {
                vo2Slope += vo2Buffer[i] - vo2Buffer[i-1];
                vco2Slope += vco2Buffer[i] - vco2Buffer[i-1];
            }
            
            // Normalizar pendientes para mayor precisión
            vo2Slope /= (MUESTRAS_VT - 1);
            vco2Slope /= (MUESTRAS_VT - 1);
            
            // Detectar VT1 (primer umbral ventilatorio)
            if (!liveData.vt1Detected && vco2Slope > vo2Slope * 1.1) {
                liveData.vt1Detected = true;
                liveData.vt1VO2 = liveData.vo2;
                liveData.vt1Time = liveData.totalTimeMs;
                
                if (DEBUG_ENABLED) {
                    Serial.println("VT1 detectado");
                    Serial.print("VO2 en VT1: "); Serial.println(liveData.vt1VO2);
                    Serial.print("Tiempo en VT1: "); Serial.println(formatTime(liveData.vt1Time));
                }
            }
            
            // Detectar VT2 (segundo umbral ventilatorio) - solo después de detectar VT1
            if (liveData.vt1Detected && !liveData.vt2Detected && vco2Slope > vo2Slope * 1.5) {
                liveData.vt2Detected = true;
                liveData.vt2VO2 = liveData.vo2;
                liveData.vt2Time = liveData.totalTimeMs;
                
                if (DEBUG_ENABLED) {
                    Serial.println("VT2 detectado");
                    Serial.print("VO2 en VT2: "); Serial.println(liveData.vt2VO2);
                    Serial.print("Tiempo en VT2: "); Serial.println(formatTime(liveData.vt2Time));
                }
            }
            break;
    }
}

// Método de Wasserman para cálculo de umbrales ventilatorios
void calculateVO2Wasserman() {
    if (vo2_data.size() < 3) return;
    
    int inflexionIndex = 0;
    bool foundInflexion = false;
    
    for (int i = 1; i < vo2_data.size() - 1; i++) {
        if (vo2_data[i] > vo2_data[i - 1] && vo2_data[i] > vo2_data[i + 1]) {
            inflexionIndex = i;
            foundInflexion = true;
            break;
        }
    }
    
    if (foundInflexion) {
        if (xSemaphoreTake(dataMutex, pdMS_TO_TICKS(100)) == pdTRUE) {
            if (!liveData.vt1Detected) {
                liveData.vt1Detected = true;
                liveData.vt1VO2 = vo2_data[inflexionIndex];
                liveData.vt1Time = time_data[inflexionIndex];
                
                if (DEBUG_ENABLED) {
                    Serial.println("VT1 detectado (Wasserman)");
                    Serial.print("VO2 en VT1: "); Serial.println(liveData.vt1VO2);
                    Serial.print("Tiempo en VT1: "); Serial.println(formatTime(liveData.vt1Time));
                }
            }
            
            if (!liveData.vt2Detected && vo2_data.size() > inflexionIndex + 3) {
                liveData.vt2Detected = true;
                liveData.vt2VO2 = vo2_data[inflexionIndex] * 1.3; // Aproximación típica para VT2
                liveData.vt2Time = time_data[vo2_data.size() - 1];
                
                if (DEBUG_ENABLED) {
                    Serial.println("VT2 detectado (Wasserman)");
                    Serial.print("VO2 en VT2: "); Serial.println(liveData.vt2VO2);
                    Serial.print("Tiempo en VT2: "); Serial.println(formatTime(liveData.vt2Time));
                }
            }
            
            xSemaphoreGive(dataMutex);
        }
    }
}

// Método de Beaver para cálculo de umbrales ventilatorios
void calculateVO2Beaver() {
    if (vo2_data.size() < 3) return;
    
    float maxDiff = 0;
    int thresholdIndex = 0;
    bool foundThreshold = false;
    
    for (int i = 1; i < vo2_data.size() - 1; i++) {
        float diff = (vco2_data[i + 1] - vco2_data[i - 1]) - (vo2_data[i + 1] - vo2_data[i - 1]);
        if (diff > maxDiff) {
            maxDiff = diff;
            thresholdIndex = i;
            foundThreshold = true;
        }
    }
    
    if (foundThreshold) {
        if (xSemaphoreTake(dataMutex, pdMS_TO_TICKS(100)) == pdTRUE) {
            if (!liveData.vt1Detected) {
                liveData.vt1Detected = true;
                liveData.vt1VO2 = vo2_data[thresholdIndex];
                liveData.vt1Time = time_data[thresholdIndex];
                
                if (DEBUG_ENABLED) {
                    Serial.println("VT1 detectado (Beaver)");
                    Serial.print("VO2 en VT1: "); Serial.println(liveData.vt1VO2);
                    Serial.print("Tiempo en VT1: "); Serial.println(formatTime(liveData.vt1Time));
                }
            }
            
            if (!liveData.vt2Detected && vo2_data.size() > thresholdIndex + 5) {
                // Buscar el segundo umbral después del primero
                float maxDiff2 = 0;
                int threshold2Index = 0;
                bool foundThreshold2 = false;
                
                for (int i = thresholdIndex + 2; i < vo2_data.size() - 1; i++) {
                    float diff = (vco2_data[i + 1] - vco2_data[i - 1]) - (vo2_data[i + 1] - vo2_data[i - 1]);
                    if (diff > maxDiff2) {
                        maxDiff2 = diff;
                        threshold2Index = i;
                        foundThreshold2 = true;
                    }
                }
                
                if (foundThreshold2) {
                    liveData.vt2Detected = true;
                    liveData.vt2VO2 = vo2_data[threshold2Index];
                    liveData.vt2Time = time_data[threshold2Index];
                    
                    if (DEBUG_ENABLED) {
                        Serial.println("VT2 detectado (Beaver)");
                        Serial.print("VO2 en VT2: "); Serial.println(liveData.vt2VO2);
                        Serial.print("Tiempo en VT2: "); Serial.println(formatTime(liveData.vt2Time));
                    }
                }
            }
            
            xSemaphoreGive(dataMutex);
        }
    }
}

// Método de Dickhuth para cálculo de umbrales ventilatorios
void calculateVO2Dickhuth() {
    if (vo2_data.size() < 5) return;
    
    float maxAcceleration = 0;
    int maxAccelIndex = 0;
    bool foundAccel = false;
    
    for (int i = 2; i < vo2_data.size() - 2; i++) {
        float accel = (vo2_data[i + 2] + vco2_data[i + 2] - 2 * vo2_data[i] - 2 * vco2_data[i] + 
                       vo2_data[i - 2] + vco2_data[i - 2]) / 5.0;
        if (accel > maxAcceleration) {
            maxAcceleration = accel;
            maxAccelIndex = i;
            foundAccel = true;
        }
    }
    
    if (foundAccel) {
        if (xSemaphoreTake(dataMutex, pdMS_TO_TICKS(100)) == pdTRUE) {
            if (!liveData.vt1Detected) {
                liveData.vt1Detected = true;
                liveData.vt1VO2 = vo2_data[maxAccelIndex];
                liveData.vt1Time = time_data[maxAccelIndex];
                
                if (DEBUG_ENABLED) {
                    Serial.println("VT1 detectado (Dickhuth)");
                    Serial.print("VO2 en VT1: "); Serial.println(liveData.vt1VO2);
                    Serial.print("Tiempo en VT1: "); Serial.println(formatTime(liveData.vt1Time));
                }
            }
            
            if (!liveData.vt2Detected && maxAccelIndex + 3 < vo2_data.size()) {
                // Detectar VT2 como el punto donde la aceleración cambia después de VT1
                float minChange = std::numeric_limits<float>::max();
                int vt2Index = maxAccelIndex;
                
                for (int i = maxAccelIndex + 1; i < vo2_data.size() - 2; i++) {
                    float accelChange = abs(1.0 - 
                                        ((vo2_data[i + 1] - vo2_data[i]) / 
                                         (vo2_data[i] - vo2_data[i - 1])));
                    if (accelChange < minChange) {
                        minChange = accelChange;
                        vt2Index = i;
                    }
                }
                
                liveData.vt2Detected = true;
                liveData.vt2VO2 = vo2_data[vt2Index];
                liveData.vt2Time = time_data[vt2Index];
                
                if (DEBUG_ENABLED) {
                    Serial.println("VT2 detectado (Dickhuth)");
                    Serial.print("VO2 en VT2: "); Serial.println(liveData.vt2VO2);
                    Serial.print("Tiempo en VT2: "); Serial.println(formatTime(liveData.vt2Time));
                }
            }
            
            xSemaphoreGive(dataMutex);
        }
    }
}

void readVoltage() {
    uint16_t adcValue = analogRead(ADC_PIN);
    liveData.batteryVoltage = ((float)adcValue / 4095.0) * 2.0 * 3.3 * (1100.0 / 1000.0);
}

void readAmbientConditions() {
    if (!demoMode) {
        float rawTemp = bmp.readTemperature();
        if (settings.useAdvancedFilters) {
            liveData.ambientTemp = filtroTemperatura.filtrar(rawTemp);
        } else {
            liveData.ambientTemp = rawTemp;
        }
        liveData.ambientPressure = bmp.readPressure();
    } else {
        liveData.ambientTemp = 25.0;
        liveData.ambientPressure = 101325.0;
    }
}

void updateTimers() {
    // Simple calculation - time since boot
    liveData.totalTimeMs = millis();
    
    // If using relative time from measurement start
    // liveData.totalTimeMs = millis() - startupTimer.lastTime;
}

// ===================== Funciones de UI =====================

void updateScreen() {
    if (screenChanged) {
        drawScreen();
        screenChanged = 0;
    }
}

void drawScreen() {
    tft.setRotation(1);
    switch (liveData.screenNumber) {
        case 1: drawScreen1(); break; // Mediciones principales
        case 2: drawScreen2(); break; // Datos respiratorios
        case 3: drawScreen3(); break; // Umbrales ventilatorios
        case 4: drawScreen4(); break; // Condiciones ambientales
        case 5: drawScreen5(); break; // Conectividad
        case 6: drawScreen6(); break; // Configuración
        case 7: drawScreen7(); break; // Normas ISO
        default: drawScreen1(); break;
    }
}

void drawScreen1() {
    tft.fillScreen(TFT_BLACK);
    tft.setTextColor(TFT_CYAN, TFT_BLACK);
    tft.drawCentreString("MEDICIONES", 120, 5, 2);
    
    tft.setTextColor(TFT_GREEN, TFT_BLACK);
    tft.setCursor(5, 30, 4);
    tft.print("VO2:");
    tft.setTextColor(TFT_WHITE, TFT_BLACK);
    tft.setCursor(80, 30, 4);
    tft.print(liveData.vo2, 1);
    tft.println(" ml/kg/min");
    
    tft.setTextColor(TFT_GREEN, TFT_BLACK);
    tft.setCursor(5, 55, 4);
    tft.print("VO2 Max:");
    tft.setTextColor(TFT_WHITE, TFT_BLACK);
    tft.setCursor(80, 55, 4);
    tft.print(liveData.vo2Max, 1);
    tft.println(" ml/kg/min");
    
    tft.setTextColor(TFT_GREEN, TFT_BLACK);
    tft.setCursor(5, 80, 4);
    tft.print("RQ:");
    tft.setTextColor(TFT_WHITE, TFT_BLACK);
    tft.setCursor(80, 80, 4);
    tft.println(liveData.rer, 2);
    
    tft.setTextColor(TFT_GREEN, TFT_BLACK);
    tft.setCursor(5, 105, 4);
    tft.print("Tiempo:");
    tft.setTextColor(TFT_RED, TFT_BLACK);
    tft.setCursor(80, 105, 4);
    tft.println(formatTime(liveData.totalTimeMs));
    
    drawBatteryIndicator();
}

void drawScreen2() {
    tft.fillScreen(TFT_BLACK);
    tft.setTextColor(TFT_CYAN, TFT_BLACK);
    tft.drawCentreString("RESPIRACION", 120, 5, 2);
    
    tft.setTextColor(TFT_GREEN, TFT_BLACK);
    tft.setCursor(5, 30, 4);
    tft.print("Vol. Exp:");
    tft.setTextColor(TFT_WHITE, TFT_BLACK);
    tft.setCursor(100, 30, 4);
    tft.print(liveData.volumeExp, 2);
    tft.println(" L");
    
    tft.setTextColor(TFT_GREEN, TFT_BLACK);
    tft.setCursor(5, 55, 4);
    tft.print("VE/min:");
    tft.setTextColor(TFT_WHITE, TFT_BLACK);
    tft.setCursor(100, 55, 4);
    tft.print(liveData.volumeVEMean, 1);
    tft.println(" L/min");
    
    tft.setTextColor(TFT_GREEN, TFT_BLACK);
    tft.setCursor(5, 80, 4);
    tft.print("Frec. Resp:");
    tft.setTextColor(TFT_WHITE, TFT_BLACK);
    tft.setCursor(100, 80, 4);
    tft.print(liveData.breathRateMean, 1);
    tft.println(" rpm");
    
    tft.setTextColor(TFT_GREEN, TFT_BLACK);
    tft.setCursor(5, 105, 4);
    tft.print("Tiempo:");
    tft.setTextColor(TFT_RED, TFT_BLACK);
    tft.setCursor(100, 105, 4);
    tft.println(formatTime(liveData.totalTimeMs));
    
    drawBatteryIndicator();
}

void drawScreen3() { // Reemplaza drawScreen6
    tft.fillScreen(TFT_BLACK);
    tft.setTextColor(TFT_CYAN, TFT_BLACK);
    tft.drawCentreString("UMBRALES", 120, 5, 2);
    
    tft.setTextColor(TFT_GREEN, TFT_BLACK);
    tft.setCursor(5, 30, 4);
    tft.print("VT1 VO2:");
    tft.setCursor(100, 30, 4);
    tft.setTextColor(liveData.vt1Detected ? TFT_WHITE : TFT_RED, TFT_BLACK);
    tft.println(liveData.vt1Detected ? String(liveData.vt1VO2, 1) : "N/A");
    
    tft.setTextColor(TFT_GREEN, TFT_BLACK);
    tft.setCursor(5, 55, 4);
    tft.print("VT1 Tiempo:");
    tft.setCursor(100, 55, 4);
    tft.setTextColor(liveData.vt1Detected ? TFT_WHITE : TFT_RED, TFT_BLACK);
    tft.println(liveData.vt1Detected ? formatTime(liveData.vt1Time) : "N/A");
    
    tft.setTextColor(TFT_GREEN, TFT_BLACK);
    tft.setCursor(5, 80, 4);
    tft.print("VT2 VO2:");
    tft.setCursor(100, 80, 4);
    tft.setTextColor(liveData.vt2Detected ? TFT_WHITE : TFT_RED, TFT_BLACK);
    tft.println(liveData.vt2Detected ? String(liveData.vt2VO2, 1) : "N/A");
    
    tft.setTextColor(TFT_GREEN, TFT_BLACK);
    tft.setCursor(5, 105, 4);
    tft.print("VT2 Tiempo:");
    tft.setCursor(100, 105, 4);
    tft.setTextColor(liveData.vt2Detected ? TFT_WHITE : TFT_RED, TFT_BLACK);
    tft.println(liveData.vt2Detected ? formatTime(liveData.vt2Time) : "N/A");
    
    drawBatteryIndicator();
}

void drawScreen4() {
    tft.fillScreen(TFT_BLACK);
    tft.setTextColor(TFT_CYAN, TFT_BLACK);
    tft.drawCentreString("AMBIENTE", 120, 5, 2);
    
    tft.setTextColor(TFT_GREEN, TFT_BLACK);
    tft.setCursor(5, 30, 4);
    tft.print("Temp:");
    tft.setTextColor(TFT_WHITE, TFT_BLACK);
    tft.setCursor(80, 30, 4);
    tft.print(liveData.ambientTemp, 1);
    tft.println(" °C");
    
    tft.setTextColor(TFT_GREEN, TFT_BLACK);
    tft.setCursor(5, 55, 4);
    tft.print("Presion:");
    tft.setTextColor(TFT_WHITE, TFT_BLACK);
    tft.setCursor(80, 55, 4);
    tft.print(liveData.ambientPressure / 100.0, 1);
    tft.println(" hPa");
    
    tft.setTextColor(TFT_GREEN, TFT_BLACK);
    tft.setCursor(5, 80, 4);
    tft.print("Humedad:");
    tft.setTextColor(TFT_WHITE, TFT_BLACK);
    tft.setCursor(80, 80, 4);
    tft.print(liveData.humidity, 1);
    tft.println(" %");
    
    tft.setTextColor(TFT_GREEN, TFT_BLACK);
    tft.setCursor(5, 105, 4);
    tft.print("Densidad:");
    tft.setTextColor(TFT_WHITE, TFT_BLACK);
    tft.setCursor(80, 105, 4);
    tft.print(liveData.airDensity, 3);
    tft.println(" kg/m³");
    
    drawBatteryIndicator();
}

void drawScreen5() { // Reemplaza drawScreen8
    tft.fillScreen(TFT_BLACK);
    tft.setTextColor(TFT_CYAN, TFT_BLACK);
    tft.drawCentreString("CONECTIVIDAD", 120, 5, 2);
    
    tft.setTextColor(TFT_GREEN, TFT_BLACK);
    tft.setCursor(5, 30, 4);
    tft.print("WiFi:");
    tft.setCursor(80, 30, 4);
    tft.setTextColor(wifiActive ? TFT_GREEN : TFT_RED, TFT_BLACK);
    tft.println(wifiActive ? "ON" : "OFF");
    
    tft.setTextColor(TFT_GREEN, TFT_BLACK);
    tft.setCursor(5, 55, 4);
    tft.print("IP:");
    tft.setTextColor(TFT_WHITE, TFT_BLACK);
    tft.setCursor(80, 55, 4);
    tft.println(WiFi.softAPIP().toString());
    
    tft.setTextColor(TFT_GREEN, TFT_BLACK);
    tft.print("Bluetooth:");
    tft.setCursor(80, 80, 4);
    tft.setTextColor(bleClientConnected ? TFT_GREEN : TFT_RED, TFT_BLACK);
    tft.println(bleClientConnected ? "ON" : "OFF");
    
    tft.setTextColor(TFT_GREEN, TFT_BLACK);
    tft.setCursor(5, 105, 4);
    tft.print("Transm.:");
    tft.setCursor(80, 105, 4);
    tft.setTextColor(liveData.dataTransmissionEnabled ? TFT_GREEN : TFT_RED, TFT_BLACK);
    tft.println(liveData.dataTransmissionEnabled ? "ON" : "OFF");
    
    drawBatteryIndicator();
}

// Nueva pantalla para visualizar umbrales ventilatorios
void drawScreen6() { // Reemplaza drawParametersScreen
    tft.fillScreen(TFT_BLUE);
    tft.setTextColor(TFT_WHITE, TFT_BLUE);
    tft.drawCentreString("CONFIGURACION", 120, 5, 2);
    
    tft.setCursor(5, 30, 4);
    tft.print("Peso:");
    tft.setCursor(80, 30, 4);
    tft.println(settings.weightKg, 1);
    
    tft.setCursor(5, 55, 4);
    tft.print("Corr.:");
    tft.setCursor(80, 55, 4);
    tft.println(settings.correctionSensor, 2);
    
    tft.setCursor(5, 80, 4);
    tft.print("Metodo VO2:");
    tft.setCursor(80, 80, 4);
    switch(settings.vo2Method) {
        case VO2_METHOD_VSLOPE: tft.println("V-Slope"); break;
        case VO2_METHOD_WASSERMAN: tft.println("Wasserman"); break;
        case VO2_METHOD_BEAVER: tft.println("Beaver"); break;
    }
}

void drawScreen7() { // Reemplaza showISOScreen como pantalla navegable
    tft.fillScreen(TFT_BLACK);
    tft.setTextColor(TFT_CYAN, TFT_BLACK);
    tft.drawCentreString("NORMAS ISO", 120, 5, 2);
    
    tft.setTextColor(TFT_WHITE, TFT_BLACK);
    tft.drawCentreString("ISO 26782:2009 - Flujo", 120, 30, 2);
    tft.drawCentreString("ISO 2533:2020 - STPD", 120, 50, 2);
    tft.drawCentreString("ISO 5167-1:2003 - Presion", 120, 70, 2);
    tft.drawCentreString("ISO 80601-2-61:2017 - Gases", 120, 90, 2);
    
    tft.setTextColor(TFT_YELLOW, TFT_BLACK);
    tft.drawCentreString("VO2Smart " + String(DEVICE_VERSION), 120, 120, 2);
    drawBatteryIndicator();
}

void drawParametersScreen() {
    tft.fillScreen(TFT_BLUE);
    tft.setTextColor(TFT_WHITE, TFT_BLUE);
    tft.drawCentreString("CONFIGURACION", 120, 5, 2);
    
    tft.setCursor(5, 30, 4);
    tft.print("Peso:");
    tft.setCursor(80, 30, 4);
    tft.println(settings.weightKg, 1);
    
    tft.setCursor(5, 55, 4);
    tft.print("Corr.:");
    tft.setCursor(80, 55, 4);
    tft.println(settings.correctionSensor, 2);
    
    tft.setCursor(5, 80, 4);
    tft.print("Metodo VO2:");
    tft.setCursor(80, 80, 4);
    switch(settings.vo2Method) {
        case VO2_METHOD_VSLOPE: tft.println("V-Slope"); break;
        case VO2_METHOD_WASSERMAN: tft.println("Wasserman"); break;
        case VO2_METHOD_BEAVER: tft.println("Beaver"); break;
    }
}

void handleButtonActions() {
    // Reiniciar dispositivo si ambos botones se mantienen presionados
    if (buttonPushCounter1 > 20 && buttonPushCounter2 > 20) {
        setWeight(); // Cambiar peso en lugar de reiniciar directamente
        screenChanged = 1;
        return;
    }
    
    // Navegación entre pantallas
    if (buttonPushCounter1 == 2) { // Botón 1: Retrocede
        liveData.screenNumber--;
        screenChanged = 1;
    }
    
    if (buttonPushCounter2 == 2) { // Botón 2: Avanza
        liveData.screenNumber++;
        screenChanged = 1;
    }
    
    // Acciones especiales
    if (buttonPushCounter1 >= 5 && buttonPushCounter1 < 15) {
        toggleDataTransmission();
        screenChanged = 1;
    }
    
    if (buttonPushCounter2 >= 5 && buttonPushCounter2 < 15) {
        toggleVO2Method();
        screenChanged = 1;
    }
    
    // Mantener pantalla en rango válido
    if (liveData.screenNumber < 1) liveData.screenNumber = 7;
    if (liveData.screenNumber > 7) liveData.screenNumber = 1;
}

void showISOScreen() {
    tft.fillScreen(TFT_BLACK);
    tft.setTextColor(TFT_CYAN, TFT_BLACK);
    tft.drawCentreString("NORMAS ISO", 120, 5, 2);
    
    tft.setTextColor(TFT_WHITE, TFT_BLACK);
    tft.drawCentreString("ISO 26782:2009 - Flujo", 120, 30, 2);
    tft.drawCentreString("ISO 2533:2020 - STPD", 120, 50, 2);
    tft.drawCentreString("ISO 5167-1:2003 - Presion", 120, 70, 2);
    tft.drawCentreString("ISO 80601-2-61:2017 - Gases", 120, 90, 2);
    
    tft.setTextColor(TFT_YELLOW, TFT_BLACK);
    tft.drawCentreString("VO2Smart " + String(DEVICE_VERSION), 120, 120, 2);
}

void showDemoSelectionScreen() {
    tft.fillScreen(TFT_BLACK);
    tft.setTextColor(TFT_WHITE, TFT_BLACK);
    tft.drawCentreString("Seleccionar Modo", 120, 40, 2);
    tft.drawCentreString("1. Normal", 120, 70, 2);
    tft.drawCentreString("2. Demo", 120, 100, 2);
    
    uint32_t startTime = millis();
    while (millis() - startTime < 5000) {
        if (!digitalRead(BUTTON_PIN1)) {
            demoMode = false;
            break;
        }
        if (!digitalRead(BUTTON_PIN2)) {
            demoMode = true;
            break;
        }
        delay(100);
    }
    
    tft.fillScreen(TFT_BLACK);
}

void readButtons() {
    int reading1 = digitalRead(BUTTON_PIN1);
    int reading2 = digitalRead(BUTTON_PIN2);
    
    if (reading1 != buttonState1) {
        if (reading1 == LOW) {
            buttonPushCounter1++;
        } else {
            buttonPushCounter1 = 0;
        }
        buttonState1 = reading1;
    }
    
    if (reading2 != buttonState2) {
        if (reading2 == LOW) {
            buttonPushCounter2++;
        } else {
            buttonPushCounter2 = 0;
        }
        buttonState2 = reading2;
    }
}

void updateBacklight() {
    // For TTGO T-Display, backlight control using ledcWrite
    // Create these constants at the top with other #defines
    #define BACKLIGHT_CHANNEL 0
    #define BACKLIGHT_PIN 4 // Typical backlight pin for TTGO T-Display
    
    static bool backlightInitialized = false;
    
    if (!backlightInitialized) {
        ledcSetup(BACKLIGHT_CHANNEL, 5000, 8); // 5KHz, 8-bit resolution
        ledcAttachPin(BACKLIGHT_PIN, BACKLIGHT_CHANNEL);
        backlightInitialized = true;
    }
    
    uint8_t level = 255; // Full brightness by default
    
    if (liveData.batteryVoltage < 3.5) {
        // Reduce brightness to save battery
        level = 128; // 50% brightness
    } else {
        // Normal brightness
        level = 204; // 80% brightness
    }
    
    ledcWrite(BACKLIGHT_CHANNEL, level);
}

void drawBatteryIndicator() {
    tft.setTextColor(TFT_GREEN, TFT_BLACK);
    tft.setCursor(5, 130, 4);
    tft.print("Bateria:");
    tft.setTextColor(TFT_WHITE, TFT_BLACK);
    tft.setCursor(80, 130, 4);
    tft.print(liveData.batteryVoltage, 2);
    tft.println(" V");
}
// ===================== Funciones de calibración =====================

// Function to display error messages on the TFT screen
void showError(const char* message) {
    tft.fillScreen(TFT_RED);
    tft.setTextColor(TFT_WHITE, TFT_RED);
    tft.drawCentreString(message, 120, 55, 4);
    delay(3000);
}

bool checkEnvironmentalStability() {
    // Check if environmental conditions are stable
    static float lastTemp = liveData.ambientTemp;
    static float lastPressure = liveData.ambientPressure;
    static float lastHumidity = liveData.humidity;

    float tempDiff = abs(liveData.ambientTemp - lastTemp);
    float pressureDiff = abs(liveData.ambientPressure - lastPressure);
    float humidityDiff = abs(liveData.humidity - lastHumidity);

    lastTemp = liveData.ambientTemp;
    lastPressure = liveData.ambientPressure;
    lastHumidity = liveData.humidity;

    // Define thresholds for stability
    const float TEMP_THRESHOLD = 0.5; // °C
    const float PRESSURE_THRESHOLD = 100.0; // Pa
    const float HUMIDITY_THRESHOLD = 2.0; // %

    return (tempDiff < TEMP_THRESHOLD && pressureDiff < PRESSURE_THRESHOLD && humidityDiff < HUMIDITY_THRESHOLD);
}
// ===================== Funciones de calibración =====================

void calibrateO2Sensor() {
    // Calibrar sensor de oxígeno
    tft.fillScreen(TFT_BLACK);
    tft.setTextColor(TFT_WHITE, TFT_BLACK);
    tft.drawCentreString("Calibrando O2...", 120, 55, 4);
    
    float o2Sum = 0;
    for (int i = 0; i < 10; i++) {
        o2Sum += oxygenSensor.ReadOxygenData(OXYGEN_COLLECT_NUMBER);
        delay(100);
    }
    
    float o2Mean = o2Sum / 10.0;
    settings.correctionSensor = FI02 / o2Mean;
    saveSettings();
    
    tft.fillScreen(TFT_BLACK);
    tft.setTextColor(TFT_GREEN, TFT_BLACK);
    tft.drawCentreString("Calibracion O2 OK", 120, 55, 4);
    delay(2000);
}

void calibrateFlowSensor() {
    // Calibrar sensor de flujo
    tft.fillScreen(TFT_BLACK);
    tft.setTextColor(TFT_WHITE, TFT_BLACK);
    tft.drawCentreString("Calibrando Flujo...", 120, 55, 4);
    
    float flowSum = 0;
    for (int i = 0; i < 10; i++) {
        flowSum += pressureSensor.getPressure();
        delay(100);
    }
    
    float flowMean = flowSum / 10.0;
    settings.correctionSensor = 1.0 / flowMean;
    saveSettings();
    
    tft.fillScreen(TFT_BLACK);
    tft.setTextColor(TFT_GREEN, TFT_BLACK);
    tft.drawCentreString("Calibracion Flujo OK", 120, 55, 4);
    delay(2000);
}

void calibrateCO2Sensor() {
    // Calibrar sensor de CO2
    tft.fillScreen(TFT_BLACK);
    tft.setTextColor(TFT_WHITE, TFT_BLACK);
    tft.drawCentreString("Calibrando CO2...", 120, 55, 4);
    
    float co2Sum = 0;
    for (int i = 0; i < 10; i++) {
        float result[3] = {0};
        scd30.getCarbonDioxideConcentration(result);
        co2Sum += result[0];
        delay(100);
    }
    
    float co2Mean = co2Sum / 10.0;
    settings.correctionSensor = FICO2 / co2Mean;
    saveSettings();
    
    tft.fillScreen(TFT_BLACK);
    tft.setTextColor(TFT_GREEN, TFT_BLACK);
    tft.drawCentreString("Calibracion CO2 OK", 120, 55, 4);
    delay(2000);
}

void setWeight() {
    // Configurar peso del usuario
    tft.fillScreen(TFT_BLACK);
    tft.setTextColor(TFT_WHITE, TFT_BLACK);
    tft.drawCentreString("Configurar Peso", 120, 40, 2);
    tft.drawCentreString("Peso actual: " + String(settings.weightKg) + " kg", 120, 70, 2);
    tft.drawCentreString("Usar botones para ajustar", 120, 100, 2);
    
    while (true) {
        readButtons();
        
        if (buttonPushCounter1 == 2) {
            settings.weightKg -= 0.5;
            if (settings.weightKg < 30.0) settings.weightKg = 30.0;
            tft.fillScreen(TFT_BLACK);
            tft.drawCentreString("Configurar Peso", 120, 40, 2);
            tft.drawCentreString("Peso actual: " + String(settings.weightKg) + " kg", 120, 70, 2);
            tft.drawCentreString("Usar botones para ajustar", 120, 100, 2);
        }
        
        if (buttonPushCounter2 == 2) {
            settings.weightKg += 0.5;
            if (settings.weightKg > 150.0) settings.weightKg = 150.0;
            tft.fillScreen(TFT_BLACK);
            tft.drawCentreString("Configurar Peso", 120, 40, 2);
            tft.drawCentreString("Peso actual: " + String(settings.weightKg) + " kg", 120, 70, 2);
            tft.drawCentreString("Usar botones para ajustar", 120, 100, 2);
        }
        
        if (buttonPushCounter1 > 20 && buttonPushCounter2 > 20) {
            saveSettings();
            tft.fillScreen(TFT_BLACK);
            tft.setTextColor(TFT_GREEN, TFT_BLACK);
            tft.drawCentreString("Peso Configurado", 120, 55, 4);
            delay(2000);
            break;
        }
        
        delay(100);
    }
}

bool performSyringeCalibration() {
    float totalVolume = 0;
    uint32_t startTime = millis();
    bool stableEnvironment = checkCalibrationConditions();
    
    uint32_t lastMeasure = millis(); // Declare and initialize lastMeasure
    while((millis() - startTime) < CALIB_TIMEOUT_MS) {
        // Medir flujo integrado
        float readFilteredFlow() {
            float rawPressure = pressureSensor.getPressure();
            if (!isnan(rawPressure)) {
                if (settings.useAdvancedFilters) {
                    return filtroPresion.filtrar(rawPressure);
                } else {
                    return rawPressure;
                }
            }
            return 0.0; // Return 0 if the pressure reading is invalid
        }
        float flow = readFilteredFlow();
        totalVolume += flow * (millis() - lastMeasure) / 1000.0;
        lastMeasure = millis();
        
        // Actualizar UI
        float progress = constrain(totalVolume / SYRINGE_VOLUME, 0, 1);
        drawSyringeCalibrationScreen(totalVolume, progress);
        
        // Verificar estabilidad ambiental durante calibración
        if(!checkEnvironmentalStability()) {
            showError("Condiciones inestables!");
            logCalibration(false, totalVolume);
            return false;
        }
        
        if(totalVolume >= SYRINGE_VOLUME) break;
    }

    // Validación ISO
    float error = fabs((totalVolume - SYRINGE_VOLUME)/SYRINGE_VOLUME)*100;
    bool passed = (error <= CALIB_ALLOWED_ERROR) && stableEnvironment;
    
    if(passed) {
        settings.flowCalibFactor = SYRINGE_VOLUME / totalVolume;
        saveSettings();
    }
    
    logCalibration(passed, totalVolume, error);
    showCalibrationResult(passed, error);
    return passed;
}

void drawSyringeCalibrationScreen(float volInyectado, float progress) {
    tft.fillScreen(TFT_BLACK);
    tft.setTextColor(TFT_CYAN, TFT_BLACK);
    tft.drawCentreString("CALIBRACION JERINGA", 120, 10, 2);
    
    // Barra de progreso
    tft.drawRect(20, 40, 200, 30, TFT_WHITE);
    tft.fillRect(22, 42, (int)(196*progress), 26, TFT_GREEN);
    
    // Valores numéricos
    tft.setTextColor(TFT_WHITE, TFT_BLACK);
    tft.setCursor(20, 80);
    tft.printf("Vol. Inyectado: %.1f mL", volInyectado);
    tft.setCursor(20, 100);
    tft.printf("Objetivo: 3000 mL ±%.0f%%", CALIB_ALLOWED_ERROR);
    
    // Indicador ISO
    tft.setTextColor(TFT_YELLOW, TFT_BLACK);
    tft.drawCentreString("Cumple ISO 26782:2023", 120, 130, 2);
}

bool checkCalibrationConditions() {
    return (
        checkEnvironmentalStability() && 
        (liveData.ambientPressure > 95000) && 
        (liveData.ambientTemp >= 20 && liveData.ambientTemp <= 25)
    );
}

void showCalibrationResult(bool passed, float error) {
    tft.fillScreen(passed ? TFT_DARKGREEN : TFT_RED);
    tft.setTextColor(TFT_WHITE);
    tft.drawCentreString(passed ? "CALIBRACION EXITOSA" : "FALLA CALIBRACION", 120, 40, 2);
    tft.drawCentreString(String(error,1) + "% Error", 120, 70, 2);
    tft.drawCentreString("ISO 80601-2-61:2017", 120, 100, 2);
    delay(3000);
}

// ===================== Funciones de datos =====================

void logData() {
    if (DEBUG_ENABLED) {
        Serial.print("VO2: "); Serial.print(liveData.vo2, 1);
        Serial.print(" ml/kg/min, VO2 Max: "); Serial.print(liveData.vo2Max, 1);
        Serial.print(" ml/kg/min, RQ: "); Serial.print(liveData.rer, 2);
        Serial.print(", Tiempo: "); Serial.println(formatTime(liveData.totalTimeMs));
    }
}

String formatTime(uint32_t timeMs) {
    uint32_t seconds = timeMs / 1000;
    uint32_t minutes = seconds / 60;
    seconds = seconds % 60;
    return String(minutes) + ":" + (seconds < 10 ? "0" : "") + String(seconds);
}

float convertToSTPD(float volume, float temperature, float pressure) {
    return volume * (PRESION_STPD / pressure) * ((temperature + 273.15) / TEMP_STPD);
}

void safetyChecks() {
    // Verificar condiciones de seguridad
    if (liveData.batteryVoltage < 3.0) {
        tft.fillScreen(TFT_RED);
        tft.setTextColor(TFT_WHITE, TFT_RED);
        tft.drawCentreString("Bateria Baja!", 120, 55, 4);
        delay(5000);
        ESP.restart();
    }
}

// ===================== Funciones ISO =====================

float calculatePH2O(float temperature) {
    return 6.1078 * pow(10, (7.5 * temperature) / (237.3 + temperature));
}

float termISO26782(float temperature, float pressure) {
    return (pressure - calculatePH2O(temperature)) / (PRESION_STPD - calculatePH2O(0));
}

void logCalibration(float value, float refValue, float error = 0.0) {
    if (DEBUG_ENABLED) {
        Serial.print("Valor: "); Serial.print(value);
        Serial.print(", Valor de referencia: "); Serial.print(refValue);
        Serial.print(", Error: "); Serial.println(error);
    }
}

bool testThermalStability(float temperature, float threshold) {
    static float lastTemp = temperature;
    float tempDiff = abs(temperature - lastTemp);
    lastTemp = temperature;
    return tempDiff < threshold;
}

bool autoCalibrate(float measured, float expected, float tolerance) {
    float diff = abs(measured - expected);
    return diff / expected <= tolerance;
}

// ===================== Funciones de Web Server =====================

void setupWiFi() {
    WiFi.softAP(ssid, password);
    delay(100);
    if (WiFi.softAPIP()) {
        wifiActive = true;
        if (DEBUG_ENABLED) {
            Serial.print("IP Address: ");
            Serial.println(WiFi.softAPIP());
        }
    }
    
    server.on("/", handleRoot);
    server.on("/data", handleData);
    server.onNotFound(handleNotFound);
    server.begin();
    webServerActive = true;
}

void handleRoot() {
    server.send(200, "text/html", htmlPage);
}

void handleData() {
    String jsonData = "{";
    jsonData += "\"vo2Max\":" + String(liveData.vo2Max, 1) + ",";
    jsonData += "\"rq\":" + String(liveData.rer, 2) + ",";
    jsonData += "\"vt1\":" + String(liveData.vt1VO2, 1) + ",";
    jsonData += "\"vt2\":" + String(liveData.vt2VO2, 1) + ",";
    jsonData += "\"time\":\"" + formatTime(liveData.totalTimeMs) + "\"";
    jsonData += "}";
    server.send(200, "application/json", jsonData);
}

void handleNotFound() {
    server.send(404, "text/plain", "Not Found");
}

void saveDataRecord() {
    DataRecord record;
    record.timestamp = millis();
    record.vo2 = liveData.vo2;
    record.vco2 = liveData.vco2;
    record.rer = liveData.rer;
    record.volumeVE = liveData.volumeVEMean;
    record.o2Percent = liveData.o2Percent;
    record.co2Ppm = liveData.co2Ppm;
    record.breathRate = liveData.breathRateMean;
    record.calories = liveData.calories;
    record.vt1Detected = liveData.vt1Detected;
    record.vt2Detected = liveData.vt2Detected;
    record.vt1VO2 = liveData.vt1VO2;
    record.vt2VO2 = liveData.vt2VO2;
    
    dataBuffer.push(record);
}

bool transmitData(const String& dataString, uint8_t retries) {
    for (uint8_t i = 0; i < retries; i++) {
        if (SerialBT.available()) {
            SerialBT.println(dataString);
            return true;
        }
        delay(100);
    }
    return false;
}

String formatDataRecord(const DataRecord& record) {
    String dataString = String(record.timestamp) + ",";
    dataString += String(record.vo2, 1) + ",";
    dataString += String(record.vco2, 1) + ",";
    dataString += String(record.rer, 2) + ",";
    dataString += String(record.volumeVE, 1) + ",";
    dataString += String(record.o2Percent, 1) + ",";
    dataString += String(record.co2Ppm, 1) + ",";
    dataString += String(record.breathRate, 1) + ",";
    dataString += String(record.calories, 1) + ",";
    dataString += String(record.vt1Detected) + ",";
    dataString += String(record.vt2Detected) + ",";
    dataString += String(record.vt1VO2, 1) + ",";
    dataString += String(record.vt2VO2, 1);
    return dataString;
}

void flushDataBuffer() {
    while (!dataBuffer.isEmpty()) {
        DataRecord record = dataBuffer.shift();
        String dataString = formatDataRecord(record);
        if (!transmitData(dataString, MAX_RETRIES)) {
            dataBuffer.push(record);
            break;
        }
    }
}

void toggleDataTransmission() {
    liveData.dataTransmissionEnabled = !liveData.dataTransmissionEnabled;
}

void toggleVO2Method() {
    settings.vo2Method = (settings.vo2Method + 1) % 3;
    saveSettings();
}

// Add these functions to your code:

void checkInitialO2() {
    if (DEBUG_ENABLED) {
        Serial.println("Leyendo valor inicial de O2...");
    }
    
    float o2Sum = 0.0;
    int validReadings = 0;
    
    for (int i = 0; i < 10; i++) {
        float reading = oxygenSensor.ReadOxygenData(OXYGEN_COLLECT_NUMBER);
        if (!isnan(reading) && reading > 15.0 && reading < 25.0) {
            o2Sum += reading;
            validReadings++;
        }
        delay(100);
    }
    
    if (validReadings > 0) {
        liveData.initialO2 = o2Sum / validReadings;
        if (DEBUG_ENABLED) {
            Serial.print("Valor inicial de O2: ");
            Serial.println(liveData.initialO2);
        }
    } else {
        liveData.initialO2 = 20.9; // Default value if readings fail
        if (DEBUG_ENABLED) {
            Serial.println("Error leyendo O2 inicial, usando valor por defecto");
        }
    }
    
    // Reset O2 filter with initial value
    filtroO2.reset(liveData.initialO2, 0.5);
}

void checkInitialCO2() {
    if (DEBUG_ENABLED) {
        Serial.println("Leyendo valor inicial de CO2...");
    }
    
    float co2Sum = 0.0;
    int validReadings = 0;
    
    // Only try to read if CO2 sensor is enabled
    if (settings.co2SensorEnabled) {
        for (int i = 0; i < 10; i++) {
            if (scd30.isAvailable()) {
                float result[3] = {0};
                scd30.getCarbonDioxideConcentration(result);
                
                if (!isnan(result[0]) && result[0] > 300.0 && result[0] < 1000.0) {
                    co2Sum += result[0];
                    validReadings++;
                }
            }
            delay(100);
        }
        
        if (validReadings > 0) {
            liveData.initialCO2 = co2Sum / validReadings;
            if (DEBUG_ENABLED) {
                Serial.print("Valor inicial de CO2: ");
                Serial.println(liveData.initialCO2);
            }
        } else {
            liveData.initialCO2 = 400.0; // Default value if readings fail
            if (DEBUG_ENABLED) {
                Serial.println("Error leyendo CO2 inicial, usando valor por defecto");
            }
        }
        
        // Reset CO2 filter with initial value
        filtroCO2.reset(liveData.initialCO2 / 10000.0, 0.9);
    } else {
        liveData.initialCO2 = 400.0; // Default when sensor is disabled
        if (DEBUG_ENABLED) {
            Serial.println("Sensor CO2 deshabilitado, usando valor por defecto");
        }
    }
}
hay errores