// VO2Smart // Claudio Abarca // Patente 2024024875
// Proyecto VO2Max ESP32 Integrado - Versión Optimizada 3.0
// Fecha: 2 de abril de 2025
// Optimizado por Csav20
//Vo2 curvo venturi redodndo

// TTGO T-Display: SDA-Pin21, SCL-Pin22
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//Dimensiones de la Screen de la TTGO T DISPLAY 240X135 PIXELES

// Set this to the correct printed case venturi diameter
#define DIAMETER 20

#define VERBOSE // additional debug logging

#include <Arduino.h>
#include "esp_adc_cal.h" // ADC calibration data
#include <EEPROM.h>      // include library to read and write settings from flash
#include <freertos/FreeRTOS.h>
#include <freertos/semphr.h>
#include <freertos/task.h>
#include <string.h>      // for memset
#include <math.h>        // for isnan, isinf, sin, etc.
#define ADC_EN 14        // ADC_EN is the ADC detection enable port
#define ADC_PIN 34
int vref = 1100;

// Mutex declarations for thread safety
SemaphoreHandle_t sensorDataMutex = NULL;
SemaphoreHandle_t settingsMutex = NULL;
SemaphoreHandle_t errorLogMutex = NULL;
SemaphoreHandle_t calculationMutex = NULL;

#include "DFRobot_OxygenSensor.h" //Library for Oxygen sensor
#include "SCD30.h"                //Library for CO2 sensor
#include "Omron_D6FPH.h"          //Library for differential pressure sensor
#include <SPI.h>
#include <TFT_eSPI.h> // Graphics and font library for ST7735 driver chip
#include <Wire.h>
#include "Adafruit_BMP280.h" // Library for BMP280 ambient temp and pressure, set correct I2C address 0x76

// BLE includes
#include <BLEDevice.h>
#include <BLEServer.h>
#include <BLEUtils.h>
#include <BLE2902.h>

// Forward declarations (prototipos) de funciones
void ConvertTime(float ms);
void drawBatteryIndicator();
void ReadButtons();
void showMainMenu();
void StreamBT();
void VolumeCalc();
void showScreen();
void saveSettings();
void readCO2();
void showParameters();
void tftScreen1();
void tftScreen2();
void tftScreen3();
void tftScreen4();
void tftScreen5();
void tftParameters();
void loadSettings();
void showSplashScreen();
void showError(const char* message, bool critical);
void setupBLE();
void CheckInitialO2();
void CheckInitialCO2();
void fnCalO2();
bool performSyringeCalibration();
void GetWeightkg();
void generateDemoData();
void drawDemoScreen(int screenNum);
void vo2maxCalc();
void AirDensity();
void BatteryBT();
void ExcelStream();
void readVoltage();
bool checkCalibrationConditions();
bool checkEnvironmentalStability();
void showCalibrationResult(bool passed, float error);
void drawSyringeCalibrationScreen(float volInyectado, float progress);
void logCalibration(float measuredVolume, float targetVolume);
void ReadO2();
void showCalibrationMenu(); // Add forward declaration for showCalibrationMenu
void showCarouselMenu(); // Forward declaration for showCarouselMenu
void manualCalibrateWithSyringe(); // Forward declaration for manualCalibrateWithSyringe
void autoCalibrate(); // Forward declaration for autoCalibrate
bool validateReadings(); // Forward declaration for validateReadings
void checkAdvertising(); // Forward declaration for checkAdvertising
void handleBLEConnection(); // Forward declaration for handleBLEConnection
void showBLEStatus(); // Forward declaration for showBLEStatus
void runVO2Mode(); // Forward declaration for runVO2Mode
void loop();
void setup();

// Nuevas funciones para validación de datos y manejo centralizado de errores
bool validateSensorData(float value, float min, float max, const char* sensorName);
void logSensorError(const char* sensorName, float value, const char* reason);
bool isValidO2Reading(float o2Value);
bool isValidCO2Reading(float co2Value);
bool isValidPressureReading(float pressure);
bool isValidTemperatureReading(float temperature);
void initializeErrorLogging();
uint32_t calculateEEPROMChecksum(void* data, size_t size);
bool verifyEEPROMIntegrity();
void saveSettingsWithChecksum();
bool loadSettingsWithChecksum();

// Función de diagnóstico del sistema mejorado
void runSystemDiagnostics();

// ============================================================================
// CLASES DE FILTROS OPTIMIZADAS PARA PROCESAMIENTO EN TIEMPO REAL
// ============================================================================

/**
 * Filtro de Kalman optimizado para datos de sensores
 * Implementa el algoritmo discreto de Kalman con predicción y corrección
 * Optimizado para operaciones de punto flotante del ESP32
 */
class FiltroKalman {
public:
    /**
     * Constructor del filtro de Kalman
     * @param _q Ruido del proceso (menor = más suave, mayor = más responsivo)
     * @param _r Ruido de medición (menor = más confianza en mediciones)
     */
    FiltroKalman(float _q = 0.1, float _r = 0.1) : q(_q), r(_r), x(0), p(1) {}

    /**
     * Procesa una nueva medición con el filtro de Kalman
     * @param medida Nueva medición del sensor
     * @return Valor filtrado estimado
     */
    inline float filtrar(float medida) {
        // Paso de predicción: proyectar estado hacia adelante
        float p_pred = p + q;

        // Paso de corrección: calcular ganancia de Kalman
        float k = p_pred / (p_pred + r);
        
        // Actualizar estimación y covarianza
        x += k * (medida - x);
        p = (1.0f - k) * p_pred;

        return x;
    }
    
    /**
     * Ajusta dinámicamente los parámetros del filtro
     * Útil para adaptar el filtro a diferentes condiciones de operación
     */
    inline void ajustarParametros(float nuevo_q, float nuevo_r) {
        q = nuevo_q;
        r = nuevo_r;
    }
    
    /**
     * Reinicia el filtro con un nuevo valor inicial
     */
    inline void reiniciar(float valor_inicial = 0) {
        x = valor_inicial;
        p = 1.0f;
    }

private:
    float q; // Varianza del ruido del proceso
    float r; // Varianza del ruido de medición
    float x; // Estado estimado actual
    float p; // Covarianza del error de estimación
};

/**
 * Filtro de Kalman con inicialización personalizada
 * Especializado para sensores que requieren valores iniciales específicos
 */
class FiltroKalmanGauss {
public:
    FiltroKalmanGauss(float _valorInicial = 0, float _q = 0.1) 
        : valorEstimado(_valorInicial), p(1), q(_q), r(0.1) {}
    
    inline float filtrar(float medida) {
        float p_temp = p + q;
        float k = p_temp / (p_temp + r);
        valorEstimado += k * (medida - valorEstimado);
        p = (1.0f - k) * p_temp;
        return valorEstimado;
    }

private:
    float valorEstimado;
    float p, q, r;
};

/**
 * Filtro de Kalman unificado con interfaz consistente
 * Versión optimizada que combina las mejores características
 */
class KalmanFilter {
public:
    KalmanFilter(float q = 0.01, float r = 0.1, float initial = 0.0)
        : q(q), r(r), x(initial), p(1.0) {}
        
    inline float filtrar(float measurement) {
        // Algoritmo optimizado de Kalman en una sola pasada
        float p_temp = p + q;
        float k = p_temp / (p_temp + r);
        x += k * (measurement - x);
        p = (1.0f - k) * p_temp;
        return x;
    }
    
private:
    float q, r, x, p;
};

/**
 * Filtro de promedio móvil exponencial optimizado
 * Más eficiente que Kalman para aplicaciones simples de suavizado
 * Inspirado en distribución Maxwell-Boltzmann pero simplificado
 */
class MaxwellBoltzmannFilter {
public:
    MaxwellBoltzmannFilter(float _alpha = 0.1) : alpha(_alpha), lastValue(0) {}
    
    /**
     * Filtro exponencial simple: y[n] = α*x[n] + (1-α)*y[n-1]
     * @param value Nueva medición
     * @return Valor filtrado
     */
    inline float filtrar(float value) {
        lastValue += alpha * (value - lastValue); // Forma optimizada
        return lastValue;
    }
    
    /**
     * Ajusta la respuesta del filtro dinámicamente
     * @param nuevo_alpha Factor de suavizado (0-1)
     */
    inline void ajustarAlpha(float nuevo_alpha) {
        alpha = constrain(nuevo_alpha, 0.001f, 0.999f);
    }

private:
    float alpha;
    float lastValue;
};

/**
 * Filtro de Kalman con término de no-linealidad
 * Diseñado para señales con componentes periódicas o no-lineales
 * NOTA: El término "cuántico" es metafórico - simula efectos no-lineales
 */
class FiltroKalmanCuantico {
public:
    FiltroKalmanCuantico(float _q = 0.01, float _r = 0.1) 
        : q(_q), r(_r), x(0), p(1) {}
    
    inline float filtrar(float medida) {
        float p_temp = p + q;
        float k = p_temp / (p_temp + r);
        
        // Término no-lineal para capturar patrones complejos
        float termino_nolineal = k * 0.01f * sin(medida * 0.1f);
        
        x += k * (medida - x) + termino_nolineal;
        p = (1.0f - k) * p_temp;
        
        return x;
    }

private:
    float q, r, x, p;
};

// ============================================================================
// INSTANCIAS DE FILTROS OPTIMIZADAS CON PARÁMETROS CALIBRADOS
// ============================================================================

/**
 * Configuración de filtros para diferentes señales del sistema VO2Smart:
 * 
 * Parámetros de ajuste:
 * - q (ruido proceso): Mayor valor = más responsivo, menor = más estable
 * - r (ruido medición): Mayor valor = menos confianza en sensores
 * - alpha: Factor de suavizado para filtros exponenciales (0-1)
 */

// Filtro para presión diferencial del Venturi (señal ruidosa, necesita estabilidad)
FiltroKalman filtroPresion(0.5, 0.1);  // q=0.5 para respuesta rápida a cambios reales
                                       // r=0.1 para filtrar ruido del sensor

// Filtro para sensor de O2 (inicializado con valor ambiente típico)
FiltroKalmanGauss filtroO2(20.93, 0.5); // Valor inicial: 20.93% (aire ambiente)
                                         // q=0.5 para balance respuesta/estabilidad

// Filtro para sensor de CO2 (inicializado con valor ambiente)
KalmanFilter filtroCO2(0.01, 0.1, 400.0); // q=0.01 para suavizado agresivo
                                           // Valor inicial: 400 ppm (ambiente típico)

// Filtro exponencial para gases respiratorios (procesamiento eficiente)
MaxwellBoltzmannFilter filtroGasResp(0.1); // Alpha=0.1 para suavizado moderado

// Filtro para cálculos de volumen (balancear precisión y estabilidad)
FiltroKalman filtroVolumen(1.0, 0.2);  // q=1.0 para seguir cambios volumétricos
                                       // r=0.2 para filtrar cálculos ruidosos

// Filtro para VO2 (parámetros específicos para mediciones metabólicas)
FiltroKalman filtroVO2(0.04, 0.9);     // q=0.04 para estabilidad en mediciones lentas
                                       // r=0.9 para priorizar estabilidad sobre rapidez

// Fix TOUCH_CS warning
#define TOUCH_CS -1 // Disable touch functionality if not used

#include <TFT_eSPI.h>

// declarations for bluetooth serial --------------
// Reemplazar la implementación Bluetooth Serial antigua con BLE
// declarations for bluetooth serial --------------
#include "BluetoothSerial.h"
#if !defined(CONFIG_BT_ENABLED) || !defined(CONFIG_BLUEDROID_ENABLED)
#error Bluetooth is not enabled! Please run `make menuconfig` to and enable it
#endif
BluetoothSerial SerialBT;

// Definir UUIDs para servicios y características BLE - estos deben coincidir con los esperados por la web
#define SERVICE_UUID           "0000ffe0-0000-1000-8000-00805f9b34fb"
#define CHARACTERISTIC_UUID    "0000ffe1-0000-1000-8000-00805f9b34fb"

BLEServer* pServer = NULL;
BLECharacteristic* pCharacteristic = NULL;
bool deviceConnected = false;
bool oldDeviceConnected = false;
std::string btBuffer = "";

// Callbacks para manejar conexiones BLE
class MyServerCallbacks: public BLEServerCallbacks {
    void onConnect(BLEServer* pServer) {
      deviceConnected = true;
      Serial.println("Cliente BLE conectado!");
    };

    void onDisconnect(BLEServer* pServer) {
      deviceConnected = false;
      Serial.println("Cliente BLE desconectado!");
      // Reiniciar advertising cuando se desconecta el cliente
      pServer->getAdvertising()->start();
    }
}; // Add the missing semicolon here

const char* Version = "V02Smart 2025 Curvo";

byte bpm;

bool _BLEClientConnected = false;

// ------------------------------------------


#include <Adafruit_BMP280.h> //Library for barometric sensor
Adafruit_BMP280 bmp;

// Starts Screen for TTGO device
TFT_eSPI tft = TFT_eSPI(); // Invoke library, pins defined in User_Setup.h

// Labels the pressure sensor: mySensor
Omron_D6FPH mySensor;

// Label of oxygen sensor
DFRobot_OxygenSensor Oxygen;
#define COLLECT_NUMBER 10           // collect number, the collection range is 1-100.
#define Oxygen_IICAddress ADDRESS_3 // I2C  label for o2 address

// CO2 sensor instance
SCD30 scd30;

// Defines button state for adding wt
const int buttonPin1 = 0;
const int buttonPin2 = 35;
int wtTotal = 0;
int buttonPushCounter1 = 0; // counter for the duration of button1 pressed
int buttonState1 = 1;       // current state of the button
int buttonPushCounter2 = 0; // counter for the duration of button2 pressed
int buttonState2 = 1;       // current state of the button
int screenChanged = 0;
int screenNr = 1;
int HeaderStreamed = 0;
int HeaderStreamedBT = 0;
int DEMO = 0; // 1 = DEMO-mode

// ############################################
//  Select correct diameter depending on printed
//  case dimensions:
// ############################################

// Verificar y ajustar las áreas del Venturi
float area_1 = 0.000531; // Área de 26mm de diámetro
#if (DIAMETER == 20)
float area_2 = 0.000314; // Área de 20mm de diámetro
#elif (DIAMETER == 19)
float area_2 = 0.000284; // Área de 19mm de diámetro
#else
float area_2 = 0.000201; // Área de 16mm de diámetro
#endif

// Verificar densidades del aire
float rho = 1.225;     // Densidad en condiciones ATP (aire seco)
float rhoSTPD = 1.292; // Densidad en condiciones STPD
float rhoBTPS = 1.123; // Densidad en condiciones BTPS

float massFlow = 0;
float volFlow = 0;
float volumeTotal = 0;      // variable for holding total volume of breath
float pressure = 0.0;       // differential pressure of the venturi nozzle
float pressThreshold = 0.2; // threshold for starting calculation of VE
float volumeVE = 0.0;
float volumeVEmean = 0.0;
float volumeExp = 0.0;

// ######## Edit correction factor based on flow measurment with calibration syringe ############

// float correctionSensor = 1.0;   // correction factor

// ##############################################################################################

// Basic defaults in settings, saved to eeprom
struct
{
    int version = 1;              // Make sure saved data is right version
    float correctionSensor = 1.0; // calculated from 3L calibration syringe
    float weightkg = 75.0;        // Standard-body-weight
    bool co2_on = false;          // CO2 sensor active
} settings;

// Estructura para logging centralizado de errores
struct ErrorLogEntry {
    unsigned long timestamp;      // Timestamp del error
    char sensorName[16];         // Nombre del sensor
    float value;                 // Valor que causó el error
    char reason[32];             // Razón del error
};

// Sistema de logging de errores
struct ErrorLogger {
    ErrorLogEntry entries[MAX_ERROR_LOG_ENTRIES];
    int currentIndex;
    int totalErrors;
    bool initialized;
} errorLog;

// Contadores de errores por sensor para manejo inteligente
struct SensorErrorCounters {
    int o2Errors;
    int co2Errors;
    int pressureErrors;
    int temperatureErrors;
    unsigned long lastO2ErrorTime;
    unsigned long lastCO2ErrorTime;
    unsigned long lastPressureErrorTime;
    unsigned long lastTempErrorTime;
} sensorErrors;

float TimerVolCalc = 0.0;
float Timer5s = 0.0;
float Timer1min = 0.0;
float TimerVO2calc = 0.0;
float TimerVO2diff = 0.0; // used for integral of calories
float TimerStart = 0.0;
float TotalTime = 0.0;
String TotalTimeMin = String("00:00");
int readVE = 0;
float TimerVE = 0.0;
float DurationVE = 0.0;

float lastO2 = 0;
float initialO2 = 0;
float co2 = 0;
float calTotal = 0;
float vo2Cal = 0;
float vo2CalH = 0;        // calories per hour
float vo2CalDay = 0.0;    // calories per day
float vo2CalDayMax = 0.0; // highest value of calories per day
float vo2Max = 0;         // value of vo2Max/min/kg, calculated every 30 seconds
float vo2Total = 0.0;     // value of total vo2Max/min
float vo2MaxMax = 0;      // Best value of vo2 max for whole time machine is on

float respq = 0.0;      // respiratory quotient in mol VCO2 / mol VO2
float co2ppm = 0.0;     // CO2 sensor in ppm
float co2perc = 0.0;    // = CO2ppm /10000
float initialCO2 = 0.0; // initial value of CO2 in ppm
float vco2Total = 0.0;
float vco2Max = 0.0;
float co2temp = 0.0; // temperature CO2 sensor
float co2hum = 0.0;  // humidity CO2 sensor (not used in calculations)

float freqVE = 0.0;     // ventilation frequency
float freqVEmean = 0.0; // mean ventilation frequency

float expiratVol = 0.0; // last expiratory volume in L
float volumeTotalOld = 0.0;
float volumeTotal2 = 0.0;
float TempC = 15.0;    // Air temperature in Celsius barometric sensor BMP180
float PresPa = 101325; // uncorrected (absolute) barometric pressure

float Battery_Voltage = 0.0;

// Constantes para calibración con jeringa
#define SYRINGE_VOLUME 3000.0      // Volumen de la jeringa en mL
#define CALIB_TIMEOUT_MS 60000     // Tiempo máximo para la calibración (1 minuto)
#define CALIB_UPDATE_INTERVAL_MS 100 // Intervalo de actualización (100 ms)
#define CALIB_ALLOWED_ERROR 3.0    // Error permitido (3%)

// Constantes para validación de sensores y rangos fisiológicos
#define O2_MIN_VALID 8.0           // Mínimo O2% válido (hipoxia severa)
#define O2_MAX_VALID 25.0          // Máximo O2% válido (hiperoxia)
#define O2_AMBIENT_TYPICAL 20.93   // O2% típico del aire ambiente
#define CO2_MIN_VALID 200.0        // Mínimo CO2 ppm válido
#define CO2_MAX_VALID 50000.0      // Máximo CO2 ppm válido (5%)
#define CO2_AMBIENT_TYPICAL 400.0  // CO2 ppm típico del aire ambiente
#define PRESSURE_MIN_VALID -50.0   // Mínima presión diferencial válida (Pa)
#define PRESSURE_MAX_VALID 5000.0  // Máxima presión diferencial válida (Pa)
#define TEMP_MIN_VALID -10.0       // Mínima temperatura válida (°C)
#define TEMP_MAX_VALID 60.0        // Máxima temperatura válida (°C)
#define VO2_MIN_PHYSIOLOGICAL 3.0  // Mínimo VO2/kg fisiológico (ml/kg/min)
#define VO2_MAX_PHYSIOLOGICAL 100.0 // Máximo VO2/kg fisiológico (ml/kg/min)
#define ATMOSPHERIC_PRESSURE_MIN 85000  // Presión atmosférica mínima (Pa) - ~850 mbar
#define ATMOSPHERIC_PRESSURE_MAX 108000 // Presión atmosférica máxima (Pa) - ~1080 mbar

// Constantes para sistema de errores centralizado
#define MAX_ERROR_LOG_ENTRIES 20   // Máximo número de errores almacenados
#define ERROR_DISPLAY_DURATION 2000 // Duración de visualización de errores (ms)
#define SENSOR_ERROR_THRESHOLD 5   // Errores consecutivos antes de desactivar sensor

// Constantes para integridad EEPROM
#define EEPROM_CHECKSUM_OFFSET (sizeof(settings)) // Posición del checksum
#define EEPROM_MAGIC_WORD 0xDEADBEEF              // Palabra mágica para validación

// Demo mode variables
#define DEMO_SCREEN_DURATION 10000  // 10 segundos por pantalla
#define DEMO_UPDATE_INTERVAL 300    // Actualización cada 300ms

struct {
    uint8_t currentScreen;
    float batteryVoltage;
    float vo2;
    float vco2;
    float rq;
    float ve;
    float freq;
    unsigned long lastScreenChange;
    unsigned long lastBatteryUpdate;
    unsigned long lastDataUpdate;
    unsigned long lastDisplayUpdate;    
    bool needsDisplayUpdate;
    // Nuevas variables para demo mejorado
    uint8_t testPhase;         // 0=reposo, 1=calentamiento, 2=incremental, 3=máximo, 4=recuperación
    float testTime;            // Tiempo transcurrido en minutos
    float testDuration;        // Duración total planeada en minutos
    float workload;            // Carga de trabajo en watts
    float hr;                  // Frecuencia cardíaca
    float hrMax;               // FC máxima alcanzada
    float vo2Max;              // VO2 máximo alcanzado
    float vo2Percent;          // Porcentaje del VO2max teórico
    bool showGrid;             // Mostrar cuadrícula en gráficos
    float dataHistory[120][4]; // Almacenar historia: [tiempo][vo2,hr,ve,rq]
    int dataPoints;            // Número de puntos de datos almacenados
    int protocolType;          // 0=Rampa, 1=Escalón, 2=Bruce
    bool isPaused;             // Para pausar la simulación
    float weight;              // Peso del sujeto simulado en kg
    float height;              // Altura del sujeto simulado en cm
    uint8_t age;               // Edad del sujeto simulado
    uint8_t gender;            // 0=masculino, 1=femenino
    float mets;                // Equivalentes metabólicos
} demo;

// Constantes para el modo demo basadas en literatura científica
#define DEMO_REST_VO2          3.5     // ml/kg/min en reposo (1 MET)
#define DEMO_WARMUP_VO2        15.0    // ml/kg/min en calentamiento
#define DEMO_VO2_INCREMENT     3.0     // Incremento ml/kg/min por min en fase incremental
#define DEMO_MAX_VO2_MALE      42.0    // VO2max promedio para hombre sedentario 35-40 años
#define DEMO_MAX_VO2_FEMALE    35.0    // VO2max promedio para mujer sedentaria 35-40 años
#define DEMO_MAX_HR_FORMULA    220     // Base para fórmula FC máx = 220-edad
#define DEMO_REST_HR           70      // FC en reposo promedio
#define DEMO_RQ_REST           0.82    // RQ en reposo
#define DEMO_RQ_MAX            1.15    // RQ máximo al final del test
#define DEMO_VE_REST           8.0     // Ventilación en reposo (L/min)
#define DEMO_BREATH_REST       12      // Respiraciones por minuto en reposo
#define DEMO_BREATH_MAX        50      // Respiraciones por minuto máximas

// Enumeración para fases del test
enum TestPhases {
    PHASE_REST = 0,
    PHASE_WARMUP = 1,
    PHASE_INCREMENTAL = 2,
    PHASE_MAX = 3,
    PHASE_RECOVERY = 4
};

// Enumeración para protocolos
enum TestProtocols {
    PROTOCOL_RAMP = 0,
    PROTOCOL_STEP = 1,
    PROTOCOL_BRUCE = 2
};

// Colores adicionales para mejorar la interfaz (coherentes con TFT_eSPI)
#define TFT_NAVY        0x000F      // Azul marino
#define TFT_DARKGREEN   0x03E0      // Verde oscuro
#define TFT_DARKCYAN    0x03EF      // Cian oscuro
#define TFT_MAROON      0x7800      // Marrón
#define TFT_PURPLE      0x780F      // Púrpura
#define TFT_OLIVE       0x7BE0      // Oliva
#define TFT_LIGHTGREY   0xD69A      // Usar el valor de TFT_eSPI.h
#define TFT_DARKGREY    0x7BEF      // Gris oscuro
#define TFT_ORANGE      0xFDA0      // Usar el valor de TFT_eSPI.h
#define TFT_PINK        0xFE19      // Rosa

// Implementación mejorada de generateDemoData()
void generateDemoData() {
    // Actualizar el tiempo de test
    static unsigned long lastUpdate = millis();
    unsigned long now = millis();
    float deltaTime = (now - lastUpdate) / 1000.0 / 60.0; // Convertir a minutos
    
    // Avanzar tiempo solo si no está pausado
    if (!demo.isPaused) {
        demo.testTime += deltaTime;
    }
    lastUpdate = now;
    
    // Determinar la fase actual del test basándose en el tiempo transcurrido
    if (demo.testTime < 2.0) {
        // Fase de reposo (2 minutos)
        demo.testPhase = PHASE_REST;
    } else if (demo.testTime < 4.0) {
        // Fase de calentamiento (2 minutos)
        demo.testPhase = PHASE_WARMUP;
    } else if (demo.testTime < 14.0) {
        // Fase incremental (10 minutos)
        demo.testPhase = PHASE_INCREMENTAL;
    } else if (demo.testTime < 15.0) {
        // Fase VO2max (1 minuto)
        demo.testPhase = PHASE_MAX;
    } else {
        // Fase de recuperación
        demo.testPhase = PHASE_RECOVERY;
    }
    
    // Valores objetivo según la fase (basados en literatura científica)
    float targetVO2 = 0.0;
    float targetHR = 0.0;
    float targetRQ = 0.0;
    float targetVE = 0.0;
    float targetFreq = 0.0;
    float maxPredictedVO2 = (demo.gender == 0) ? DEMO_MAX_VO2_MALE : DEMO_MAX_VO2_FEMALE;
    float maxPredictedHR = DEMO_MAX_HR_FORMULA - demo.age;
    
    // Calcular valores objetivo según la fase del test
    switch(demo.testPhase) {
        case PHASE_REST:
            targetVO2 = DEMO_REST_VO2;
            targetHR = DEMO_REST_HR;
            targetRQ = DEMO_RQ_REST;
            targetVE = DEMO_VE_REST;
            targetFreq = DEMO_BREATH_REST;
            demo.workload = 0;
            break;
            
        case PHASE_WARMUP:
            targetVO2 = DEMO_WARMUP_VO2;
            targetHR = DEMO_REST_HR + (maxPredictedHR - DEMO_REST_HR) * 0.3;
            targetRQ = DEMO_RQ_REST + 0.05;
            targetVE = DEMO_VE_REST * 2;
            targetFreq = DEMO_BREATH_REST * 1.3;
            demo.workload = 50;
            break;
            
        case PHASE_INCREMENTAL:
            // Incremento lineal durante la fase incremental
            {
                float incrementalProgress = (demo.testTime - 4.0) / 10.0; // 0 a 1 durante los 10 min
                targetVO2 = DEMO_WARMUP_VO2 + (maxPredictedVO2 - DEMO_WARMUP_VO2) * incrementalProgress;
                targetHR = DEMO_REST_HR + (maxPredictedHR - DEMO_REST_HR) * (0.3 + 0.65 * incrementalProgress);
                targetRQ = DEMO_RQ_REST + 0.05 + (DEMO_RQ_MAX - DEMO_RQ_REST - 0.05) * incrementalProgress;
                targetVE = DEMO_VE_REST * (2 + 10 * incrementalProgress);
                targetFreq = DEMO_BREATH_REST * (1.3 + 2.7 * incrementalProgress);
                
                // Calcular carga de trabajo según protocolo
                if (demo.protocolType == PROTOCOL_RAMP) {
                    // Incremento continuo
                    demo.workload = 50 + 150 * incrementalProgress;
                } else if (demo.protocolType == PROTOCOL_STEP) {
                    // Incremento en bloques de 2 minutos
                    int stepNumber = (int)((demo.testTime - 4.0) / 2.0);
                    demo.workload = 50 + stepNumber * 30;
                } else if (demo.protocolType == PROTOCOL_BRUCE) {
                    // Protocolo de Bruce (aproximación)
                    int stageNumber = (int)((demo.testTime - 4.0) / 3.0);
                    float speeds[5] = {1.7, 2.5, 3.4, 4.2, 5.0}; // mph
                    float grades[5] = {10, 12, 14, 16, 18}; // %
                    float speed = (stageNumber < 5) ? speeds[stageNumber] : 5.0;
                    float grade = (stageNumber < 5) ? grades[stageNumber] : 18.0;
                    // Convertir a watts (aproximación)
                    demo.workload = 50 + 50 * stageNumber;
                }
            }
            break;
            
        case PHASE_MAX:
            // Meseta del VO2
            targetVO2 = maxPredictedVO2;
            targetHR = maxPredictedHR;
            targetRQ = DEMO_RQ_MAX;
            targetVE = DEMO_VE_REST * 12;
            targetFreq = DEMO_BREATH_MAX;
            demo.workload = 200;
            
            // Guardar máximos
            if (targetVO2 > demo.vo2Max) demo.vo2Max = targetVO2;
            if (targetHR > demo.hrMax) demo.hrMax = targetHR;
            break;
            
        case PHASE_RECOVERY:
            // Descenso exponencial en la recuperación
            {
                float recoveryTime = demo.testTime - 15.0; // Tiempo en recuperación
                float recoveryFactor = exp(-recoveryTime / 2.0); // Decaimiento exponencial
                
                targetVO2 = DEMO_REST_VO2 + (maxPredictedVO2 - DEMO_REST_VO2) * recoveryFactor * 0.6;
                targetHR = DEMO_REST_HR + (maxPredictedHR - DEMO_REST_HR) * recoveryFactor * 0.7;
                targetRQ = DEMO_RQ_REST + (DEMO_RQ_MAX - DEMO_RQ_REST) * recoveryFactor * 0.8;
                targetVE = DEMO_VE_REST * (1 + 11 * recoveryFactor * 0.7);
                targetFreq = DEMO_BREATH_REST * (1 + 3 * recoveryFactor * 0.8);
                demo.workload = 50 * recoveryFactor;
            }
            break;
    }
    
    // Añadir oscilaciones fisiológicas realistas (variabilidad)
    static float oscillationPhase = 0;
    oscillationPhase += deltaTime * 10; // Velocidad de oscilación
    
    float breathOscillation = sin(oscillationPhase * 3) * 0.05; // Oscilación respiratoria
    float hrOscillation = sin(oscillationPhase) * 0.02; // Oscilación cardíaca
    
    // Aplicar valores finales con suavizado y oscilaciones
    float smoothingFactor = 0.1; // Factor de suavizado (0-1)
    
    demo.vo2 = demo.vo2 * (1-smoothingFactor) + (targetVO2 * (1.0 + breathOscillation)) * smoothingFactor;
    demo.hr = demo.hr * (1-smoothingFactor) + (targetHR * (1.0 + hrOscillation)) * smoothingFactor;
    demo.rq = demo.rq * (1-smoothingFactor) + (targetRQ * (1.0 + breathOscillation * 0.2)) * smoothingFactor;
    demo.ve = demo.ve * (1-smoothingFactor) + (targetVE * (1.0 + breathOscillation * 2)) * smoothingFactor;
    demo.freq = demo.freq * (1-smoothingFactor) + (targetFreq * (1.0 + breathOscillation)) * smoothingFactor;
    
    // Calcular VCO2 a partir de VO2 y RQ
    demo.vco2 = demo.vo2 * demo.rq;
    
    // Actualizar porcentaje del VO2max teórico
    demo.vo2Percent = (demo.vo2 / maxPredictedVO2) * 100.0;
    
    // Actualizar MET (1 MET = 3.5 ml/kg/min)
    demo.mets = demo.vo2 / 3.5;
    
    // Almacenar datos históricos (cada 15 segundos)
    if (now - demo.lastDataUpdate >= 15000 && demo.dataPoints < 120) {
        demo.dataHistory[demo.dataPoints][0] = demo.vo2;
        demo.dataHistory[demo.dataPoints][1] = demo.hr;
        demo.dataHistory[demo.dataPoints][2] = demo.ve;
        demo.dataHistory[demo.dataPoints][3] = demo.rq;
        demo.dataPoints++;
        demo.lastDataUpdate = now;
    }
    
    // Actualizar valores usados en el flujo principal para pantallas
    vo2Max = filtroVO2.filtrar(volumeVEmean * (lastO2 - initialO2) * 10); // Ejemplo simplificado
    vco2Max = volumeVEmean * co2perc; // Cálculo directo
    volumeVEmean = demo.ve;
    freqVEmean = demo.freq;
    respq = demo.rq;
    
    // Simular volumen respiratorio (basado en VE y frecuencia)
    volumeExp = demo.ve / demo.freq;
    
    // Simular la batería con un patrón realista
    static float batteryDirection = -0.0001;
    demo.batteryVoltage += batteryDirection;
    if (demo.batteryVoltage < 3.5) {
        batteryDirection = 0.0001;
    } else if (demo.batteryVoltage > 4.1) {
        batteryDirection = -0.0001;
    }
    
    // Actualizar variable global para integración con otras partes del código
    Battery_Voltage = demo.batteryVoltage;
    
    // Actualizar tiempo total para integración con otras partes del código
    TotalTime = demo.testTime * 60000; // Convertir a milisegundos
    ConvertTime(TotalTime); // Actualizar cadena de tiempo formateada
}

// Limpieza y unificación de la función drawDemoScreen, asegurando cierre correcto y sin duplicados
void drawDemoScreen(int screenNum) {
    tft.fillScreen(TFT_BLACK);
    tft.setTextColor(TFT_CYAN, TFT_BLACK);
    // Mostrar la fase actual del test en la parte superior
    const char* phaseText = "";
    switch (demo.testPhase) {
        case PHASE_REST: phaseText = "Reposo"; break;
        case PHASE_WARMUP: phaseText = "Calentamiento"; break;
        case PHASE_INCREMENTAL: phaseText = "Incremental"; break;
        case PHASE_MAX: phaseText = "Maximo"; break;
        case PHASE_RECOVERY: phaseText = "Recuperacion"; break;
    }
    tft.drawString(phaseText, 5, 3, 2);
    tft.setTextColor(TFT_WHITE, TFT_NAVY);
    int mins = int(demo.testTime);
    int secs = int((demo.testTime - mins) * 60);
    char timeStr[8];
    sprintf(timeStr, "%02d:%02d", mins, secs);
    tft.drawRightString(timeStr, 235, 3, 2);

    switch (screenNum) {
        case 1: {
            // Pantalla 1: VO2, FC, RQ, barra de intensidad
            tft.setTextColor(TFT_WHITE, TFT_BLACK);
            tft.drawString("VO2 (ml/kg/min):", 10, 50, 2);
            tft.setTextColor(TFT_YELLOW, TFT_BLACK);
            tft.drawFloat(demo.vo2, 1, 170, 50, 2);
            tft.setTextColor(TFT_WHITE, TFT_BLACK);
            tft.drawString("FC (lpm):", 10, 75, 2);
            tft.setTextColor(TFT_YELLOW, TFT_BLACK);
            tft.drawFloat(demo.hr, 0, 170, 75, 2);
            tft.setTextColor(TFT_WHITE, TFT_BLACK);
            tft.drawString("RQ:", 10, 100, 2);
            tft.setTextColor(TFT_YELLOW, TFT_BLACK);
            tft.drawFloat(demo.rq, 2, 170, 100, 2);
            int intensity = int(demo.vo2Percent);
            intensity = constrain(intensity, 0, 100);
            tft.fillRect(20, 150, 200, 15, TFT_DARKGREY);
            uint16_t barColor;
            if (intensity < 50) barColor = TFT_GREEN;
            else if (intensity < 75) barColor = TFT_YELLOW;
            else if (intensity < 90) barColor = TFT_ORANGE;
            else barColor = TFT_RED;
            tft.fillRect(20, 150, intensity * 2, 15, barColor);
            tft.setTextColor(TFT_BLACK, barColor);
            if (intensity > 10) {
                tft.drawNumber(intensity, 25, 150, 2);
                tft.drawString("%", 45, 150, 2);
            }
            break;
        }
        case 2: {
            // Pantalla 2: Ventilación y frecuencia respiratoria
            tft.setTextColor(TFT_CYAN, TFT_BLACK);
            tft.drawCentreString("VENTILACION", 120, 5, 2);
            tft.fillRoundRect(10, 25, 110, 50, 5, TFT_DARKGREEN);
            tft.setTextColor(TFT_WHITE, TFT_DARKGREEN);
            tft.drawString("VE", 15, 30, 2);
            tft.setTextColor(TFT_YELLOW, TFT_DARKGREEN);
            tft.drawFloat(demo.ve, 1, 20, 50, 4);
            tft.setTextColor(TFT_WHITE, TFT_DARKGREEN);
            tft.drawString("L/min", 15, 75, 1);
            tft.fillRoundRect(130, 25, 110, 50, 5, TFT_DARKCYAN);
            tft.setTextColor(TFT_WHITE, TFT_DARKCYAN);
            tft.drawString("FREC", 135, 30, 2);
            tft.setTextColor(TFT_YELLOW, TFT_DARKCYAN);
            tft.drawFloat(demo.freq, 1, 140, 50, 4);
            tft.setTextColor(TFT_WHITE, TFT_DARKCYAN);
            tft.drawString("resp/min", 135, 75, 1);
            // Gráfico de ventilación
            tft.fillRect(10, 90, 220, 40, TFT_NAVY);
            tft.drawRect(10, 90, 220, 40, TFT_WHITE);
            if (demo.dataPoints > 0) {
                float maxVE = 0;
                for (int i = 0; i < demo.dataPoints; i++) {
                    if (demo.dataHistory[i][2] > maxVE) maxVE = demo.dataHistory[i][2];
                }
                if (maxVE < 30) maxVE = 30;
                int startIdx = max(0, demo.dataPoints - 20);
                for (int i = startIdx; i < demo.dataPoints - 1; i++) {
                    int x1 = map(i - startIdx, 0, 19, 15, 225);
                    int y1 = map(demo.dataHistory[i][2], 0, maxVE, 125, 95);
                    int x2 = map(i + 1 - startIdx, 0, 19, 15, 225);
                    int y2 = map(demo.dataHistory[i + 1][2], 0, maxVE, 125, 95);
                    tft.drawLine(x1, y1, x2, y2, TFT_GREEN);
                }
            }
            break;
        }
        case 3: {
            // Pantalla 3: Consumo energético
            tft.setTextColor(TFT_CYAN, TFT_BLACK);
            tft.drawCentreString("CONSUMO ENERGETICO", 120, 25, 2);
            tft.fillRoundRect(5, 40, 110, 55, 5, TFT_RED);
            tft.setTextColor(TFT_WHITE, TFT_RED);
            tft.drawString("VO2MAX", 12, 43, 2);
            tft.setTextColor(TFT_YELLOW, TFT_RED);
            tft.drawFloat(demo.vo2Max, 1, 20, 60, 4);
            tft.setTextColor(TFT_WHITE, TFT_RED);
            tft.drawString("ml/kg/min", 15, 85, 1);
            tft.fillRoundRect(125, 40, 110, 55, 5, TFT_OLIVE);
            tft.setTextColor(TFT_WHITE, TFT_OLIVE);
            tft.drawString("METS", 132, 43, 2);
            tft.setTextColor(TFT_YELLOW, TFT_OLIVE);
            tft.drawFloat(demo.mets, 1, 140, 60, 4);
            tft.fillRoundRect(5, 100, 110, 45, 5, TFT_MAROON);
            tft.setTextColor(TFT_WHITE, TFT_MAROON);
            tft.drawString("VCO2", 12, 103, 2);
            tft.setTextColor(TFT_YELLOW, TFT_MAROON);
            tft.drawFloat(demo.vco2, 1, 20, 118, 4);
            float calories = demo.vo2 * demo.weight * 0.005;
            tft.fillRoundRect(125, 100, 110, 45, 5, TFT_ORANGE);
            tft.setTextColor(TFT_WHITE, TFT_ORANGE);
            tft.drawString("KCAL/MIN", 132, 103, 2);
            tft.setTextColor(TFT_YELLOW, TFT_ORANGE);
            tft.drawFloat(calories, 1, 140, 118, 4);
            char subjectInfo[30];
            sprintf(subjectInfo, "%s, %da, %dcm, %dkg", demo.gender == 0 ? "Hombre" : "Mujer", demo.age, (int)demo.height, (int)demo.weight);
            tft.fillRect(0, 150, 240, 20, TFT_NAVY);
            tft.setTextColor(TFT_WHITE, TFT_NAVY);
            tft.drawCentreString(subjectInfo, 120, 153, 2);
            break;
        }
        case 4: {
            // Pantalla 4: VE y FREC
            tft.setTextColor(TFT_CYAN, TFT_BLACK);
            tft.drawCentreString("VE y FREC", 120, 5, 2);
            tft.fillRoundRect(10, 25, 110, 50, 5, TFT_DARKGREEN);
            tft.setTextColor(TFT_WHITE, TFT_DARKGREEN);
            tft.drawString("VE", 15, 30, 2);
            tft.setTextColor(TFT_YELLOW, TFT_DARKGREEN);
            tft.drawFloat(demo.ve, 1, 20, 50, 4);
            tft.setTextColor(TFT_WHITE, TFT_DARKGREEN);
            tft.drawString("L/min", 15, 75, 1);
            tft.fillRoundRect(130, 25, 110, 50, 5, TFT_DARKCYAN);
            tft.setTextColor(TFT_WHITE, TFT_DARKCYAN);
            tft.drawString("FREC", 135, 30, 2);
            tft.setTextColor(TFT_YELLOW, TFT_DARKCYAN);
            tft.drawFloat(demo.freq, 1, 140, 50, 4);
            tft.setTextColor(TFT_WHITE, TFT_DARKCYAN);
            tft.drawString("resp/min", 135, 75, 1);
            break;
        }
        case 5: {
            // Pantalla 5: VO2 y CARGA
            tft.setTextColor(TFT_CYAN, TFT_BLACK);
            tft.drawCentreString("VO2 y CARGA", 120, 5, 2);
            tft.fillRoundRect(10, 25, 110, 50, 5, TFT_DARKCYAN);
            tft.setTextColor(TFT_WHITE, TFT_DARKCYAN);
            tft.drawString("VO2", 15, 30, 2);
            tft.setTextColor(TFT_YELLOW, TFT_DARKCYAN);
            tft.drawFloat(demo.vo2, 1, 20, 50, 4);
            tft.setTextColor(TFT_WHITE, TFT_DARKCYAN);
            tft.drawString("ml/kg/min", 15, 75, 1);
            tft.fillRoundRect(130, 25, 110, 50, 5, TFT_GREEN);
            tft.setTextColor(TFT_WHITE, TFT_GREEN);
            tft.drawString("CARGA", 135, 30, 2);
            tft.setTextColor(TFT_YELLOW, TFT_GREEN);
            tft.drawNumber(int(demo.workload), 140, 50, 4);
            break;
        }
        case 6: {
            // Pantalla 6: VCO2 y KCAL/MIN
            tft.setTextColor(TFT_CYAN, TFT_BLACK);
            tft.drawCentreString("VCO2 y KCAL/MIN", 120, 5, 2);
            tft.fillRoundRect(10, 25, 110, 50, 5, TFT_MAROON);
            tft.setTextColor(TFT_WHITE, TFT_MAROON);
            tft.drawString("VCO2", 15, 30, 2);
            tft.setTextColor(TFT_YELLOW, TFT_MAROON);
            tft.drawFloat(demo.vco2, 1, 20, 50, 4);
            float calories = demo.vo2 * demo.weight * 0.005;
            tft.fillRoundRect(130, 25, 110, 50, 5, TFT_ORANGE);
            tft.setTextColor(TFT_WHITE, TFT_ORANGE);
            tft.drawString("KCAL/MIN", 135, 30, 2);
            tft.setTextColor(TFT_YELLOW, TFT_ORANGE);
            tft.drawFloat(calories, 1, 140, 50, 4);
            break;
        }
        default: {
            tft.setTextColor(TFT_WHITE, TFT_BLACK);
            tft.drawCentreString("Pantalla no implementada", 120, 60, 2);
            break;
        }
    }
    tft.setTextColor(TFT_LIGHTGREY, TFT_BLACK);
    tft.drawString("Bot1: Siguiente", 2, 175, 1);
    tft.drawString("Bot2: Pausa", 120, 175, 1);
    drawBatteryIndicator();
}

//----------------------------------------------------------------------------------------------------------
//                  MAIN PROGRAM
//----------------------------------------------------------------------------------------------------------

// ============================================================================
// SISTEMA DE VALIDACIÓN DE DATOS Y MANEJO CENTRALIZADO DE ERRORES
// ============================================================================

/**
 * Inicializa el sistema de logging de errores
 * Debe llamarse una vez al inicio del programa
 */
void initializeErrorLogging() {
    if (errorLogMutex == NULL) {
        errorLogMutex = xSemaphoreCreateMutex();
    }
    
    if (xSemaphoreTake(errorLogMutex, pdMS_TO_TICKS(100))) {
        errorLog.currentIndex = 0;
        errorLog.totalErrors = 0;
        errorLog.initialized = true;
        
        // Inicializar contadores de errores por sensor
        memset(&sensorErrors, 0, sizeof(sensorErrors));
        
        Serial.println("Sistema de logging de errores inicializado");
        xSemaphoreGive(errorLogMutex);
    }
}

/**
 * Registra un error de sensor en el log centralizado
 * @param sensorName Nombre del sensor que generó el error
 * @param value Valor que causó el error
 * @param reason Descripción del motivo del error
 */
void logSensorError(const char* sensorName, float value, const char* reason) {
    if (!errorLog.initialized || errorLogMutex == NULL) return;
    
    if (xSemaphoreTake(errorLogMutex, pdMS_TO_TICKS(50))) {
        ErrorLogEntry* entry = &errorLog.entries[errorLog.currentIndex];
        
        entry->timestamp = millis();
        strncpy(entry->sensorName, sensorName, sizeof(entry->sensorName) - 1);
        entry->sensorName[sizeof(entry->sensorName) - 1] = '\0';
        entry->value = value;
        strncpy(entry->reason, reason, sizeof(entry->reason) - 1);
        entry->reason[sizeof(entry->reason) - 1] = '\0';
        
        errorLog.currentIndex = (errorLog.currentIndex + 1) % MAX_ERROR_LOG_ENTRIES;
        errorLog.totalErrors++;
        
        // Log detallado por serial para depuración
        Serial.printf("[ERROR] %s: %.2f - %s (Total errores: %d)\n", 
                     sensorName, value, reason, errorLog.totalErrors);
        
        xSemaphoreGive(errorLogMutex);
    }
}

/**
 * Valida si un valor de sensor está dentro de rangos aceptables
 * @param value Valor a validar
 * @param min Valor mínimo aceptable
 * @param max Valor máximo aceptable
 * @param sensorName Nombre del sensor para logging
 * @return true si el valor es válido, false en caso contrario
 */
bool validateSensorData(float value, float min, float max, const char* sensorName) {
    // Verificar si el valor es NaN o infinito
    if (isnan(value) || isinf(value)) {
        logSensorError(sensorName, value, "Valor NaN/Infinito");
        return false;
    }
    
    // Verificar rango válido
    if (value < min || value > max) {
        char reason[64];
        snprintf(reason, sizeof(reason), "Fuera de rango [%.2f, %.2f]", min, max);
        logSensorError(sensorName, value, reason);
        return false;
    }
    
    return true;
}

/**
 * Valida específicamente lecturas de oxígeno con lógica contextual
 * @param o2Value Porcentaje de O2 medido
 * @return true si la lectura es válida y confiable
 */
bool isValidO2Reading(float o2Value) {
    if (!validateSensorData(o2Value, O2_MIN_VALID, O2_MAX_VALID, "O2")) {
        return false;
    }
    
    // Verificación adicional: el O2 no debería estar demasiado lejos del ambiente
    // a menos que estemos en una medición activa
    static float lastValidO2 = O2_AMBIENT_TYPICAL;
    float deviation = fabs(o2Value - lastValidO2);
    
    // Permitir cambios graduales mayores durante mediciones activas
    if (deviation > 5.0 && TotalTime < 10000) { // Primeros 10 segundos más estrictos
        char reason[64];
        snprintf(reason, sizeof(reason), "Cambio abrupto: %.2f%% (anterior: %.2f%%)", 
                o2Value, lastValidO2);
        logSensorError("O2", o2Value, reason);
        return false;
    }
    
    lastValidO2 = o2Value;
    return true;
}

/**
 * Valida lecturas de CO2 con consideraciones fisiológicas
 * @param co2Value Concentración de CO2 en ppm
 * @return true si la lectura es válida
 */
bool isValidCO2Reading(float co2Value) {
    if (!validateSensorData(co2Value, CO2_MIN_VALID, CO2_MAX_VALID, "CO2")) {
        return false;
    }
    
    // Verificación de seguridad: niveles peligrosos de CO2
    if (co2Value > 40000) { // 4% CO2 es peligroso
        logSensorError("CO2", co2Value, "Nivel peligroso detectado");
        showError("CO2 PELIGROSO!", true);
        return false;
    }
    
    return true;
}

/**
 * Valida lecturas de presión diferencial con filtrado de ruido
 * @param pressure Presión diferencial en Pa
 * @return true si la lectura es válida
 */
bool isValidPressureReading(float pressure) {
    if (!validateSensorData(pressure, PRESSURE_MIN_VALID, PRESSURE_MAX_VALID, "Presion")) {
        return false;
    }
    
    // Filtro adicional: presiones muy pequeñas pueden ser ruido
    static int consecutiveNoiseReadings = 0;
    if (fabs(pressure) < 0.1 && TotalTime > 5000) { // Después de 5s de operación
        consecutiveNoiseReadings++;
        if (consecutiveNoiseReadings > 10) {
            logSensorError("Presion", pressure, "Posible ruido del sensor");
            consecutiveNoiseReadings = 0; // Reset para evitar spam
        }
    } else {
        consecutiveNoiseReadings = 0;
    }
    
    return true;
}

/**
 * Valida lecturas de temperatura ambiente
 * @param temperature Temperatura en grados Celsius
 * @return true si la lectura es válida
 */
bool isValidTemperatureReading(float temperature) {
    if (!validateSensorData(temperature, TEMP_MIN_VALID, TEMP_MAX_VALID, "Temperatura")) {
        return false;
    }
    
    // Verificación de estabilidad: la temperatura no debería cambiar abruptamente
    static float lastValidTemp = 20.0; // Temperatura inicial razonable
    float tempChange = fabs(temperature - lastValidTemp);
    
    if (tempChange > 10.0) { // Cambio de más de 10°C es sospechoso
        char reason[64];
        snprintf(reason, sizeof(reason), "Cambio abrupto: %.1f°C (anterior: %.1f°C)", 
                temperature, lastValidTemp);
        logSensorError("Temperatura", temperature, reason);
        return false;
    }
    
    lastValidTemp = temperature;
    return true;
}

// ============================================================================
// SISTEMA DE INTEGRIDAD EEPROM CON CHECKSUM
// ============================================================================

/**
 * Calcula el checksum CRC32 de un bloque de datos
 * @param data Puntero a los datos
 * @param size Tamaño en bytes
 * @return Checksum CRC32
 */
uint32_t calculateEEPROMChecksum(void* data, size_t size) {
    uint32_t crc = 0xFFFFFFFF;
    uint8_t* bytes = (uint8_t*)data;
    
    for (size_t i = 0; i < size; i++) {
        crc ^= bytes[i];
        for (int j = 0; j < 8; j++) {
            if (crc & 1) {
                crc = (crc >> 1) ^ 0xEDB88320; // Polinomio CRC32
            } else {
                crc >>= 1;
            }
        }
    }
    
    return ~crc;
}

/**
 * Verifica la integridad de los datos almacenados en EEPROM
 * @return true si los datos son íntegros, false si están corruptos
 */
bool verifyEEPROMIntegrity() {
    uint32_t storedChecksum;
    uint32_t calculatedChecksum;
    
    // Leer el checksum almacenado
    EEPROM.get(EEPROM_CHECKSUM_OFFSET, storedChecksum);
    
    // Calcular el checksum de los datos actuales
    calculatedChecksum = calculateEEPROMChecksum(&settings, sizeof(settings));
    
    bool isValid = (storedChecksum == calculatedChecksum);
    
    if (!isValid) {
        Serial.printf("Error de integridad EEPROM: stored=0x%08X, calculated=0x%08X\n", 
                     storedChecksum, calculatedChecksum);
        logSensorError("EEPROM", storedChecksum, "Checksum inválido");
    }
    
    return isValid;
}

/**
 * Guarda la configuración en EEPROM con verificación de integridad
 */
void saveSettingsWithChecksum() {
    if (settingsMutex == NULL) {
        settingsMutex = xSemaphoreCreateMutex();
    }
    
    if (xSemaphoreTake(settingsMutex, pdMS_TO_TICKS(100))) {
        // Calcular y almacenar checksum
        uint32_t checksum = calculateEEPROMChecksum(&settings, sizeof(settings));
        
        // Escribir configuración
        for (int i = 0; i < sizeof(settings); ++i) {
            EEPROM.write(i, ((byte *)&settings)[i]);
        }
        
        // Escribir checksum
        EEPROM.put(EEPROM_CHECKSUM_OFFSET, checksum);
        
        // Confirmar escritura
        if (EEPROM.commit()) {
            Serial.println("Configuración guardada con checksum exitosamente");
        } else {
            logSensorError("EEPROM", 0, "Fallo al confirmar escritura");
        }
        
        xSemaphoreGive(settingsMutex);
    }
}

/**
 * Carga la configuración desde EEPROM con verificación de integridad
 * @return true si la carga fue exitosa, false si hubo errores
 */
bool loadSettingsWithChecksum() {
    if (settingsMutex == NULL) {
        settingsMutex = xSemaphoreCreateMutex();
    }
    
    bool success = false;
    
    if (xSemaphoreTake(settingsMutex, pdMS_TO_TICKS(100))) {
        // Verificar integridad primero
        if (verifyEEPROMIntegrity()) {
            // Cargar datos si son válidos
            for (int i = 0; i < sizeof(settings); ++i) {
                ((byte *)&settings)[i] = EEPROM.read(i);
            }
            
            // Verificar versión de configuración
            if (settings.version == 1) {
                Serial.println("Configuración cargada exitosamente");
                success = true;
            } else {
                logSensorError("EEPROM", settings.version, "Versión incompatible");
            }
        } else {
            // Usar valores por defecto si hay corrupción
            Serial.println("Usando configuración por defecto debido a corrupción EEPROM");
            // Los valores por defecto ya están definidos en la declaración de settings
            saveSettingsWithChecksum(); // Guardar defaults limpios
        }
        
        xSemaphoreGive(settingsMutex);
    }
    
    return success;
}

// ============================================================================
// FUNCIONES OPTIMIZADAS CON PROTECCIÓN MUTEX Y VALIDACIÓN
// ============================================================================

/**
 * Ejecuta diagnósticos completos del sistema mejorado
 * Verifica integridad EEPROM, estado de sensores y sistema de errores
 */
void runSystemDiagnostics() {
    Serial.println("\n=== DIAGNÓSTICO SISTEMA VO2SMART ===");
    
    // Verificar integridad EEPROM
    Serial.print("Integridad EEPROM: ");
    if (verifyEEPROMIntegrity()) {
        Serial.println("OK");
    } else {
        Serial.println("FALLO - Datos corruptos detectados");
    }
    
    // Verificar estado de mutex
    Serial.print("Sistema Mutex: ");
    bool mutexOK = (sensorDataMutex != NULL && settingsMutex != NULL && 
                   errorLogMutex != NULL && calculationMutex != NULL);
    Serial.println(mutexOK ? "OK" : "FALLO");
    
    // Verificar sistema de logging de errores
    Serial.print("Sistema Error Log: ");
    Serial.println(errorLog.initialized ? "ACTIVO" : "INACTIVO");
    if (errorLog.initialized) {
        Serial.printf("  Errores registrados: %d\n", errorLog.totalErrors);
        Serial.printf("  Errores O2: %d, CO2: %d, Presión: %d, Temp: %d\n",
                     sensorErrors.o2Errors, sensorErrors.co2Errors,
                     sensorErrors.pressureErrors, sensorErrors.temperatureErrors);
    }
    
    // Verificar configuración cargada
    Serial.println("Configuración actual:");
    Serial.printf("  Peso: %.1f kg\n", settings.weightkg);
    Serial.printf("  Factor corrección: %.3f\n", settings.correctionSensor);
    Serial.printf("  CO2 activo: %s\n", settings.co2_on ? "SÍ" : "NO");
    
    // Verificar memoria disponible
    Serial.printf("Memoria libre: %d bytes\n", ESP.getFreeHeap());
    
    // Test rápido de filtros
    Serial.println("Test filtros:");
    float testValue = 20.5;
    Serial.printf("  Kalman O2: %.3f -> %.3f\n", testValue, filtroO2.filtrar(testValue));
    Serial.printf("  Kalman Presión: %.3f -> %.3f\n", testValue, filtroPresion.filtrar(testValue));
    
    Serial.println("=== FIN DIAGNÓSTICO ===\n");
}

// Function to display the main menu
// Removed duplicate definition of showMainMenu()

// Modificar la parte de setup() que inicializa el modo DEMO
/**
 * Configuración inicial del sistema VO2Smart
 * Inicializa hardware, sensores, sistema de errores y mutex
 */
void setup() {
    // Inicialización básica del sistema
    Serial.begin(115200);
    while (!Serial && millis() < 3000) { // Esperar Serial por max 3 segundos
        delay(10);
    }
    Serial.println("VO2Smart - Iniciando sistema...");
    
    // Inicializar EEPROM para configuración persistente
    EEPROM.begin(512); // 512 bytes deberían ser suficientes
    
    // Inicializar sistema de mutex para thread safety
    sensorDataMutex = xSemaphoreCreateMutex();
    settingsMutex = xSemaphoreCreateMutex();
    errorLogMutex = xSemaphoreCreateMutex();
    calculationMutex = xSemaphoreCreateMutex();
    
    if (sensorDataMutex == NULL || settingsMutex == NULL || 
        errorLogMutex == NULL || calculationMutex == NULL) {
        Serial.println("ERROR: Fallo al crear mutex del sistema");
        // Continuar sin mutex - funcionalidad reducida pero operativa
    } else {
        Serial.println("Sistema de mutex inicializado correctamente");
    }
    
    // Inicializar sistema de logging de errores
    initializeErrorLogging();
    
    // Configurar pines de entrada
    pinMode(buttonPin1, INPUT_PULLUP);
    pinMode(buttonPin2, INPUT_PULLUP);
    
    // Inicializar pantalla TFT
    tft.init();
    tft.setRotation(1);
    
    // Cargar configuración desde EEPROM con verificación de integridad
    Serial.println("Cargando configuración desde EEPROM...");
    if (loadSettingsWithChecksum()) {
        Serial.printf("Configuración cargada: peso=%.1fkg, corrección=%.3f\n", 
                     settings.weightkg, settings.correctionSensor);
    } else {
        Serial.println("Usando configuración por defecto");
    }
    
    // Mostrar pantalla de inicio
    showSplashScreen();
    
    // Log del estado inicial del sistema
    Serial.printf("Sistema inicializado - Memoria libre: %d bytes\n", ESP.getFreeHeap());
    Serial.printf("Versión de configuración: %d\n", settings.version);
    
    // Ejecutar diagnósticos del sistema mejorado
    runSystemDiagnostics();
    
    // Mostrar menú principal
    showCarouselMenu();
}

void loop() {
    ReadButtons();
    // Permitir volver al menú si ambos botones se mantienen presionados 2 segundos
    static unsigned long menuPressStart = 0;
    if (digitalRead(buttonPin1) == LOW && digitalRead(buttonPin2) == LOW) {
        if (menuPressStart == 0) menuPressStart = millis();
        if (millis() - menuPressStart > 2000) {
            showCarouselMenu();
            menuPressStart = 0;
            return;
        }
    } else {
        menuPressStart = 0;
    }
    if (DEMO) {
        generateDemoData();
        drawDemoScreen(demo.currentScreen);
        // Puedes agregar navegación entre pantallas demo aquí si lo deseas
    } else {
        showScreen();
        // Puedes agregar navegación entre pantallas VO2 aquí si lo deseas
    }
    delay(10); // Pequeño delay para estabilidad
}

// --- MENÚ PRINCIPAL ---
void showMainMenu() {
    enum MenuOptions {
        OPTION_VO2_MODE = 0,
        OPTION_DEMO_MODE,
        OPTION_CALIBRATION,
        OPTION_SETTINGS,
        OPTION_COUNT
    };

    const char* menuOptions[] = {
        "Modo VO2",
        "Modo Demo",
        "Calibracion",
        "Configuracion"
    };

    int selectedOption = 0;
    bool menuActive = true;

    while (menuActive) {
        // Dibujar el menú
        tft.fillScreen(TFT_BLACK);
        tft.setTextColor(TFT_CYAN, TFT_BLACK);
        tft.drawCentreString("VO2Smart Menu", 120, 10, 4);
        for (int i = 0; i < OPTION_COUNT; i++) {
            int y = 50 + i * 35;
            if (i == selectedOption) {
                tft.fillRoundRect(20, y, 200, 30, 5, TFT_DARKGREY);
                tft.setTextColor(TFT_YELLOW, TFT_DARKGREY);
            } else {
                tft.fillRoundRect(20, y, 200, 30, 5, TFT_NAVY);
                tft.setTextColor(TFT_WHITE, TFT_NAVY);
            }
            tft.drawCentreString(menuOptions[i], 120, y + 7, 2);
        }
        tft.setTextColor(TFT_GREEN, TFT_BLACK);
        tft.drawString("Bot2: Navegar", 10, 190, 1);
        tft.drawString("Bot1: Seleccionar", 120, 190, 1);

        // Esperar pulsación de botón
        bool waiting = true;
        while (waiting) {
            ReadButtons();
            if (buttonPushCounter2 == 1) { // Botón 2: Navegar
                selectedOption = (selectedOption + 1) % 4;
                buttonPushCounter2 = 0;
                waiting = false;
            }
            if (buttonPushCounter1 == 1) { // Botón 1: Seleccionar
                menuActive = false;
                buttonPushCounter1 = 0;
                waiting = false;
            }
            delay(80);
        }
    }

    // Ejecutar acción según opción seleccionada
    switch (selectedOption) {
        case OPTION_VO2_MODE:
            DEMO = 0;
            screenNr = 1;
            showScreen(); // Mostrar pantalla principal del modo VO2
            break;
        case OPTION_DEMO_MODE:
            DEMO = 1;
            demo.currentScreen = 1;
            demo.batteryVoltage = 4.0;
            demo.vo2 = DEMO_REST_VO2;
            demo.vco2 = DEMO_REST_VO2 * DEMO_RQ_REST;
            demo.rq = DEMO_RQ_REST;
            demo.ve = DEMO_VE_REST;
            demo.freq = DEMO_BREATH_REST;
            demo.lastScreenChange = millis();
            demo.lastBatteryUpdate = millis();
            demo.lastDataUpdate = millis() - 10000;
            demo.lastDisplayUpdate = 0;
            demo.needsDisplayUpdate = true;
            demo.testPhase = PHASE_REST;
            demo.testTime = 0;
            demo.testDuration = 20;
            demo.workload = 0;
            demo.hr = DEMO_REST_HR;
            demo.hrMax = 0;
            demo.vo2Max = 0;
            demo.vo2Percent = 0;
            demo.showGrid = true;
            demo.dataPoints = 0;
            demo.protocolType = PROTOCOL_RAMP;
            demo.isPaused = false;
            demo.weight = 75;
            demo.height = 175;
            demo.age = 35;
            demo.gender = 0;
            demo.mets = 1.0;
            drawDemoScreen(demo.currentScreen); // Mostrar la primera pantalla del modo DEMO
            break;
        case OPTION_CALIBRATION:
            showCalibrationMenu(); // Mostrar submenú de calibración
            break;
        case OPTION_SETTINGS:
            GetWeightkg(); // Configurar peso del usuario
            break;
    }
}

void showCarouselMenu() {
    enum MenuOptions {
        OPTION_VO2_MODE = 0,
        OPTION_DEMO_MODE,
        OPTION_CALIBRATION,
        OPTION_SETTINGS,
        OPTION_COUNT
    };

    const char* menuOptions[] = {
        "Modo VO2",
        "Modo Demo",
        "Calibracion",
        "Configuracion"
    };

    const uint16_t menuColors[] = {
        TFT_DARKCYAN,  // Color para "Modo VO2"
        TFT_DARKGREEN, // Color para "Modo Demo"
        TFT_ORANGE,    // Color para "Calibracion"
        TFT_PURPLE     // Color para "Configuracion"
    };

    int selectedOption = 0;
    bool menuActive = true;

    while (menuActive) {
        // Dibujar fondo
        tft.fillScreen(TFT_BLACK);
        tft.fillRect(0, 0, 240, 30, TFT_NAVY); // Barra superior
        tft.setTextColor(TFT_WHITE, TFT_NAVY);
        tft.drawCentreString("VO2Smart", 120, 5, 2);
        tft.fillRoundRect(40, 40, 160, 50, 10, menuColors[selectedOption]);
        tft.setTextColor(TFT_WHITE, menuColors[selectedOption]);
        tft.drawCentreString(menuOptions[selectedOption], 120, 55, 2);
        int prevOption = (selectedOption - 1 + OPTION_COUNT) % OPTION_COUNT;
        int nextOption = (selectedOption + 1) % OPTION_COUNT;
        tft.setTextColor(TFT_LIGHTGREY, TFT_BLACK);
        tft.drawCentreString(menuOptions[prevOption], 40, 110, 1);
        tft.drawCentreString(menuOptions[nextOption], 200, 110, 1);
        tft.setTextColor(TFT_GREEN, TFT_BLACK);
        tft.drawString("Bot2: Navegar", 10, 130, 1);
        tft.drawString("Bot1: Seleccionar", 120, 130, 1);
        bool waiting = true;
        while (waiting) {
            ReadButtons();
            if (buttonPushCounter2 == 1) { // Botón 2: Navegar
                selectedOption = (selectedOption + 1) % OPTION_COUNT;
                buttonPushCounter2 = 0;
                waiting = false;
            }
            if (buttonPushCounter1 == 1) { // Botón 1: Seleccionar
                menuActive = false;
                buttonPushCounter1 = 0;
                waiting = false;
            }
            delay(80);
        }
    }
    // Ejecutar acción según opción seleccionada
    switch (selectedOption) {
        case OPTION_VO2_MODE:
            DEMO = 0;
            screenNr = 1;
            runVO2Mode();
            break;
        case OPTION_DEMO_MODE:
            DEMO = 1;
            demo.currentScreen = 1;
            drawDemoScreen(demo.currentScreen);
            break;
        case OPTION_CALIBRATION:
            showCalibrationMenu();
            break;
        case OPTION_SETTINGS:
            GetWeightkg();
            break;
    }
}

// --- MENÚ DE CALIBRACIÓN ---
void showCalibrationMenu() {
    const char* calibrationOptions[] = {
        "Autocalibracion",
        "Manual con Jeringa"
    };

    const uint16_t calibrationColors[] = {
        TFT_BLUE,    // Color para "Autocalibracion"
        TFT_GREEN   // Color para "Manual con Jeringa"
    };

    int selectedOption = 0;
    bool menuActive = true;

    while (menuActive) {
        // Dibujar fondo
        tft.fillScreen(TFT_BLACK);

        // Dibujar encabezado
        tft.fillRect(0, 0, 240, 30, TFT_NAVY); // Barra superior
        tft.setTextColor(TFT_WHITE, TFT_NAVY);
        tft.drawCentreString("CALIBRACION", 120, 5, 2); // Encabezado centrado

        // Dibujar la opción seleccionada en el centro
        tft.fillRoundRect(40, 40, 160, 50, 10, calibrationColors[selectedOption]); // Rectángulo central
        tft.setTextColor(TFT_WHITE, calibrationColors[selectedOption]);
        tft.drawCentreString(calibrationOptions[selectedOption], 120, 55, 2); // Texto centrado en el rectángulo

        // Dibujar las opciones laterales (previa y siguiente)
        int prevOption = (selectedOption - 1 + 2) % 2;
        int nextOption = (selectedOption + 1) % 2;

        tft.setTextColor(TFT_LIGHTGREY, TFT_BLACK);
        tft.drawCentreString(calibrationOptions[prevOption], 40, 110, 1); // Opción previa (izquierda)
        tft.drawCentreString(calibrationOptions[nextOption], 200, 110, 1); // Opción siguiente (derecha)

        // Indicaciones de navegación
        tft.setTextColor(TFT_GREEN, TFT_BLACK);
        tft.drawString("Bot2: Navegar", 10, 130, 1);
        tft.drawString("Bot1: Seleccionar", 120, 130, 1);

        // Esperar pulsación de botón
        bool waiting = true;
        while (waiting) {
            ReadButtons();
            if (buttonPushCounter2 == 1) { // Botón 2: Navegar
                selectedOption = (selectedOption + 1) % 2;
                waiting = false;
            }
            if (buttonPushCounter1 == 1) { // Botón 1: Seleccionar
                menuActive = false;
                waiting = false;
            }
            delay(80);
        }
    }

    // Ejecutar acción según opción seleccionada
    switch (selectedOption) {
        case 0:
            autoCalibrate(); // Ejecutar calibración automática
            break;
        case 1:
            manualCalibrateWithSyringe(); // Ejecutar calibración manual
            break;
    }
}

// --- BLE ---
void setupBLE() {
    BLEDevice::init("VO2SmartCurvo");
    pServer = BLEDevice::createServer();
    pServer->setCallbacks(new MyServerCallbacks());

    BLEService *pService = pServer->createService(SERVICE_UUID);
    pCharacteristic = pService->createCharacteristic(
        CHARACTERISTIC_UUID,
        BLECharacteristic::PROPERTY_READ | BLECharacteristic::PROPERTY_WRITE | BLECharacteristic::PROPERTY_NOTIFY
    );
    pCharacteristic->addDescriptor(new BLE2902());

    pService->start();

    BLEAdvertising *pAdvertising = BLEDevice::getAdvertising();
    pAdvertising->addServiceUUID(SERVICE_UUID);
    pAdvertising->setScanResponse(true);
    pAdvertising->setMinPreferred(0x06); // Intervalo mínimo (~100ms)
    pAdvertising->setMaxPreferred(0x12); // Intervalo máximo (~200ms)
    BLEDevice::startAdvertising();
    Serial.println("BLE initialized and advertising started.");
}

// Forward declaration to fix 'checkAdvertising' was not declared in this scope
void checkAdvertising();

void StreamBT() {
  //HeaderStreamedBT = 1;// TEST: Deactivation of header
  if (HeaderStreamedBT == 0) {
    SerialBT.print("Time");
    SerialBT.print(",");
    SerialBT.print("VO2");
    SerialBT.print(",");
    SerialBT.print("VO2MAX");
    SerialBT.print(",");
    SerialBT.print("VO2total");
    SerialBT.print(",");
    SerialBT.print("kcal");
    SerialBT.print(",");
    SerialBT.print("Bvol");
    SerialBT.print(",");
    SerialBT.print("VEmin");
    SerialBT.print(",");
    SerialBT.print("Brate");
    SerialBT.print(",");
    SerialBT.print("outO2%");
    SerialBT.print(",");
    SerialBT.println("inO2%");
    HeaderStreamedBT = 1;
  }
  SerialBT.print(float(TotalTime / 1000), 0);
  SerialBT.print(",");
  SerialBT.print(vo2Max);
  SerialBT.print(",");
  SerialBT.print(vo2MaxMax);
  SerialBT.print(",");
  SerialBT.print(vo2Total);
  SerialBT.print(",");
  SerialBT.print(calTotal);
  SerialBT.print(",");
  SerialBT.print(volumeExp);
  SerialBT.print(",");
  SerialBT.print(volumeVEmean);
  SerialBT.print(",");
  SerialBT.print(freqVEmean);
  SerialBT.print(",");
  SerialBT.print(lastO2);
  SerialBT.print(",");
  SerialBT.println(initialO2);
}

// --- ENVÍO DE DATOS BLE CADA SEGUNDO ---
unsigned long lastBLESend = 0;
void sendBLEData() {
    if (deviceConnected && pCharacteristic != nullptr) {
        String dataString = String(float(TotalTime / 1000), 0) + "," +
                            String(vo2Max) + "," +
                            String(vo2MaxMax) + "," +
                            String(vo2Total) + "," +
                            String(calTotal) + "," +
                            String(volumeExp) + "," +
                            String(volumeVEmean) + "," +
                            String(freqVEmean) + "," +
                            String(lastO2) + "," +
                            String(initialO2);
        pCharacteristic->setValue(dataString.c_str());
        pCharacteristic->notify();
    }
}

// --- BOTONES ---
// void ReadButtons() is defined later in the file or in Untitled-1.cpp, so this duplicate is removed.

// --- SPLASH Y BATERÍA ---
void showSplashScreen() {
    tft.fillScreen(TFT_BLACK);

    // Dibujar encabezado
    tft.setTextColor(TFT_CYAN, TFT_BLACK);
    tft.drawCentreString("VO2Smart", 120, 20, 4);

    // Dibujar versión
    tft.setTextColor(TFT_WHITE, TFT_BLACK);
    tft.drawCentreString(Version, 120, 50, 2);

    // Dibujar mensaje de inicio
    tft.drawCentreString("Iniciando...", 120, 80, 2);

    // Dibujar contorno de la barra de progreso
    int barX = 40, barY = 110, barWidth = 160, barHeight = 20;
    tft.drawRect(barX, barY, barWidth, barHeight, TFT_WHITE);

    // Actualizar la barra de progreso
    for (int progress = 0; progress <= barWidth; progress++) {
        tft.fillRect(barX + 1, barY + 1, progress, barHeight - 2, TFT_GREEN);
        delay(20); // Ajusta el tiempo para controlar la velocidad de la barra
    }

    // Breve pausa al completar la barra
    delay(500);
}
void drawBatteryIndicator() {
    int x = 200, y = 5, w = 30, h = 12;
    tft.drawRect(x, y, w, h, TFT_WHITE);
    int fill = map((int)(Battery_Voltage * 100), 330, 420, 0, w - 4);
    fill = constrain(fill, 0, w - 4);
    tft.fillRect(x + 2, y + 2, fill, h - 4, (Battery_Voltage < 3.7) ? TFT_RED : TFT_GREEN);
    tft.setTextColor(TFT_WHITE, TFT_BLACK);
    tft.setCursor(x - 40, y, 2);
    tft.printf("%.2fV", Battery_Voltage);
}

void drawStatusIndicators() {
    // Indicador de estado del sensor de oxígeno
    tft.fillCircle(10, 10, 5, (lastO2 > 0) ? TFT_GREEN : TFT_RED);

    // Indicador de estado del sensor de CO2
    tft.fillCircle(30, 10, 5, (co2perc > 0) ? TFT_GREEN : TFT_RED);

    // Indicador de conexión BLE
    tft.fillCircle(50, 10, 5, deviceConnected ? TFT_BLUE : TFT_RED);
}

// --- FUNCIONES FALTANTES IMPLEMENTADAS ---

void ConvertTime(float ms) {
    long inms = long(ms);
    int h, m, s;
    String strh, strm, strs;
    s = (inms / 1000) % 60;
    m = (inms / 60000) % 60;
    h = (inms / 3600000) % 24;
    strs = String(s);
    if (s < 10) strs = String("0") + strs;
    strm = String(m);
    if (m < 10) strm = String("0") + strm;
    strh = String(h);
    if (h < 10) strh = String("0") + strh;
    TotalTimeMin = String(strh) + String(":") + String(strm) + String(":") + String(strs);
}

void ReadButtons() {
    static int lastState1 = HIGH, lastState2 = HIGH;
    int state1 = digitalRead(buttonPin1);
    int state2 = digitalRead(buttonPin2);

    if (state1 == LOW && lastState1 == HIGH) {
        buttonPushCounter1++;
    } else if (state1 == HIGH) {
        buttonPushCounter1 = 0;
    }
    lastState1 = state1;

    if (state2 == LOW && lastState2 == HIGH) {
        buttonPushCounter2++;
    } else if (state2 == HIGH) {
        buttonPushCounter2 = 0;
    }
    lastState2 = state2;
}

void handleVO2Navigation() {
    if (buttonPushCounter1 == 1) {
        screenNr--;
        if (screenNr < 1) screenNr = 5; // Ajustar al número total de pantallas
        showScreen();
    }

    if (buttonPushCounter2 == 1) {
        screenNr++;
        if (screenNr > 5) screenNr = 1; // Ajustar al número total de pantallas
        showScreen();
    }
}

void handleDemoNavigation() {
    ReadButtons();

    // Botón 1: Cambiar a la siguiente pantalla
    if (buttonPushCounter1 == 1) {
        demo.currentScreen = (demo.currentScreen % 6) + 1; // Cambiado de 4 a 6
        drawDemoScreen(demo.currentScreen);
    }

    // Botón 2: Pausar o continuar la simulación
    if (buttonPushCounter2 == 1) {
        demo.isPaused = !demo.isPaused;
        tft.fillRoundRect(70, 80, 100, 40, 10, demo.isPaused ? TFT_ORANGE : TFT_GREEN);
        tft.setTextColor(TFT_WHITE, demo.isPaused ? TFT_ORANGE : TFT_GREEN);
        tft.drawCentreString(demo.isPaused ? "PAUSADO" : "CONTINUA", 120, 90, 2);
    }
}

void autoCalibrate() {
    // Ejemplo simple: promediar 50 lecturas de O2 y ajustar factor de corrección
    float o2Sum = 0;
    for (int i = 0; i < 50; i++) {
        o2Sum += Oxygen.ReadOxygenData(COLLECT_NUMBER);
        delay(100);
    }
    float o2Mean = o2Sum / 50.0f;
    if (abs(o2Mean - 20.9) < 1.0) {
        settings.correctionSensor = 20.9f / o2Mean;
        saveSettings();
        tft.fillScreen(TFT_GREEN);
        tft.drawCentreString("CALIBRACION EXITOSA", 120, 55, 4);
        delay(2000);
    } else {
        tft.fillScreen(TFT_RED);
        tft.drawCentreString("CALIBRACION FALLIDA", 120, 55, 4);
        delay(2000);
    }
}

void manualCalibrateWithSyringe() {
    tft.fillScreen(TFT_BLUE);
    tft.setTextColor(TFT_WHITE, TFT_BLUE);
    tft.drawCentreString("INSERT 3L SYRINGE", 120, 30, 4);
    while (digitalRead(buttonPin1) == HIGH) { delay(20); }
    if (isnan(mySensor.getPressure())) {
        tft.fillScreen(TFT_RED);
        tft.drawCentreString("ERROR: SENSOR PRESION", 120, 55, 4);
        delay(2000);
        return;
    }
    tft.fillScreen(TFT_YELLOW);
    tft.drawCentreString("INJECTING...", 120, 30, 4);
    float startTime = millis();
    volumeTotal = 0;
    while (millis() - startTime < CALIB_TIMEOUT_MS) {
        VolumeCalc();
        int progress = map(volumeTotal * 1000, 0, SYRINGE_VOLUME, 0, 200);
        tft.fillRect(21, 61, progress, 18, TFT_GREEN);
        if (volumeTotal * 1000 >= SYRINGE_VOLUME) break;
        delay(CALIB_UPDATE_INTERVAL_MS);
    }
    float error = abs(volumeTotal * 1000 - SYRINGE_VOLUME) / SYRINGE_VOLUME * 100.0;
    if (error <= CALIB_ALLOWED_ERROR) {
        tft.fillScreen(TFT_GREEN);
        tft.setTextColor(TFT_WHITE, TFT_GREEN);
        tft.drawCentreString("CALIBRACION EXITOSA", 120, 55, 4);
        tft.drawCentreString("Error: " + String(error, 2) + "%", 120, 90, 2);
        settings.correctionSensor *= (SYRINGE_VOLUME / (volumeTotal * 1000));
        saveSettings();
    } else {
        tft.fillScreen(TFT_RED);
        tft.setTextColor(TFT_WHITE, TFT_RED);
        tft.drawCentreString("CALIBRACION FALLIDA", 120, 55, 4);
        tft.drawCentreString("Error: " + String(error, 2) + "%", 120, 90, 2);
    }
    delay(3000);
}

void calibrateFlowSensor() {
    tft.fillScreen(TFT_BLACK);
    tft.setTextColor(TFT_WHITE, TFT_BLACK);
    tft.drawCentreString("Calibrando flujo...", 120, 50, 2);

    volumeTotal2 = 0; // Reiniciar volumen total
    TimerStart = millis();
    TimerVolCalc = millis();

    while ((millis() - TimerStart) < 10000) { // Calibración durante 10 segundos
        float R = 287.05;
        float tempK = TempC + 273.15;
        rho = PresPa / (R * tempK);
        rhoBTPS = PresPa / (292.9 * (35 + 273.15));
    }
}

/**
 * Cálculo optimizado de volumen respiratorio usando tubo Venturi
 * Implementa la ecuación de Bernoulli con correcciones de densidad
 * 
 * Ecuación base del Venturi:
 * Q = A₂ × √(2ΔP / ρ × (1/(A₂/A₁)² - 1))
 * Donde:
 * - Q: Flujo volumétrico (m³/s)
 * - A₁, A₂: Áreas de entrada y garganta del Venturi
 * - ΔP: Presión diferencial medida
 * - ρ: Densidad del aire
 */
void VolumeCalc() {
    static unsigned long lastValidReading = 0;
    static float lastValidPressure = 0;
    
    // Protección con mutex para datos compartidos
    if (sensorDataMutex == NULL) {
        sensorDataMutex = xSemaphoreCreateMutex();
    }
    
    if (!xSemaphoreTake(sensorDataMutex, pdMS_TO_TICKS(50))) {
        logSensorError("VolumeCalc", 0, "Timeout mutex volumen");
        return;
    }
    
    // Leer presión diferencial del sensor Omron
    float pressureraw = mySensor.getPressure();
    
    // Validar lectura del sensor
    if (!isValidPressureReading(pressureraw)) {
        sensorErrors.pressureErrors++;
        sensorErrors.lastPressureErrorTime = millis();
        
        // Usar último valor válido si es reciente (< 2 segundos)
        if (millis() - lastValidReading < 2000) {
            pressureraw = lastValidPressure;
            Serial.println("Usando última presión válida por error de sensor");
        } else {
            // Asumir flujo cero si no hay lecturas válidas recientes
            pressureraw = 0;
        }
    } else {
        lastValidReading = millis();
        lastValidPressure = pressureraw;
    }
    
    // Aplicar filtro de promedio móvil para suavizar fluctuaciones
    pressure = (pressure * 0.5) + (pressureraw * 0.5);
    
    // Asegurar que la presión no sea negativa (físicamente imposible en este contexto)
    if (pressure < 0) pressure = 0;
    
    // ============================================================================
    // DETECCIÓN Y PROCESAMIENTO DE CICLOS RESPIRATORIOS
    // ============================================================================
    
    /**
     * Lógica de detección de expiración:
     * - Cuando la presión cae por debajo del umbral después de haber estado alta
     * - Se considera el final de una espiración
     */
    if (pressure < pressThreshold && readVE == 1) {
        // Fin de espiración detectado
        readVE = 0;
        DurationVE = millis() - TimerVE;
        TimerVE = millis();
        
        // Calcular volumen espiratorio individual
        volumeExp = volumeTotal;
        volumeTotal = 0; // Reset para próximo ciclo
        
        // Validar duración del ciclo respiratorio (150ms - 10s son fisiológicos)
        if (DurationVE > 150 && DurationVE < 10000) {
            // Calcular ventilación por minuto
            volumeVE = (volumeExp / 1000.0) * (60000.0 / DurationVE); // L/min
            
            // Aplicar filtro de promedio móvil ponderado para VE
            volumeVEmean = (volumeVEmean * 0.75) + (volumeVE * 0.25);
            
            // Validar y limitar VE a rangos fisiológicos
            if (volumeVEmean < 0.5) volumeVEmean = 0; // Eliminar ruido
            if (volumeVEmean > 200.0) { // Límite superior fisiológico
                logSensorError("VE", volumeVEmean, "Ventilación excesiva");
                volumeVEmean = 200.0;
            }
            
            // Calcular frecuencia respiratoria
            freqVE = 60000.0 / DurationVE; // respiraciones por minuto
            
            // Validar frecuencia respiratoria (5-60 rpm son normales)
            if (freqVE >= 5.0 && freqVE <= 60.0) {
                freqVEmean = (freqVEmean * 0.75) + (freqVE * 0.25);
            } else {
                logSensorError("FreqResp", freqVE, "Frecuencia respiratoria anormal");
            }
        } else {
            // Duración de ciclo anormal - posible ruido
            logSensorError("CicloResp", DurationVE, "Duración ciclo anormal");
        }
        
        // Convertir volumen espiratorio a litros para display
        volumeExp = volumeExp / 1000.0;
        
        // Log detallado cada 10 respiraciones para monitoreo
        static int breathCount = 0;
        if (++breathCount >= 10 && VERBOSE) {
            Serial.printf("Resp: VE=%.1f L/min, Freq=%.1f rpm, Vol=%.3f L\n", 
                         volumeVEmean, freqVEmean, volumeExp);
            breathCount = 0;
        }
    }
    
    // Reset automático si pasa mucho tiempo sin respiración detectada
    if (millis() - TimerVE > 5000) {
        readVE = 1; // Permitir nueva detección
        if (volumeVEmean > 1.0) {
            // Degradar gradualmente VE si no hay actividad
            volumeVEmean *= 0.95;
            freqVEmean *= 0.95;
        }
    }
    
    // ============================================================================
    // CÁLCULO DE FLUJO USANDO ECUACIÓN DE VENTURI
    // ============================================================================
    
    if (pressure >= pressThreshold) {
        /**
         * Ecuación de Bernoulli aplicada al Venturi:
         * 
         * Q = Cd × A₂ × √(2ΔP / ρ × (1 - (A₂/A₁)²))
         * 
         * Simplificada para nuestro Venturi específico:
         * massFlow = 1000 × √(2ΔP × ρ / (1/A₂² - 1/A₁²))
         * 
         * Factor 1000: conversión de m³/s a L/s
         */
        
        // Verificar que la densidad del aire sea válida
        if (rho <= 0 || rho > 2.0) {
            logSensorError("Densidad", rho, "Densidad aire inválida");
            rho = 1.225; // Usar densidad estándar del aire
        }
        
        // Calcular flujo másico usando ecuación de Venturi
        float denominatorVenturi = (1.0 / pow(area_2, 2)) - (1.0 / pow(area_1, 2));
        if (denominatorVenturi <= 0) {
            logSensorError("Venturi", denominatorVenturi, "Error configuración áreas");
            xSemaphoreGive(sensorDataMutex);
            return;
        }
        
        massFlow = 1000.0 * sqrt((abs(pressure) * 2.0 * rho) / denominatorVenturi);
        
        // Convertir flujo másico a volumétrico
        volFlow = massFlow / rho;
        
        // Aplicar factor de corrección de calibración
        volFlow = volFlow * settings.correctionSensor;
        
        // Validar flujo calculado
        if (volFlow < 0 || volFlow > 15.0) { // 15 L/s es un límite superior razonable
            logSensorError("Flujo", volFlow, "Flujo calculado fuera de rango");
            volFlow = constrain(volFlow, 0, 15.0);
        }
        
        // Integrar volumen usando tiempo transcurrido
        float deltaTime = millis() - TimerVolCalc;
        if (deltaTime > 0 && deltaTime < 1000) { // Validar delta tiempo razonable
            float volumeIncrement = volFlow * (deltaTime / 1000.0); // L/s × s = L
            
            volumeTotal += volumeIncrement;
            volumeTotal2 += volumeIncrement;
            
            // Limitar acumulación para evitar overflow
            if (volumeTotal > 50.0) { // 50L es un volumen muy alto por respiración
                logSensorError("VolTotal", volumeTotal, "Volumen acumulado excesivo");
                volumeTotal = 50.0;
            }
        }
    }
    
    // Actualizar timer para próxima iteración
    TimerVolCalc = millis();
    
    // Detectar volúmenes espiratorios grandes para análisis
    if ((volumeTotal2 - volumeTotalOld) > 0.2) { // 200ml es significativo
        expiratVol = (volumeTotal2 - volumeTotalOld); // Ya en litros
        volumeTotalOld = volumeTotal2;
        
        // Validar volumen espiratorio individual
        if (expiratVol > 8.0) { // 8L es extremadamente alto
            logSensorError("VolEspiratorio", expiratVol, "Volumen espiratorio excesivo");
            expiratVol = constrain(expiratVol, 0, 8.0);
        }
    }
    
    xSemaphoreGive(sensorDataMutex);
}

void handleBLEConnection() {
    // Ejemplo: no hace nada, placeholder para lógica BLE
}

void showBLEStatus() {
    // Ejemplo: muestra estado BLE en pantalla
    tft.setCursor(180, 0, 2);
    if (deviceConnected) {
        tft.setTextColor(TFT_GREEN, TFT_BLACK);
        tft.print("BLE OK");
    } else {
        tft.setTextColor(TFT_RED, TFT_BLACK);
        tft.print("BLE OFF");
    }
}

void showScreen() {
    ConvertTime(TotalTime);
    tft.setRotation(1);
    switch (screenNr) {
        case 1: tftScreen1(); break;
        case 2: tftScreen2(); break;
        case 3: tftScreen3(); break;
        case 4: tftScreen4(); break;
        case 5: tftScreen5(); break;
        case 6: tftParameters(); break;
        default: tftScreen1(); break;
    }
}

// --- FUNCIONES FALTANTES Y/O COMENTADAS ---

// --- FUNCIONES INTEGRADAS DESDE Untitled-1.cpp ---

void fnCalAir() {
    tft.fillScreen(TFT_BLACK);
    tft.setTextColor(TFT_WHITE, TFT_BLACK);
    tft.setCursor(0, 5, 4);
    tft.println("Usa 3L calib");
    tft.setCursor(0, 30, 4);
    tft.println("for sensor check.");
    tft.setCursor(0, 105, 4);
    tft.setTextColor(TFT_GREEN, TFT_BLACK);
    tft.println("Presione para iniciar >>>");
    while (digitalRead(buttonPin1));
    TimerStart = millis();
    volumeTotal2 = 0;
    do {
        VolumeCalc();
        tft.setTextColor(TFT_GREEN, TFT_BLACK);
        tft.setCursor(0, 5, 4);
        tft.println("Total Volume (ml):");
        tft.setTextColor(TFT_WHITE, TFT_BLACK);
        tft.setCursor(0, 55, 7);
        tft.println(volumeTotal2, 0);
        tft.setCursor(0, 105, 4);
        tft.print("Tiempo: ");
        tft.print((millis() - TimerStart) / 1000, 1);
    } while ((millis() - TimerStart) < 10000);
    settings.correctionSensor = 3000 / volumeTotal2;
    saveSettings();
}

void fnCalO2() {
    Oxygen.Calibrate(20.9, 0.0);
    showParameters();
}

void tftScreen1() {
    tft.fillScreen(TFT_BLACK); // Limpia la pantalla antes de dibujar
    tft.setTextColor(TFT_GREEN, TFT_BLACK);
    tft.setCursor(5, 5, 4);
    tft.print("Time  ");
    tft.setCursor(120, 5, 4);
    tft.setTextColor(TFT_RED, TFT_BLACK);
    tft.println(TotalTimeMin);

    tft.setTextColor(TFT_GREEN, TFT_BLACK);
    tft.setCursor(5, 30, 4);
    tft.print("VO2 ");
    tft.setCursor(120, 30, 4);
    tft.println(isnan(vo2Max) ? String("--") : String(vo2Max));

    tft.setCursor(5, 55, 4);
    tft.print("VO2MAX ");
    tft.setCursor(120, 55, 4);
    tft.println(isnan(vo2MaxMax) ? String("--") : String(vo2MaxMax));

    tft.setCursor(5, 80, 4);
    tft.print("VO2total ");
    tft.setCursor(120, 80, 4);
    tft.println(isnan(vo2Total) ? String("--") : String(vo2Total, 0));

    tft.setCursor(5, 105, 4);
    tft.print("kcal ");
    tft.setCursor(120, 105, 4);
    tft.println(isnan(calTotal) ? String("--") : String(calTotal, 0));
}

void tftScreen2() {
    tft.fillScreen(TFT_BLACK);
    if (DEMO) {
        tft.setTextColor(TFT_YELLOW, TFT_BLACK);
        tft.drawString("DEMO", 5, 5, 2);
    }
    tft.setTextColor(TFT_GREEN, TFT_BLACK);
    tft.setCursor(5, 5, 4);
    tft.print("Time  ");
    tft.setCursor(120, 5, 4);
    tft.setTextColor(TFT_RED, TFT_BLACK);
    tft.println(TotalTimeMin);
    tft.setTextColor(TFT_GREEN, TFT_BLACK);
    tft.setCursor(5, 30, 4);
    tft.print("kcal ");
    tft.setCursor(120, 30, 4);
    tft.println(calTotal, 0);
    tft.setCursor(5, 55, 4);
    tft.print("kcal/h ");
    tft.setCursor(120, 55, 4);
    tft.println(vo2CalH, 0);
    drawBatteryIndicator();
}

void tftScreen3() {
    tft.fillScreen(TFT_BLACK);
    if (DEMO) {
        tft.setTextColor(TFT_YELLOW, TFT_BLACK);
                      tft.drawString("DEMO", 5, 5, 2);
    }
    tft.setTextColor(TFT_GREEN, TFT_BLACK);
    tft.setCursor(5, 5, 4);
    tft.print("Time  ");
    tft.setCursor(120, 5, 4);
    tft.setTextColor(TFT_RED, TFT_BLACK);
    tft.println(TotalTimeMin);
    tft.setTextColor(TFT_GREEN, TFT_BLACK);
    tft.setCursor(5, 30, 4);
    tft.print("Bvol ");
    tft.setCursor(120, 30, 4);
    tft.println(volumeExp);
    tft.setCursor(5,  55, 4);
    tft.print("VEmin ");
    tft.setCursor(120, 55, 4);
    tft.println(volumeVEmean, 1);
    tft.setCursor(5, 80, 4);
       tft.print("Brate ");
    tft.setCursor(120,  80, 4);
    tft.println(freqVEmean, 1);
    tft.setCursor(5, 105, 4);
    tft.print("O2%diff ");
    tft.setCursor(120, 105, 4);
    float co2diff = lastO2 - initialO2;
    tft.println(co2diff);
    drawBatteryIndicator();
}

void tftScreen4() {
    tft.fillScreen(TFT_BLACK);
    if (DEMO) {
        tft.setTextColor(TFT_YELLOW, TFT_BLACK);
        tft.drawString("DEMO", 5, 5, 2);
    }
    tft.setTextColor(TFT_GREEN, TFT_BLACK);
    tft.setCursor(5, 5, 4);
    tft.print("Time ");
    tft.setCursor(120, 5, 4);
    tft.setTextColor(TFT_RED, TFT_BLACK);
       tft.println(TotalTimeMin);
    tft.setTextColor(TFT_GREEN, TFT_BLACK);
    tft.setCursor(5, 30, 4);
    tft.print("O2% ");
    tft.setCursor(120, 30, 4);
    tft.println(lastO2);
    tft.setCursor(5, 55, 4);
    tft.print("CO2 ");
    tft.setCursor(120, 55, 4);
    tft.println(co2perc * 100, 1);
    tft.setCursor(5, 80, 4);
    tft.print("Temp ");
    tft.setCursor(120, 80, 4);
    tft.println(TempC, 1);
    tft.setCursor(5, 105, 4);
    tft.print("Humidity ");
    tft.setCursor(120, 105, 4);
    tft.println(co2hum, 0);
    drawBatteryIndicator();
}

void tftScreen5() {
    tft.fillScreen(TFT_BLACK);
    if (DEMO) {
        tft.setTextColor(TFT_YELLOW, TFT_BLACK);
        tft.drawString("DEMO", 5, 5, 2);
    }
    tft.setTextColor(TFT_GREEN, TFT_BLACK);
    tft.setCursor(5, 5, 4);
    tft.print("Time  ");
    tft.setCursor(120, 5, 4);
    tft.setTextColor(TFT_RED, TFT_BLACK);
    tft.println(TotalTimeMin);
    tft.setTextColor(TFT_GREEN, TFT_BLACK);
    tft.setCursor(5, 30, 4);
    tft.print("VO2 ");
    tft.setTextColor(TFT_WHITE, TFT_BLACK);
    tft.setCursor(90, 30, 7);
    tft.println(vo2Max);
    tft.setTextColor(TFT_GREEN, TFT_BLACK);
    tft.setCursor(5, 80, 4);
    tft.print("RQ ");
    tft.setTextColor(TFT_WHITE, TFT_BLACK);
    tft.setCursor(90, 80, 7);
    tft.println(respq);
    drawBatteryIndicator();
}

void tftParameters() {
    tft.fillScreen(TFT_BLUE);
    tft.setTextColor(TFT_WHITE, TFT_BLUE);
    tft.setCursor(5, 5, 4);
    tft.print("*C");
    tft.setCursor(120, 5, 4);
    tft.println(co2temp, 1);
    tft.setCursor(5, 30, 4);
    tft.print("hPA");
    tft.setCursor(120, 30, 4);
    tft.println((PresPa / 100));
    tft.setCursor(5, 55, 4);
    tft.print("kg/m3");
    tft.setCursor(120, 55, 4);
    tft.println(rho, 4);
    tft.setCursor(5, 80, 4);
    tft.print("kg");
    tft.setCursor(45, 80, 4);
    tft.println(settings.weightkg, 1);
    tft.setCursor(120, 80, 4);
    tft.print("cor");
    tft.setCursor(180, 80, 4);
    tft.println(settings.correctionSensor, 2);
    tft.setCursor(5, 105, 4);
    tft.print("inO2%");
    tft.setCursor(120, 105, 4);
    tft.println(initialO2);
    drawBatteryIndicator();
}

/**
 * Lectura mejorada del sensor de CO2 con validación y recuperación
 * Implementa detección de condiciones peligrosas y filtrado adaptativo
 */
void readCO2() {
    static int errorCount = 0;
    static unsigned long lastSuccessfulReading = 0;
    
    // Verificar si el sensor está habilitado
    if (!settings.co2_on) return;
    
    // Protección con mutex
    if (sensorDataMutex == NULL) {
        sensorDataMutex = xSemaphoreCreateMutex();
    }
    
    if (xSemaphoreTake(sensorDataMutex, pdMS_TO_TICKS(50))) {
        float result[3] = {0}; // [CO2, Temperatura, Humedad]
        
        // Intentar lectura del sensor SCD30
        if (!scd30.getCarbonDioxideConcentration(result)) {
            errorCount++;
            sensorErrors.co2Errors++;
            sensorErrors.lastCO2ErrorTime = millis();
            
            logSensorError("CO2", 0, "Fallo comunicación SCD30");
            
            if (errorCount > SENSOR_ERROR_THRESHOLD) {
                settings.co2_on = false;
                showError("CO2 sensor desactivado", false);
                Serial.println("Desactivando CO2 por fallos repetidos");
            }
            
            xSemaphoreGive(sensorDataMutex);
            return;
        }
        
        // Validar cada componente de la lectura
        if (!isValidCO2Reading(result[0]) || 
            !isValidTemperatureReading(result[1]) ||
            isnan(result[2])) {
            
            errorCount++;
            
            // Usar último valor válido si está disponible y es reciente
            if (millis() - lastSuccessfulReading < 10000) { // 10 segundos
                Serial.printf("Usando último CO2 válido: %.0f ppm (errores: %d)\n", 
                             co2ppm, errorCount);
            } else {
                // Degradar hacia valor ambiente
                co2ppm = co2ppm * 0.95 + CO2_AMBIENT_TYPICAL * 0.05;
                logSensorError("CO2", co2ppm, "Degradando hacia valor ambiente");
            }
            
            xSemaphoreGive(sensorDataMutex);
            return;
        }
        
        // Lecturas válidas: procesar datos
        errorCount = 0;
        lastSuccessfulReading = millis();
        
        // Aplicar filtro Kalman adaptativo para CO2
        float filteredCO2 = filtroCO2.filtrar(result[0]);
        
        // Verificación de seguridad crítica para CO2
        if (filteredCO2 >= 40000) { // 4% es peligroso
            showError("CO2 LIMITE CRITICO!", true);
            logSensorError("CO2", filteredCO2, "Nivel crítico detectado");
            
            // En modo real, podríamos activar alarmas adicionales aquí
            tft.setTextColor(TFT_WHITE, TFT_RED);
            tft.drawCentreString("VENTILE AREA!", 120, 100, 4);
        }
        
        // Actualizar valores globales
        co2ppm = filteredCO2;
        
        // Establecer valor inicial si es la primera lectura válida
        if (initialCO2 == 0) {
            initialCO2 = co2ppm;
        }
        
        // Convertir a porcentaje (ppm/10000)
        co2perc = co2ppm / 10000.0;
        
        // Actualizar temperatura y humedad del sensor CO2
        co2temp = result[1];
        co2hum = result[2];
        
        // Modo demo: usar valores simulados
        if (DEMO) {
            co2ppm = 30000; // Valor fijo para demo
            co2perc = 3.0;  // 3% para demo
        }
        
        xSemaphoreGive(sensorDataMutex);
        
        // Log periódico para monitoreo (cada 30 segundos)
        static unsigned long lastLogTime = 0;
        if (millis() - lastLogTime > 30000) {
            Serial.printf("CO2: %.0f ppm (%.1f%%), Temp: %.1f°C, Hum: %.0f%%\n", 
                         co2ppm, co2perc * 100, co2temp, co2hum);
            lastLogTime = millis();
        }
        
    } else {
        logSensorError("CO2", 0, "Timeout mutex - lectura omitida");
    }
}

/**
 * Lectura mejorada del sensor de oxígeno con validación robusta
 * Implementa filtrado Kalman, detección de errores y recuperación automática
 */
void ReadO2() {
    static int errorCount = 0;
    static unsigned long lastSuccessfulReading = 0;
    
    // Protección con mutex para acceso a datos compartidos
    if (sensorDataMutex == NULL) {
        sensorDataMutex = xSemaphoreCreateMutex();
    }
    
    if (xSemaphoreTake(sensorDataMutex, pdMS_TO_TICKS(50))) {
        float oxygenData = Oxygen.ReadOxygenData(COLLECT_NUMBER);
        
        // Validación robusta con función específica para O2
        if (!isValidO2Reading(oxygenData)) {
            errorCount++;
            sensorErrors.o2Errors++;
            sensorErrors.lastO2ErrorTime = millis();
            
            // Estrategia de recuperación progresiva
            if (errorCount > SENSOR_ERROR_THRESHOLD) {
                // Intentar reinicialización del sensor
                if (!Oxygen.begin(Oxygen_IICAddress)) {
                    logSensorError("O2", oxygenData, "Fallo reinicialización sensor");
                    
                    // Usar último valor válido con degradación temporal
                    if (millis() - lastSuccessfulReading < 30000) { // 30 segundos
                        // Mantener último valor válido
                        Serial.println("Usando último valor O2 válido por fallo sensor");
                    } else {
                        // Usar valor por defecto seguro después de 30s
                        lastO2 = O2_AMBIENT_TYPICAL;
                        logSensorError("O2", lastO2, "Usando valor por defecto por fallo prolongado");
                    }
                    
                    xSemaphoreGive(sensorDataMutex);
                    return;
                }
                errorCount = 0; // Reset si la reinicialización fue exitosa
            } else {
                // Para errores menores, usar interpolación con último valor válido
                if (millis() - lastSuccessfulReading < 5000) { // 5 segundos
                    // Mantener último valor válido temporalmente
                    Serial.printf("Manteniendo último O2 válido: %.2f%% (errores: %d)\n", 
                                 lastO2, errorCount);
                } else {
                    // Degradar hacia valor ambiente gradualmente
                    lastO2 = lastO2 * 0.9 + O2_AMBIENT_TYPICAL * 0.1;
                }
            }
            
            xSemaphoreGive(sensorDataMutex);
            return;
        }
        
        // Lectura válida: aplicar filtro Kalman optimizado
        errorCount = 0;
        lastSuccessfulReading = millis();
        
        // Filtro Kalman con parámetros adaptativos según condiciones
        float filteredO2;
        if (TotalTime < 10000) {
            // Filtrado más agresivo durante los primeros 10 segundos (inicialización)
            static FiltroKalman filtroO2Init(0.8, 0.2);
            filteredO2 = filtroO2Init.filtrar(oxygenData);
        } else {
            // Filtrado normal durante operación
            filteredO2 = filtroO2.filtrar(oxygenData);
        }
        
        // Actualizar valores globales con protección
        lastO2 = filteredO2;
        
        // Actualizar O2 inicial si es necesario (solo en condiciones estables)
        if (pressure < 0.2 && filteredO2 > initialO2 && TotalTime < 30000) {
            initialO2 = filteredO2;
        }
        
        // Modo demo: simular consumo de O2
        if (DEMO) {
            lastO2 = initialO2 - 4; // Simulación fija para demo
        }
        
        // Calcular diferencia de CO2 equivalente (para compatibilidad)
        co2 = initialO2 - lastO2;
        if (co2 < 0) co2 = 0; // Asegurar que no sea negativo
        
        xSemaphoreGive(sensorDataMutex);
    } else {
        // No se pudo obtener mutex: log pero no bloquear
        logSensorError("O2", 0, "Timeout mutex - lectura omitida");
    }
}

/**
 * Cálculo optimizado de VO2 máximo con validación robusta
 * Implementa las ecuaciones estándar con correcciones STPD/BTPS
 * 
 * Fórmula base: VO2 = VE × (FiO2 - FeO2) × densidad_correction
 * Donde:
 * - VE: Ventilación minuto (L/min)
 * - FiO2: Fracción inspirada de O2 (inicial)
 * - FeO2: Fracción espirada de O2 (medida)
 * - densidad_correction: Factor de corrección BTPS/STPD
 */
void vo2maxCalc() {
    if (DEMO) return; // Salir temprano en modo demo
    
    // Protección con mutex para cálculos críticos
    if (calculationMutex == NULL) {
        calculationMutex = xSemaphoreCreateMutex();
    }
    
    if (!xSemaphoreTake(calculationMutex, pdMS_TO_TICKS(100))) {
        logSensorError("VO2Calc", 0, "Timeout mutex cálculo");
        return;
    }
    
    // Leer sensores con validación
    ReadO2();
    AirDensity();
    
    // Validación de prerrequisitos para cálculo válido
    if (!isValidO2Reading(lastO2)) {
        Serial.println("O2 inválido - omitiendo cálculo VO2");
        xSemaphoreGive(calculationMutex);
        return;
    }
    
    if (!isValidTemperatureReading(TempC) || !validateSensorData(PresPa, ATMOSPHERIC_PRESSURE_MIN, ATMOSPHERIC_PRESSURE_MAX, "PresionAtm")) {
        Serial.println("Condiciones ambientales inválidas - omitiendo cálculo VO2");
        xSemaphoreGive(calculationMutex);
        return;
    }
    
    // Validar ventilación mínima para cálculo meaningful
    if (volumeVEmean < 1.0) { // L/min mínimo
        Serial.println("Ventilación insuficiente para cálculo VO2");
        xSemaphoreGive(calculationMutex);
        return;
    }
    
    // Calcular diferencia de O2 con validación fisiológica
    co2 = initialO2 - lastO2;
    if (co2 < 0) {
        co2 = 0; // No puede ser negativo
    } else if (co2 > 10.0) {
        // Diferencia muy alta es sospechosa
        logSensorError("VO2Calc", co2, "Diferencia O2 excesiva");
        co2 = constrain(co2, 0, 10.0); // Limitar a valores fisiológicos
    }
    
    // ============================================================================
    // CÁLCULO PRINCIPAL DE VO2 CON CORRECCIONES ESTÁNDAR
    // ============================================================================
    
    /**
     * Corrección de densidad del aire:
     * - rhoBTPS: Condiciones corporales (37°C, saturado de vapor)
     * - rhoSTPD: Condiciones estándar (0°C, seco, 760 mmHg)
     * Factor de corrección = rhoBTPS / rhoSTPD
     */
    float densityCorrection = rhoBTPS / rhoSTPD;
    
    /**
     * Cálculo de VO2 total (ml/min):
     * VO2 = VE × (FiO2 - FeO2) × factor_densidad × factor_conversión
     * - Multiplicador 10: conversión de % a fracción decimal y ajuste unidades
     */
    float vo2TotalRaw = volumeVEmean * densityCorrection * co2 * 10.0;
    
    // Validación del resultado bruto
    if (!validateSensorData(vo2TotalRaw, 0, 10000, "VO2Total")) {
        Serial.printf("VO2 total calculado inválido: %.2f ml/min\n", vo2TotalRaw);
        xSemaphoreGive(calculationMutex);
        return;
    }
    
    // Aplicar filtro Kalman optimizado para VO2 total
    vo2Total = filtroVolumen.filtrar(vo2TotalRaw);
    
    /**
     * Cálculo de VO2 relativo (ml/kg/min):
     * Normalización por peso corporal para comparación estándar
     */
    if (settings.weightkg <= 0) {
        logSensorError("VO2Calc", settings.weightkg, "Peso corporal inválido");
        xSemaphoreGive(calculationMutex);
        return;
    }
    
    float vo2MaxRaw = vo2Total / settings.weightkg;
    
    // Validación fisiológica del VO2/kg
    if (!validateSensorData(vo2MaxRaw, VO2_MIN_PHYSIOLOGICAL, VO2_MAX_PHYSIOLOGICAL, "VO2perKg")) {
        Serial.printf("VO2/kg fuera de rango fisiológico: %.2f ml/kg/min\n", vo2MaxRaw);
        xSemaphoreGive(calculationMutex);
        return;
    }
    
    // Aplicar filtro Kalman para VO2/kg con parámetros adaptativos
    if (TotalTime < 60000) { // Primeros 60 segundos: filtrado más suave
        static FiltroKalman filtroVO2Init(0.1, 0.5);
        vo2Max = filtroVO2Init.filtrar(vo2MaxRaw);
    } else {
        vo2Max = filtroVO2.filtrar(vo2MaxRaw);
    }
    
    // Actualizar máximo histórico con validación temporal
    if (vo2Max > vo2MaxMax && TotalTime > 30000) { // Solo después de 30s de estabilización
        vo2MaxMax = vo2Max;
        Serial.printf("Nuevo VO2 máximo: %.2f ml/kg/min\n", vo2MaxMax);
    }
    
    // ============================================================================
    // CÁLCULO DE GASTO ENERGÉTICO
    // ============================================================================
    
    /**
     * Conversión a calorías usando equivalente calórico del oxígeno:
     * 1 L O2 ≈ 4.86 kcal (valor promedio para RQ mixto)
     * Fórmula: kcal/min = (VO2_total / 1000) × 4.86
     */
    vo2Cal = (vo2Total / 1000.0) * 4.86;
    
    // Validar cálculo calórico
    if (vo2Cal < 0 || vo2Cal > 50.0) { // Límites fisiológicos razonables
        logSensorError("Calorias", vo2Cal, "Gasto calórico fuera de rango");
        vo2Cal = constrain(vo2Cal, 0, 50.0);
    }
    
    // Integrar calorías totales usando tiempo transcurrido
    if (TimerVO2diff > 0) {
        float calIncrement = vo2Cal * (TimerVO2diff / 60000.0); // Convertir ms a min
        calTotal += calIncrement;
        
        // Calcular gasto energético por hora
        vo2CalH = vo2Cal * 60.0; // kcal/hora
        
        // Log periódico del gasto energético
        static unsigned long lastEnergyLog = 0;
        if (millis() - lastEnergyLog > 60000) { // Cada minuto
            Serial.printf("Energía: %.1f kcal/min, %.0f kcal/h, Total: %.1f kcal\n", 
                         vo2Cal, vo2CalH, calTotal);
            lastEnergyLog = millis();
        }
    }
    
    xSemaphoreGive(calculationMutex);
    
    // Log de depuración detallado (solo cada 30 segundos para no saturar)
    static unsigned long lastDetailedLog = 0;
    if (millis() - lastDetailedLog > 30000 && VERBOSE) {
        Serial.printf("VO2 Detalle: VE=%.1f L/min, O2diff=%.2f%%, VO2=%.1f ml/kg/min, Max=%.1f\n",
                     volumeVEmean, co2, vo2Max, vo2MaxMax);
        lastDetailedLog = millis();
    }
}

void showParameters() {
    while (digitalRead(buttonPin2)) {
        AirDensity();
        tftParameters();
        tft.setCursor(220, 5, 4);
        tft.print(">\n");
        delay(500);
        tft.setCursor(220, 5, 4);
        tft.print("    ");
        delay(500);
    }
    while (digitalRead(buttonPin2) == 0);
}

void CheckInitialO2() {
    initialO2 = Oxygen.ReadOxygenData(COLLECT_NUMBER);
    if (initialO2 < 20.00) {
        tft.fillScreen(TFT_RED);
        tft.setTextColor(TFT_WHITE, TFT_RED);
        tft.setCursor(5, 5, 4);
        tft.println("INITIAL O2% LOW!");
        tft.setCursor(5, 30, 4);
        tft.println("Wait to continue!");
        while (digitalRead(buttonPin1)) {
            initialO2 = Oxygen.ReadOxygenData(COLLECT_NUMBER);
            tft.setCursor(5, 67, 4);
            tft.print("O2: ");
            tft.print(initialO2);
            tft.println(" % ");
            tft.setCursor(5, 105, 4);
            tft.println("Continue              >>>");
            delay(500);
        }
        if (initialO2 < 20.00) initialO2 = 20.90;
        tft.fillScreen(TFT_BLACK);
        tft.setTextColor(TFT_GREEN, TFT_BLACK);
        tft.setCursor(5, 5, 4);
        tft.println("Initial O2% set to:");
        tft.setTextColor(TFT_WHITE, TFT_BLACK);
        tft.setCursor(5, 55, 4);
        tft.print(initialO2);
        tft.println(" % ");
        delay(5000);
    }
}

void CheckInitialCO2() {
    readCO2();
    initialCO2 = co2ppm;
    if (initialCO2 > 1000) {
        tft.fillScreen(TFT_RED);
        tft.setTextColor(TFT_WHITE, TFT_RED);
        tft.setCursor(5, 5, 4);
        tft.println("INITIAL CO2 HIGH!");
        tft.setCursor(5, 30, 4);
        tft.println("Wait to continue!");
        while (digitalRead(buttonPin1)) {
            readCO2();
            initialCO2 = co2ppm;
            tft.setCursor(5, 67, 4);
            tft.print("CO2: ");
            tft.print(initialCO2, 0);
            tft.println(" ppm ");
            tft.setCursor(5, 105, 4);
            tft.println("Continue              >>>");
            delay(500);
        }
        if (initialCO2 > 1000) initialCO2 = 1000;
        tft.fillScreen(TFT_BLACK);
        tft.setTextColor(TFT_GREEN, TFT_BLACK);
        tft.setCursor(5, 5, 4);
        tft.println("Initial CO2 set to:");
        tft.setTextColor(TFT_WHITE, TFT_BLACK);
        tft.setCursor(5, 55, 4);
        tft.print(initialCO2, 0);
        tft.println(" ppm");
        delay(5000);
    }
}

void GetWeightkg() {
    Timer5s = millis();
    int weightChanged = 0;
    tft.fillScreen(TFT_BLUE);
    tft.setTextColor(TFT_WHITE, TFT_BLUE);
    tft.drawString("Enter weight in kg", 20, 10, 4);
    tft.drawString(String(settings.weightkg), 48, 48, 7);
    while ((millis() - Timer5s) < 5000) {
        ReadButtons();
        if (buttonPushCounter1 > 0) {
            settings.weightkg = settings.weightkg - 0.5;
            if (buttonPushCounter1 > 8)
                settings.weightkg = settings.weightkg - 1.5;
            weightChanged = 1;
        }
        if (buttonPushCounter2 > 0) {
            settings.weightkg = settings.weightkg + 0.5;
            if (buttonPushCounter2 > 8)
                settings.weightkg = settings.weightkg + 1.5;
            weightChanged = 1;
        }
        if (settings.weightkg < 20)
            settings.weightkg = 20;
        if (settings.weightkg > 200)
            settings.weightkg = 200;
        if (weightChanged > 0) {
            tft.fillScreen(TFT_BLUE);
            tft.drawString("New weight in kg is:", 10, 10, 4);
            tft.drawString(String(settings.weightkg), 48, 48, 7);
            weightChanged = 0;
            Timer5s = millis();
        }
        delay(200);
    }
}

void readVoltage() {
    uint16_t v = analogRead(ADC_PIN);
    Battery_Voltage = ((float)v / 4095.0) * 2.0 * 3.3 * (vref / 1000.0);
    if (Battery_Voltage >= 4.3)
        tft.setTextColor(TFT_BLACK, TFT_WHITE);
    if (Battery_Voltage < 4.3)
        tft.setTextColor(TFT_BLACK, TFT_GREEN);
    if (Battery_Voltage < 3.9)
        tft.setTextColor(TFT_BLACK, TFT_YELLOW);
    if (Battery_Voltage < 3.7)
        tft.setTextColor(TFT_WHITE, TFT_RED);
    tft.setCursor(0, 0, 4);
    tft.print(String(Battery_Voltage) + "V");
}

bool checkCalibrationConditions() {
    return ((PresPa > 95000) && (TempC >= 20.0 && TempC <= 25.0));
}

bool checkEnvironmentalStability() {
    static float lastTemp = TempC;
    static float lastPressure = PresPa;
    bool stable = (abs(TempC - lastTemp) < 2.0) && (abs(PresPa - lastPressure) < 200.0);
    lastTemp = TempC;
    return stable;
}

void showCalibrationResult(bool passed, float error) {
    tft.fillScreen(passed ? TFT_DARKGREEN : TFT_RED);
    tft.setTextColor(TFT_WHITE);
    tft.drawCentreString(passed ? "CALIBRACION EXITOSA" : "FALLA CALIBRACION", 120, 40, 2);
    tft.drawCentreString("ISO 26782:2023", 120, 100, 2);
    delay(3000);
}

void drawSyringeCalibrationScreen(float volInyectado, float progress) {
    tft.fillScreen(TFT_BLACK);
    tft.setTextColor(TFT_CYAN, TFT_BLACK);
    tft.drawString("FLOW CALIB", 10, 5, 2);
    tft.setTextColor(TFT_RED, TFT_BLACK);
    tft.drawString("CANC", 195, 5, 2);
    tft.drawRect(190, 3, 45, 20, TFT_RED);
    tft.setTextColor(TFT_WHITE, TFT_BLACK);
    tft.drawCentreString("INYECTE 3L", 120, 30, 2);
    tft.drawRect(20, 50, 200, 25, TFT_WHITE);
    int barWidth = (int)(196 * progress);
    tft.fillRect(22, 52, barWidth, 21, TFT_GREEN);
    if (barWidth > 40) {
        tft.setTextColor(TFT_BLACK, TFT_GREEN);
        tft.drawString(String((int)(progress*100)) + "%", barWidth - 30, 55, 2);
    }
    tft.setTextColor(TFT_WHITE, TFT_BLACK);
    tft.drawCentreString("Vol: " + String(volInyectado/1000, 1) + "/3.0L", 120, 85, 2);
    tft.setTextColor(TFT_YELLOW, TFT_BLACK);
    tft.drawString("TEMP", 10, 110, 2);
    tft.drawString("PRESS", 85, 110, 2);
    tft.drawString("ERROR", 170, 110, 2);
    tft.setTextColor(TFT_WHITE, TFT_BLACK);
    tft.drawString(String(TempC, 1) + "C", 10, 130, 2);
    tft.drawString(String(PresPa/100, 0) + "hPa", 85, 130, 2);
    float error = fabs((volInyectado - SYRINGE_VOLUME)/SYRINGE_VOLUME) * 100;
    if (error > CALIB_ALLOWED_ERROR) {
        tft.setTextColor(TFT_RED, TFT_BLACK);
    } else {
        tft.setTextColor(TFT_GREEN, TFT_BLACK);
    }
    tft.drawString(String(error, 1) + "%", 170, 130, 2);
    drawBatteryIndicator();
}

void logCalibration(float measuredVolume, float targetVolume) {
    Serial.println("---CALIBRACIÓN DE FLUJO---");
    Serial.print("Volumen Medido: ");
    Serial.print(measuredVolume);
    Serial.println(" mL");
    Serial.print("Volumen Objetivo: ");
    Serial.print(targetVolume);
    Serial.println(" mL");
    Serial.print("Error: ");
    Serial.print(fabs((measuredVolume - targetVolume)/targetVolume)*100, 2);
    Serial.println("%");
    Serial.print("Temperatura: ");
    Serial.print(TempC);
    Serial.println(" °C");
    Serial.print("Presión: ");
    Serial.print(PresPa/100);
    Serial.println(" hPa");
}

bool performSyringeCalibration() {
    float totalVolume = 0;
    uint32_t startTime = millis();
    bool stableEnvironment = checkCalibrationConditions();
    uint32_t lastMeasure = millis();
    if (!stableEnvironment) {
        tft.fillScreen(TFT_YELLOW);
        tft.setTextColor(TFT_BLACK, TFT_YELLOW);
        tft.drawCentreString("ADVERTENCIA", 120, 40, 4);
        tft.drawCentreString("Condiciones ambientales", 120, 80, 2);
        tft.drawCentreString("fuera de rango ideal", 120, 100, 2);
        delay(2000);
    }
    volumeTotal2 = 0;
    TimerStart = millis();
    TimerVolCalc = millis();
    tft.fillScreen(TFT_BLACK);
    tft.setTextColor(TFT_CYAN, TFT_BLACK);
    tft.drawCentreString("CALIBRACION DE FLUJO", 120, 30, 2);
    tft.setTextColor(TFT_WHITE, TFT_BLACK);
    tft.drawCentreString("Prepare jeringa de 3L", 120, 60, 2);
    tft.drawCentreString("Presione para comenzar", 120, 90, 2);
    while (digitalRead(buttonPin1)) { delay(50); }
    while (!digitalRead(buttonPin1)) { delay(50); }
    while((millis() - startTime) < CALIB_TIMEOUT_MS) {
        VolumeCalc();
        totalVolume = volumeTotal2;
        if (millis() - lastMeasure >= 100) {
            lastMeasure = millis();
            float progress = constrain(totalVolume / SYRINGE_VOLUME, 0, 1);
            drawSyringeCalibrationScreen(totalVolume, progress);
            if(!checkEnvironmentalStability()) {
                showError("Condiciones inestables!", false); // Agregado argumento critical
                logCalibration(totalVolume, SYRINGE_VOLUME);
                return false;
            }
        }
        if (!digitalRead(buttonPin2)) {
            tft.fillScreen(TFT_BLACK);
            tft.setTextColor(TFT_YELLOW, TFT_BLACK);
            tft.drawCentreString("CALIBRACION CANCELADA", 120, 60, 2);
            delay(2000);
            return false;
        }
        if(!digitalRead(buttonPin1) || totalVolume >= SYRINGE_VOLUME) {
            break;
        }
    }
    TimerVolCalc = millis();
    float error = fabs((totalVolume - SYRINGE_VOLUME)/SYRINGE_VOLUME) * 100;
    bool passed = (error <= CALIB_ALLOWED_ERROR);
    if(passed) {
        settings.correctionSensor = SYRINGE_VOLUME / totalVolume;
        saveSettings();
    }
    logCalibration(totalVolume, SYRINGE_VOLUME);
    showCalibrationResult(passed, error);
    return passed;
}

/**
 * Guarda la configuración en EEPROM (función de compatibilidad)
 * Redirige a la nueva función con checksum
 */
void saveSettings() {
    saveSettingsWithChecksum();
}

/**
 * Carga la configuración desde EEPROM (función de compatibilidad)
 * Redirige a la nueva función con verificación de integridad
 */
void loadSettings() {
    if (!loadSettingsWithChecksum()) {
        Serial.println("Fallo al cargar configuración, usando valores por defecto");
    }
}

/**
 * Muestra mensajes de error en pantalla con severidad diferenciada
 * @param message Mensaje de error a mostrar
 * @param critical Si es true, muestra error crítico (rojo), sino advertencia (naranja)
 */
void showError(const char* message, bool critical) {
    tft.fillScreen(critical ? TFT_RED : TFT_ORANGE);
    tft.setTextColor(TFT_WHITE, critical ? TFT_RED : TFT_ORANGE);
    tft.drawCentreString("ERROR", 120, 40, 4);
    tft.drawCentreString(message, 120, 80, 2);
    
    // Log del error también por serial
    Serial.printf("[%s] %s\n", critical ? "CRITICO" : "ADVERTENCIA", message);
    
    delay(critical ? 3000 : 1500);
}

// --- MODO VO2 COMPATIBLE CON VERSION 1 CURVO ---
void runVO2Mode() {
    // Inicialización de hardware y sensores (ajustado a versión 1 Curvo)
    Wire.begin();
    Serial.begin(115200);
    if (!Serial) {
        tft.drawString("Serial ERROR!", 0, 0, 4);
    } else {
        tft.drawString("Serial ok", 0, 0, 4);
    }
    // Bluetooth Serial clásico (si aplica)
    #ifdef HAS_SERIALBT
    if (!SerialBT.begin("VO2Smartmax")) {
        tft.drawString("BT NOT ready!", 0, 25, 4);
    } else {
        tft.drawString("BT ready", 0, 25, 4);
    }
    #endif
    if (!bmp.begin(0x76)) { // Especificar la dirección I2C del BMP280 0x76
        tft.drawString("Temp/Pres. Error!", 0, 50, 4);
    } else {
        tft.drawString("Temp/Pres. ok", 0, 50, 4);
    }
    if (!Oxygen.begin(Oxygen_IICAddress)) {
        tft.drawString("O2-Sensor ERROR!", 0, 75, 4);
    } else {
        tft.drawString("O2-Sensor ok", 0, 75, 4);
    }
    while (!mySensor.begin(MODEL_0025AD2)) {
        tft.drawString("Flow-Sensor ERROR!", 0, 100, 4);
    }
    tft.drawString("Flow-Sensor ok", 0, 100, 4);
    delay(2000);
    // BLE inicialización (si aplica)
    #ifdef HAS_BLE
    setupBLE();
    #endif
    bpm = 30;
    initialO2 = Oxygen.ReadOxygenData(COLLECT_NUMBER);
    if (initialO2 < 20.00) {
        tft.fillScreen(TFT_RED);
        tft.setTextColor(TFT_WHITE, TFT_RED);
        tft.setCursor(5, 5, 4);
        tft.println("INITIAL O2% LOW!");
        tft.setCursor(5, 30, 4);
        tft.println("Wait to continue!");
        while (digitalRead(buttonPin1)) {
            initialO2 = Oxygen.ReadOxygenData(COLLECT_NUMBER);
            tft.setCursor(5, 67, 4);
            tft.println("O2%: ");
            tft.setCursor(120, 67, 4);
            tft.println(initialO2);
            tft.setCursor(5, 105, 4);
            tft.println("Continue              >>>");
            delay(500);
        }
        if (initialO2 < 20.00) initialO2 = 20.90;
        tft.fillScreen(TFT_BLACK);
        tft.setTextColor(TFT_GREEN, TFT_BLACK);
        tft.setCursor(5, 5, 4);
        tft.println("Initial O2% set to:");
        tft.setTextColor(TFT_WHITE, TFT_BLACK);
        tft.setCursor(100, 55, 4);
        tft.println(initialO2);
        delay(5000);
    }
    GetWeightkg();
    AirDensity();
    tftParameters();
    while (digitalRead(buttonPin2)) {
        tft.setCursor(220, 5, 4);
        tft.print(">\n");
        delay(500);
        tft.setCursor(220, 5, 4);
        tft.print("    ");
        delay(500);
    }
    tft.fillScreen(TFT_BLACK);
    tft.setTextColor(TFT_WHITE, TFT_BLACK);
    tft.setCursor(0, 5, 4);
    tft.println("Use 3L calib.pump");
    tft.setCursor(0, 30, 4);
    tft.println("for sensor check.");
    tft.setCursor(0, 105, 4);
    tft.setTextColor(TFT_GREEN, TFT_BLACK);
    tft.println("Press to start      >>>");
    while (digitalRead(buttonPin1));
    tft.fillScreen(TFT_BLACK);
    tft.setTextColor(TFT_GREEN, TFT_BLACK);
    TimerVolCalc = millis();
    Timer5s = millis();
    Timer1min = millis();
    TimerVO2calc = millis();
    TimerStart = millis();
    TotalTime = 0;
    
    // Bucle principal del modo VO2
    bool vo2Active = true;
    while (vo2Active) {
        TotalTime = millis() - TimerStart;
        VolumeCalc();

        // Cálculo de VO2 cada 5 segundos
        if ((millis() - TimerVO2calc) > 5000 && pressure < 0.2) {
            TimerVO2diff = millis() - TimerVO2calc;
            TimerVO2calc = millis();
            vo2maxCalc();
            if (TotalTime >= 10000) {
                showScreen();
                volumeTotal2 = 0;
                readVoltage();
            }
                        StreamBT();
                        delay(100);
        }

        // Envío BLE cada segundo
        if (millis() - lastBLESend > 1000) {
            lastBLESend = millis();
            sendBLEData();
        }
        
        // Navegación entre pantallas
        handleVO2Navigation();

        // Salir del modo VO2 si ambos botones se mantienen presionados
            if (buttonPushCounter1 > 20 && buttonPushCounter2 > 20) {
                vo2Active = false;
                showCarouselMenu();
                return;
            }
                        }
        }
        
/**
 * Cálculo optimizado de densidad del aire con correcciones ambientales
 * Implementa la ecuación de gas ideal con factores de corrección específicos
 * 
 * Ecuaciones utilizadas:
 * 1. Densidad aire seco: ρ = P / (R_específico × T)
 * 2. Condiciones BTPS: Body Temperature Pressure Saturated (37°C, saturado)
 * 3. Condiciones STPD: Standard Temperature Pressure Dry (0°C, seco, 1 atm)
 */
void AirDensity() {
    static unsigned long lastSuccessfulReading = 0;
    static float lastValidTemp = 20.0;
    static float lastValidPressure = 101325.0;
    
    // Protección con mutex para operaciones críticas
    if (sensorDataMutex == NULL) {
        sensorDataMutex = xSemaphoreCreateMutex();
    }
    
    if (!xSemaphoreTake(sensorDataMutex, pdMS_TO_TICKS(100))) {
        logSensorError("AirDensity", 0, "Timeout mutex densidad");
        return;
    }
    
    // Leer temperatura y presión del sensor BMP280
    float tempReading = bmp.readTemperature();
    float pressureReading = bmp.readPressure();
    
    // Validar lecturas del sensor ambiental
    bool tempValid = isValidTemperatureReading(tempReading);
    bool pressureValid = validateSensorData(pressureReading, ATMOSPHERIC_PRESSURE_MIN, ATMOSPHERIC_PRESSURE_MAX, "PresionAtm");
    
    if (!tempValid || !pressureValid) {
        sensorErrors.temperatureErrors++;
        sensorErrors.lastTempErrorTime = millis();
        
        // Usar últimos valores válidos si están disponibles y son recientes
        if (millis() - lastSuccessfulReading < 30000) { // 30 segundos
            TempC = lastValidTemp;
            PresPa = lastValidPressure;
            Serial.println("Usando últimas lecturas ambientales válidas");
        } else {
            // Usar valores por defecto después de 30 segundos sin lecturas válidas
            TempC = 20.0; // °C - temperatura ambiente típica
            PresPa = 101325.0; // Pa - presión atmosférica estándar
            logSensorError("Ambiental", 0, "Usando valores por defecto");
        }
        
        // Mostrar error crítico si es NaN
        if (isnan(tempReading) || isnan(pressureReading)) {
            showError("Sensor ambiental error!", true);
        }
    } else {
        // Lecturas válidas: actualizar valores
        TempC = tempReading;
        PresPa = pressureReading;
        lastSuccessfulReading = millis();
        lastValidTemp = TempC;
        lastValidPressure = PresPa;
    }
    
    // ============================================================================
    // CÁLCULO DE DENSIDADES SEGÚN CONDICIONES ESTÁNDAR
    // ============================================================================
    
    /**
     * Constantes físicas utilizadas:
     * - R_específico_aire_seco = 287.058 J/(kg·K) - Constante específica del aire seco
     * - R_específico_aire_húmedo ≈ 292.9 J/(kg·K) - Para condiciones BTPS
     */
    const float R_AIRE_SECO = 287.058;    // J/(kg·K)
    const float R_AIRE_HUMEDO = 292.9;    // J/(kg·K) aproximado para aire saturado
    
    // Convertir temperatura a Kelvin
    float tempK = TempC + 273.15;
    
    // Validar temperatura en Kelvin (debe ser > 0 y < 400K para ser realista)
    if (tempK <= 0 || tempK > 400) {
        logSensorError("TempKelvin", tempK, "Temperatura absoluta fuera de rango");
        tempK = 293.15; // 20°C por defecto
    }
    
    /**
     * Densidad del aire seco en condiciones actuales:
     * ρ = P / (R_específico × T)
     * 
     * Esta es la densidad real del aire en las condiciones ambientales medidas
     */
    rho = PresPa / (R_AIRE_SECO * tempK);
    
    /**
     * Densidad BTPS (Body Temperature Pressure Saturated):
     * Condiciones corporales: 37°C, presión ambiental, saturado de vapor
     * 
     * Se usa para corregir volúmenes medidos a condiciones corporales
     */
    float tempBTPS = 37.0 + 273.15; // 37°C en Kelvin
    rhoBTPS = PresPa / (R_AIRE_HUMEDO * tempBTPS);
    
    /**
     * Densidad STPD (Standard Temperature Pressure Dry):
     * Condiciones estándar: 0°C, 1 atm (101325 Pa), aire seco
     * 
     * Se usa como referencia para normalizar mediciones
     */
    float tempSTPD = 0.0 + 273.15; // 0°C en Kelvin
    float presSTPD = 101325.0;     // 1 atm en Pa
    rhoSTPD = presSTPD / (R_AIRE_SECO * tempSTPD);
    
    // Validar densidades calculadas
    if (rho <= 0 || rho > 2.0 || rhoBTPS <= 0 || rhoBTPS > 2.0) {
        logSensorError("Densidad", rho, "Densidades calculadas inválidas");
        
        // Usar densidades estándar como fallback
        rho = 1.225;     // kg/m³ - densidad estándar del aire
        rhoBTPS = 1.123; // kg/m³ - densidad en condiciones BTPS
        rhoSTPD = 1.292; // kg/m³ - densidad en condiciones STPD
    }
    
    xSemaphoreGive(sensorDataMutex);
    
    // Log periódico de condiciones ambientales (cada 2 minutos)
    static unsigned long lastEnvironmentalLog = 0;
    if (millis() - lastEnvironmentalLog > 120000) {
        Serial.printf("Ambiente: %.1f°C, %.0f hPa, ρ=%.3f kg/m³\n", 
                     TempC, PresPa/100.0, rho);
        Serial.printf("Correcciones: BTPS=%.3f, STPD=%.3f kg/m³\n", 
                     rhoBTPS, rhoSTPD);
        lastEnvironmentalLog = millis();
    }
    
    // Verificación de condiciones extremas para advertencias
    if (TempC < 5.0 || TempC > 40.0) {
        static unsigned long lastTempWarning = 0;
        if (millis() - lastTempWarning > 60000) { // Cada minuto máximo
            Serial.printf("ADVERTENCIA: Temperatura extrema %.1f°C\n", TempC);
            lastTempWarning = millis();
        }
    }
    
    if (PresPa < 90000 || PresPa > 110000) { // Fuera del rango típico al nivel del mar
        static unsigned long lastPressWarning = 0;
        if (millis() - lastPressWarning > 60000) {
            Serial.printf("ADVERTENCIA: Presión atípica %.0f hPa\n", PresPa/100.0);
            lastPressWarning = millis();
        }
    }
}
